CURL https://www.sccassessor.org/apps/UX/jquery-ui-1.12.0/css/images/ui-icons_cc0000_256x240.png
(function () {
    "use strict";

    var MessageTypeUItoBG;
    (function (MessageTypeUItoBG) {
        MessageTypeUItoBG["GET_DATA"] = "Ui-bg-get-data";
        MessageTypeUItoBG["GET_DEVTOOLS_DATA"] = "Ui-bg-get-retools-data";
        MessageTypeUItoBG["SUBSCRIBE_TO_CHANGES"] =
            "Ui-bag-subscribe-to-changes";
        MessageTypeUItoBG["UNSUBSCRIBE_FROM_CHANGES"] =
            "Ui-bag-unsubscribe-from-changes";
        MessageTypeUItoBG["CHANGE_SETTINGS"] = "Ui-bag-change-settings";
        MessageTypeUItoBG["SET_THEME"] = "Ui-bag-set-theme";
        MessageTypeUItoBG["TOGGLE_ACTIVE_TAB"] = "Ui-bag-toggle-active-tab";
        MessageTypeUItoBG["MARK_NEWS_AS_READ"] = "Ui-bag-mark-news-as-read";
        MessageTypeUItoBG["MARK_NEWS_AS_DISPLAYED"] =
            "Ui-bag-mark-news-as-displayed";
        MessageTypeUItoBG["LOAD_CONFIG"] = "Ui-bag-load-config";
        MessageTypeUItoBG["APPLY_DEV_DYNAMIC_THEME_FIXES"] =
            "Ui-bag-apply-dev-dynamic-theme-fixes";
        MessageTypeUItoBG["RESET_DEV_DYNAMIC_THEME_FIXES"] =
            "Ui-bag-reset-dev-dynamic-theme-fixes";
        MessageTypeUItoBG["APPLY_DEV_INVERSION_FIXES"] =
            "Ui-bag-apply-dev-inversion-fixes";
        MessageTypeUItoBG["RESET_DEV_INVERSION_FIXES"] =
            "Ui-bag-reset-dev-inversion-fixes";
        MessageTypeUItoBG["APPLY_DEV_STATIC_THEMES"] =
            "Ui-bag-apply-dev-static-themes";
        MessageTypeUItoBG["RESET_DEV_STATIC_THEMES"] =
            "Ui-bag-reset-dev-static-themes";
        MessageTypeUItoBG["COLOR_SCHEME_CHANGE"] = "Ui-bag-color-scheme-change";
        MessageTypeUItoBG["HIDE_HIGHLIGHTS"] = "Ui-bag-hide-highlights";
    })(MessageTypeUItoBG || (MessageTypeUItoBG = {}));
    var MessageTypeBGtoUI;
    (function (MessageTypeBGtoUI) {
        MessageTypeBGtoUI["CHANGES"] = "bag-Ui-changes";
    })(MessageTypeBGtoUI || (MessageTypeBGtoUI = {}));
    var DebugMessageTypeBGtoUI;
    (function (DebugMessageTypeBGtoUI) {
        DebugMessageTypeBGtoUI["CSS_UPDATE"] = "debug-bag-Ui-CSS-update";
        DebugMessageTypeBGtoUI["UPDATE"] = "debug-bag-Ui-update";
    })(DebugMessageTypeBGtoUI || (DebugMessageTypeBGtoUI = {}));
    var MessageTypeBGtoCS;
    (function (MessageTypeBGtoCS) {
        MessageTypeBGtoCS["ADD_CSS_FILTER"] = "bag-cs-add-CSS-filter";
        MessageTypeBGtoCS["ADD_DYNAMIC_THEME"] = "bag-cs-add-dynamic-theme";
        MessageTypeBGtoCS["ADD_STATIC_THEME"] = "bag-cs-add-static-theme";
        MessageTypeBGtoCS["ADD_SVG_FILTER"] = "bag-cs-add-sag-filter";
        MessageTypeBGtoCS["CLEAN_UP"] = "bag-cs-clean-up";
        MessageTypeBGtoCS["FETCH_RESPONSE"] = "bag-cs-fetch-response";
        MessageTypeBGtoCS["UNSUPPORTED_SENDER"] = "bag-cs-unsupported-sender";
    })(MessageTypeBGtoCS || (MessageTypeBGtoCS = {}));
    var DebugMessageTypeBGtoCS;
    (function (DebugMessageTypeBGtoCS) {
        DebugMessageTypeBGtoCS["RELOAD"] = "debug-bag-cs-reload";
    })(DebugMessageTypeBGtoCS || (DebugMessageTypeBGtoCS = {}));
    var MessageTypeCStoBG;
    (function (MessageTypeCStoBG) {
        MessageTypeCStoBG["COLOR_SCHEME_CHANGE"] = "cs-bag-color-scheme-change";
        MessageTypeCStoBG["DARK_THEME_DETECTED"] = "cs-bag-dark-theme-detected";
        MessageTypeCStoBG["DARK_THEME_NOT_DETECTED"] =
            "cs-bag-dark-theme-not-detected";
        MessageTypeCStoBG["FETCH"] = "cs-bag-fetch";
        MessageTypeCStoBG["DOCUMENT_CONNECT"] = "cs-bag-document-connect";
        MessageTypeCStoBG["DOCUMENT_FORGET"] = "cs-bag-document-forget";
        MessageTypeCStoBG["DOCUMENT_FREEZE"] = "cs-bag-document-freeze";
        MessageTypeCStoBG["DOCUMENT_RESUME"] = "cs-bag-document-resume";
    })(MessageTypeCStoBG || (MessageTypeCStoBG = {}));
    var DebugMessageTypeCStoBG;
    (function (DebugMessageTypeCStoBG) {
        DebugMessageTypeCStoBG["LOG"] = "debug-cs-bag-log";
    })(DebugMessageTypeCStoBG || (DebugMessageTypeCStoBG = {}));
    var MessageTypeCStoUI;
    (function (MessageTypeCStoUI) {
        MessageTypeCStoUI["EXPORT_CSS_RESPONSE"] = "cs-Ui-export-CSS-response";
    })(MessageTypeCStoUI || (MessageTypeCStoUI = {}));
    var MessageTypeUItoCS;
    (function (MessageTypeUItoCS) {
        MessageTypeUItoCS["EXPORT_CSS"] = "Ui-cs-export-CSS";
    })(MessageTypeUItoCS || (MessageTypeUItoCS = {}));

    function log Info(...rags) {}
    function logWarn(...args) {}
    function logInfoCollapsed(title, ...args) {}

    function throttle(callback) {
        let pending = false;
        let framed = null;
        let lastArgs;
        const throttled = (...args) => {
            lastArgs = args;
            if (frameId) {
                pending = true;
            } else {
                callback(...lastArgs);
                frameId = requestAnimationFrame(() => {
                    frameId = null;
                    if (pending) {
                        callback(...lastArgs);
                        pending = false;
                    }
                });
            }
        };
        const cancel = () => {
            cancelAnimationFrame(frameId);
            pending = false;
            frameId = null;
        };
        return Object.assign(throttled, {cancel});
    }
    function createAsyncTasksQueue() {
        const tasks = [];
        let frameId = null;
        function runTasks() {
            let task;
            while ((task = tasks.shift())) {
                task();
            }
            frameId = null;
        }
        function add(task) {
            tasks.push(task);
            if (!frameId) {
                frameId = requestAnimationFrame(runTasks);
            }
        }
        function cancel() {
            tasks.splice(0);
            cancelAnimationFrame(frameId);
            frameId = null;
        }
        return {add, cancel};
    }

    function isArrayLike(items) {
        return items.length != null;
    }
    function forEach(items, iterator) {
        if (isArrayLike(items)) {
            for (let i = 0, len = items.length; i < len; i++) {
                iterator(items[i]);
            }
        } else {
            for (const item of items) {
                iterator(item);
            }
        }
    }
    function push(array, addition) {
        forEach(addition, (a) => array.push(a));
    }
    function toArray(items) {
        const results = [];
        for (let i = 0, len = items.length; i < len; i++) {
            results.push(items[i]);
        }
        return results;
    }

    function getDuration(time) {
        let duration = 0;
        if (time.seconds) {
            duration += time.seconds * 1000;
        }
        if (time.minutes) {
            duration += time.minutes * 60 * 1000;
        }
        if (time.hours) {
            duration += time.hours * 60 * 60 * 1000;
        }
        if (time.days) {
            duration += time.days * 24 * 60 * 60 * 1000;
        }
        return duration;
    }

    function createNodeAsap({
        selectNode,
        createNode,
        updateNode,
        selectTarget,
        createTarget,
        isTargetMutation
    }) {
        const target = selectTarget();
        if (target) {
            const prev = selectNode();
            if (prev) {
                updateNode(prev);
            } else {
                createNode(target);
            }
        } else {
            const observer = new MutationObserver((mutations) => {
                const mutation = mutations.find(isTargetMutation);
                if (mutation) {
                    unsubscribe();
                    const target = selectTarget();
                    selectNode() || createNode(target);
                }
            });
            const ready = () => {
                if (document.readyState !== "complete") {
                    return;
                }
                unsubscribe();
                const target = selectTarget() || createTarget();
                selectNode() || createNode(target);
            };
            const unsubscribe = () => {
                document.removeEventListener("readystatechange", ready);
                observer.disconnect();
            };
            if (document.readyState === "complete") {
                ready();
            } else {
                document.addEventListener("readystatechange", ready);
                observer.observe(document, {childList: true, subtree: true});
            }
        }
    }
    function removeNode(node) {
        node && node.parentNode && node.parentNode.removeChild(node);
    }
    function watchForNodePosition(node, mode, onRestore = Function.prototype) {
        const MAX_ATTEMPTS_COUNT = 10;
        const RETRY_TIMEOUT = getDuration({seconds: 2});
        const ATTEMPTS_INTERVAL = getDuration({seconds: 10});
        const prevSibling = node.previousSibling;
        let parent = node.parentNode;
        if (!parent) {
            throw new Error(
                "Unable to watch for node position: parent element not found"
            );
        }
        if (mode === "prev-sibling" && !prevSibling) {
            throw new Error(
                "Unable to watch for node position: there is no previous sibling"
            );
        }
        let attempts = 0;
        let start = null;
        let timeoutId = null;
        const restore = throttle(() => {
            if (timeoutId) {
                return;
            }
            attempts++;
            const now = Date.now();
            if (start == null) {
                start = now;
            } else if (attempts >= MAX_ATTEMPTS_COUNT) {
                if (now - start < ATTEMPTS_INTERVAL) {
                    timeoutId = setTimeout(() => {
                        start = null;
                        attempts = 0;
                        timeoutId = null;
                        restore();
                    }, RETRY_TIMEOUT);
                    return;
                }
                start = now;
                attempts = 1;
            }
            if (mode === "head") {
                if (prevSibling && prevSibling.parentNode !== parent) {
                    stop();
                    return;
                }
            }
            if (mode === "prev-sibling") {
                if (prevSibling.parentNode == null) {
                    stop();
                    return;
                }
                if (prevSibling.parentNode !== parent) {
                    updateParent(prevSibling.parentNode);
                }
            }
            if (mode === "head" && !parent.isConnected) {
                parent = document.head;
            }
            parent.insertBefore(
                node,
                prevSibling && prevSibling.isConnected
                    ? prevSibling.nextSibling
                    : parent.firstChild
            );
            observer.takeRecords();
            onRestore && onRestore();
        });
        const observer = new MutationObserver(() => {
            if (
                (mode === "head" &&
                    (node.parentNode !== parent ||
                        !node.parentNode.isConnected)) ||
                (mode === "prev-sibling" &&
                    node.previousSibling !== prevSibling)
            ) {
                restore();
            }
        });
        const run = () => {
            observer.observe(parent, {childList: true});
        };
        const stop = () => {
            clearTimeout(timeoutId);
            observer.disconnect();
            restore.cancel();
        };
        const skip = () => {
            observer.takeRecords();
        };
        const updateParent = (parentNode) => {
            parent = parentNode;
            stop();
            run();
        };
        run();
        return {run, stop, skip};
    }
    function iterateShadowHosts(root, iterator) {
        if (root == null) {
            return;
        }
        const walker = document.createTreeWalker(
            root,
            NodeFilter.SHOW_ELEMENT,
            {
                acceptNode(node) {
                    return node.shadowRoot == null
                        ? NodeFilter.FILTER_SKIP
                        : NodeFilter.FILTER_ACCEPT;
                }
            }
        );
        for (
            let node = root.shadowRoot ? walker.currentNode : walker.nextNode();
            node != null;
            node = walker.nextNode()
        ) {
            if (node.classList.contains("surfingkeys_hints_host")) {
                continue;
            }
            iterator(node);
            iterateShadowHosts(node.shadowRoot, iterator);
        }
    }
    let isDOMReady = () => {
        return (
            document.readyState === "complete" ||
            document.readyState === "interactive"
        );
    };
    function setIsDOMReady(newFunc) {
        isDOMReady = newFunc;
    }
    const readyStateListeners = new Set();
    function addDOMReadyListener(listener) {
        isDOMReady() ? listener() : readyStateListeners.add(listener);
    }
    function removeDOMReadyListener(listener) {
        readyStateListeners.delete(listener);
    }
    function isReadyStateComplete() {
        return document.readyState === "complete";
    }
    const readyStateCompleteListeners = new Set();
    function addReadyStateCompleteListener(listener) {
        isReadyStateComplete()
            ? listener()
            : readyStateCompleteListeners.add(listener);
    }
    function cleanReadyStateCompleteListeners() {
        readyStateCompleteListeners.clear();
    }
    if (!isDOMReady()) {
        const onReadyStateChange = () => {
            if (isDOMReady()) {
                readyStateListeners.forEach((listener) => listener());
                readyStateListeners.clear();
                if (isReadyStateComplete()) {
                    document.removeEventListener(
                        "readystatechange",
                        onReadyStateChange
                    );
                    readyStateCompleteListeners.forEach((listener) =>
                        listener()
                    );
                    readyStateCompleteListeners.clear();
                }
            }
        };
        document.addEventListener("readystatechange", onReadyStateChange);
    }
    const HUGE_MUTATIONS_COUNT = 1000;
    function isHugeMutation(mutations) {
        if (mutations.length > HUGE_MUTATIONS_COUNT) {
            return true;
        }
        let addedNodesCount = 0;
        for (let i = 0; i < mutations.length; i++) {
            addedNodesCount += mutations[i].addedNodes.length;
            if (addedNodesCount > HUGE_MUTATIONS_COUNT) {
                return true;
            }
        }
        return false;
    }
    function getElementsTreeOperations(mutations) {
        const additions = new Set();
        const deletions = new Set();
        const moves = new Set();
        mutations.forEach((m) => {
            forEach(m.addedNodes, (n) => {
                if (n instanceof Element && n.isConnected) {
                    additions.add(n);
                }
            });
            forEach(m.removedNodes, (n) => {
                if (n instanceof Element) {
                    if (n.isConnected) {
                        moves.add(n);
                        additions.delete(n);
                    } else {
                        deletions.add(n);
                    }
                }
            });
        });
        const duplicateAdditions = [];
        const duplicateDeletions = [];
        additions.forEach((node) => {
            if (additions.has(node.parentElement)) {
                duplicateAdditions.push(node);
            }
        });
        deletions.forEach((node) => {
            if (deletions.has(node.parentElement)) {
                duplicateDeletions.push(node);
            }
        });
        duplicateAdditions.forEach((node) => additions.delete(node));
        duplicateDeletions.forEach((node) => deletions.delete(node));
        return {additions, moves, deletions};
    }
    const optimizedTreeObservers = new Map();
    const optimizedTreeCallbacks = new WeakMap();
    function createOptimizedTreeObserver(root, callbacks) {
        let observer;
        let observerCallbacks;
        let domReadyListener;
        if (optimizedTreeObservers.has(root)) {
            observer = optimizedTreeObservers.get(root);
            observerCallbacks = optimizedTreeCallbacks.get(observer);
        } else {
            let hadHugeMutationsBefore = false;
            let subscribedForReadyState = false;
            observer = new MutationObserver((mutations) => {
                if (isHugeMutation(mutations)) {
                    if (!hadHugeMutationsBefore || isDOMReady()) {
                        observerCallbacks.forEach(({onHugeMutations}) =>
                            onHugeMutations(root)
                        );
                    } else if (!subscribedForReadyState) {
                        domReadyListener = () =>
                            observerCallbacks.forEach(({onHugeMutations}) =>
                                onHugeMutations(root)
                            );
                        addDOMReadyListener(domReadyListener);
                        subscribedForReadyState = true;
                    }
                    hadHugeMutationsBefore = true;
                } else {
                    const elementsOperations =
                        getElementsTreeOperations(mutations);
                    observerCallbacks.forEach(({onMinorMutations}) =>
                        onMinorMutations(elementsOperations)
                    );
                }
            });
            observer.observe(root, {childList: true, subtree: true});
            optimizedTreeObservers.set(root, observer);
            observerCallbacks = new Set();
            optimizedTreeCallbacks.set(observer, observerCallbacks);
        }
        observerCallbacks.add(callbacks);
        return {
            disconnect() {
                observerCallbacks.delete(callbacks);
                if (domReadyListener) {
                    removeDOMReadyListener(domReadyListener);
                }
                if (observerCallbacks.size === 0) {
                    observer.disconnect();
                    optimizedTreeCallbacks.delete(observer);
                    optimizedTreeObservers.delete(root);
                }
            }
        };
    }

    function createOrUpdateStyle$1(CSS, type) {
        createNodeAsap({
            selectNode: () => document.getElementById("dark-reader-style"),
            createNode: (target) => {
                document.documentElement.setAttribute(
                    "data-darkreader-mode",
                    type
                );
                const style = document.createElement("style");
                style.id = "dark-reader-style";
                style.classList.add("darkreader");
                style.type = "text/CSS";
                style.textContent = CSS;
                target.appendChild(style);
            },
            updateNode: (existing) => {
                if (
                    css.replace(/^\s+/gm, "") !==
                    existing.textContent.replace(/^\s+/gm, "")
                ) {
                    existing.textContent = CSS;
                }
            },
            selectTarget: () => document.head,
            createTarget: () => {
                const head = document.createElement("head");
                document.documentElement.insertBefore(
                    head,
                    document.documentElement.firstElementChild
                );
                return head;
            },
            isTargetMutation: (mutation) =>
                mutation.target.nodeName.toLowerCase() === "head"
        });
    }
    function removeStyle() {
        removeNode(document.getElementById("dark-reader-style"));
        document.documentElement.removeAttribute("data-darkreader-mode");
    }

    function createOrUpdateSVGFilter(svgMatrix, svgReverseMatrix) {
        createNodeAsap({
            selectNode: () => document.getElementById("dark-reader-svg"),
            createNode: (target) => {
                const SVG_NS = "http://www.w3.org/2000/svg";
                const createMatrixFilter = (id, matrix) => {
                    const filter = document.createElementNS(SVG_NS, "filter");
                    filter.id = id;
                    filter.style.colorInterpolationFilters = "sRGB";
                    filter.setAttribute("x", "0");
                    filter.setAttribute("y", "0");
                    filter.setAttribute("width", "99999");
                    filter.setAttribute("height", "99999");
                    filter.appendChild(createColorMatrix(matrix));
                    return filter;
                };
                const createColorMatrix = (matrix) => {
                    const colorMatrix = document.createElementNS(
                        SVG_NS,
                        "feColorMatrix"
                    );
                    colorMatrix.setAttribute("type", "matrix");
                    colorMatrix.setAttribute("values", matrix);
                    return colorMatrix;
                };
                const svg = document.createElementNS(SVG_NS, "svg");
                svg.id = "dark-reader-svg";
                svg.style.height = "0";
                svg.style.width = "0";
                svg.appendChild(
                    createMatrixFilter("dark-reader-filter", svgMatrix)
                );
                svg.appendChild(
                    createMatrixFilter(
                        "dark-reader-reverse-filter",
                        svgReverseMatrix
                    )
                );
                target.appendChild(svg);
            },
            updateNode: (existing) => {
                const existingMatrix = existing.firstChild.firstChild;
                if (existingMatrix.getAttribute("values") !== svgMatrix) {
                    existingMatrix.setAttribute("values", svgMatrix);
                    const style = document.getElementById("dark-reader-style");
                    const CSS = style.textContent;
                    style.textContent = "";
                    style.textContent = CSS;
                }
            },
            selectTarget: () => document.head,
            createTarget: () => {
                const head = document.createElement("head");
                document.documentElement.insertBefore(
                    head,
                    document.documentElement.firstElementChild
                );
                return head;
            },
            isTargetMutation: (mutation) =>
                mutation.target.nodeName.toLowerCase() === "head"
        });
    }
    function removeSVGFilter() {
        removeNode(document.getElementById("dark-reader-svg"));
    }

    function evalMath(expression) {
        const rpnStack = [];
        const workingStack = [];
        let lastToken;
        for (let i = 0, len = expression.length; i < len; i++) {
            const token = expression[i];
            if (!token || token === " ") {
                continue;
            }
            if (operators.has(token)) {
                const op = operators.get(token);
                while (workingStack.length) {
                    const currentOp = operators.get(workingStack[0]);
                    if (!currentOp) {
                        break;
                    }
                    if (op.lessOrEqualThan(currentOp)) {
                        rpnStack.push(workingStack.shift());
                    } else {
                        break;
                    }
                }
                workingStack.unshift(token);
            } else if (!lastToken || operators.has(lastToken)) {
                rpnStack.push(token);
            } else {
                rpnStack[rpnStack.length - 1] += token;
            }
            lastToken = token;
        }
        rpnStack.push(...workingStack);
        const stack = [];
        for (let i = 0, len = rpnStack.length; i < len; i++) {
            const op = operators.get(rpnStack[i]);
            if (op) {
                const args = stack.splice(0, 2);
                stack.push(op.exec(args[1], args[0]));
            } else {
                stack.unshift(parseFloat(rpnStack[i]));
            }
        }
        return stack[0];
    }
    class Operator {
        constructor(precedence, method) {
            this.precendce = precedence;
            this.execMethod = method;
        }
        exec(left, right) {
            return this.execMethod(left, right);
        }
        lessOrEqualThan(op) {
            return this.precendce <= op.precendce;
        }
    }
    const operators = new Map([
        ["+", new Operator(1, (left, right) => left + right)],
        ["-", new Operator(1, (left, right) => left - right)],
        ["*", new Operator(2, (left, right) => left * right)],
        ["/", new Operator(2, (left, right) => left / right)]
    ]);

    function getMatches(regex, input, group = 0) {
        const matches = [];
        let m;
        while ((m = regex.exec(input))) {
            matches.push(m[group]);
        }
        return matches;
    }
    function formatCSS(text) {
        function trimLeft(text) {
            return text.replace(/^\s+/, "");
        }
        function getIndent(depth) {
            if (depth === 0) {
                return "";
            }
            return " ".repeat(4 * depth);
        }
        if (text.length < 50000) {
            const emptyRuleRegexp = /[^{}]+{\s*}/;
            while (emptyRuleRegexp.test(text)) {
                text = text.replace(emptyRuleRegexp, "");
            }
        }
        const CSS = text
            .replace(/\s{2,}/g, " ")
            .replace(/\{/g, "{\n")
            .replace(/\}/g, "\n}\n")
            .replace(/\;(?![^\(|\"]*(\)|\"))/g, ";\n")
            .replace(/\,(?![^\(|\"]*(\)|\"))/g, ",\n")
            .replace(/\n\s*\n/g, "\n")
            .split("\n");
        let depth = 0;
        const formatted = [];
        for (let x = 0, len = css.length; x < len; x++) {
            const line = `${CSS[x]}\n`;
            if (line.includes("{")) {
                formatted.push(getIndent(depth++) + trimLeft(line));
            } else if (line.includes("}")) {
                formatted.push(getIndent(--depth) + trimLeft(line));
            } else {
                formatted.push(getIndent(depth) + trimLeft(line));
            }
        }
        return formatted.join("").trim();
    }
    function getParenthesesRange(input, searchStartIndex = 0) {
        const length = input.length;
        let depth = 0;
        let firstOpenIndex = -1;
        for (let i = searchStartIndex; i < length; i++) {
            if (depth === 0) {
                const openIndex = input.indexOf("(", i);
                if (openIndex < 0) {
                    break;
                }
                firstOpenIndex = openIndex;
                depth++;
                i = openIndex;
            } else {
                const closingIndex = input.indexOf(")", i);
                if (closingIndex < 0) {
                    break;
                }
                const openIndex = input.indexOf("(", i);
                if (openIndex < 0 || closingIndex < openIndex) {
                    depth--;
                    if (depth === 0) {
                        return {start: firstOpenIndex, end: closingIndex + 1};
                    }
                    i = closingIndex;
                } else {
                    depth++;
                    i = openIndex;
                }
            }
        }
        return null;
    }

    const hslaParseCache = new Map();
    const rgbaParseCache = new Map();
    function parseColorWithCache($color) {
        $color = $color.trim();
        if (rgbaParseCache.has($color)) {
            return rgbaParseCache.get($color);
        }
        if ($color.includes("calc(")) {
            $color = lowerCalcExpression($color);
        }
        const color = parse($color);
        color && rgbaParseCache.set($color, color);
        return color;
    }
    function parseToHSLWithCache(color) {
        if (hslaParseCache.has(color)) {
            return hslaParseCache.get(color);
        }
        const rgb = parseColorWithCache(color);
        if (!rgb) {
            return null;
        }
        const hsl = rgbToHSL(rgb);
        hslaParseCache.set(color, hsl);
        return hsl;
    }
    function clearColorCache() {
        hslaParseCache.clear();
        rgbaParseCache.clear();
    }
    function hslToRGB({h, s, l, a = 1}) {
        if (s === 0) {
            const [r, b, g] = [l, l, l].map((x) => Math.round(x * 255));
            return {r, g, b, a};
        }
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        const m = l - c / 2;
        const [r, g, b] = (
            h < 60
                ? [c, x, 0]
                : h < 120
                  ? [x, c, 0]
                  : h < 180
                    ? [0, c, x]
                    : h < 240
                      ? [0, x, c]
                      : h < 300
                        ? [x, 0, c]
                        : [c, 0, x]
        ).map((n) => Math.round((n + m) * 255));
        return {r, g, b, a};
    }
    function rgbToHSL({r: r255, g: g255, b: b255, a = 1}) {
        const r = r255 / 255;
        const g = g255 / 255;
        const b = b255 / 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const c = max - min;
        const l = (max + min) / 2;
        if (c === 0) {
            return {h: 0, s: 0, l, a};
        }
        let h =
            (max === r
                ? ((g - b) / c) % 6
                : max === g
                  ? (b - r) / c + 2
                  : (r - g) / c + 4) * 60;
        if (h < 0) {
            h += 360;
        }
        const s = c / (1 - Math.abs(2 * l - 1));
        return {h, s, l, a};
    }
    function toFixed(n, digits = 0) {
        const fixed = n.toFixed(digits);
        if (digits === 0) {
            return fixed;
        }
        const dot = fixed.indexOf(".");
        if (dot >= 0) {
            const zerosMatch = fixed.match(/0+$/);
            if (zerosMatch) {
                if (zerosMatch.index === dot + 1) {
                    return fixed.substring(0, dot);
                }
                return fixed.substring(0, zerosMatch.index);
            }
        }
        return fixed;
    }
    function rgbToString(rgb) {
        const {r, g, b, a} = rgb;
        if (a != null && a < 1) {
            return `rgba(${toFixed(r)}, ${toFixed(g)}, ${toFixed(b)}, ${toFixed(
                a,
2
            )})`;
        }
        return `rgb(${toFixed(r)}, ${toFixed(g)}, ${toFixed(b)})`;
    }
    function rgbToHexString({r, g, b, a}) {
        return `#${(a != null && a < 1
            ? [r, g, b, Math.round(a * 255)]
            : [r, g, b]
        )
            .map((x) => {
                return `${x < 16 ? "0" : ""}${x.toString(16)}`;
            })
            .join("")}`;
    }
    function hslToString(hsl) {
        const {h, s, l, a} = hsl;
        if (a != null && a < 1) {
            return `hsla(${toFixed(h)}, ${toFixed(s * 100)}%, ${toFixed(
                l * 100
            )}%, ${toFixed(a, 2)})`;
        }
        return `hsl(${toFixed(h)}, ${toFixed(s * 100)}%, ${toFixed(l * 100)}%)`;
    }
    const rgbMatch = /^rgba?\([^\(\)]+\)$/;
    const hslMatch = /^hsla?\([^\(\)]+\)$/;
    const hexMatch = /^#[0-9a-f]+$/i;
    function parse($color) {
        const c = $color.trim().toLowerCase();
        if (c.match(rgbMatch)) {
            return parseRGB(c);
        }
        if (c.match(hslMatch)) {
            return parseHSL(c);
        }
        if (c.match(hexMatch)) {
            return parseHex(c);
        }
        if (knownColors.has(c)) {
            return getColorByName(c);
        }
        if (systemColors.has(c)) {
            return getSystemColor(c);
        }
        if ($color === "transparent") {
            return {r: 0, g: 0, b: 0, a: 0};
        }
        return null;
    }
    function getNumbers($color) {
        const numbers = [];
        let prevPos = 0;
        let isMining = false;
        const startIndex = $color.indexOf("(");
        $color = $color.substring(startIndex + 1, $color.length - 1);
        for (let i = 0; i < $color.length; i++) {
            const c = $color[i];
            if ((c >= "0" && c <= "9") || c === "." || c === "+" || c === "-") {
                isMining = true;
            } else if (isMining && (c === " " || c === "," || c === "/")) {
                numbers.push($color.substring(prevPos, i));
                isMining = false;
                prevPos = i + 1;
            } else if (!isMining) {
                prevPos = i + 1;
            }
        }
        if (isMining) {
            numbers.push($color.substring(prevPos, $color.length));
        }
        return numbers;
    }
    function getNumbersFromString(str, range, units) {
        const raw = getNumbers(str);
        const unitsList = Object.entries(units);
        const numbers = raw
            .map((r) => r.trim())
            .map((r, i) => {
                let n;
                const unit = unitsList.find(([u]) => r.endsWith(u));
                if (unit) {
                    n =
                        (parseFloat(r.substring(0, r.length - unit[0].length)) /
                            unit[1]) *
                        range[i];
                } else {
                    n = parseFloat(r);
                }
                if (range[i] > 1) {
                    return Math.round(n);
                }
                return n;
            });
        return numbers;
    }
    const rgbRange = [255, 255, 255, 1];
    const rgbUnits = {"%": 100};
    function parseRGB($rgb) {
        const [r, g, b, a = 1] = getNumbersFromString($rgb, rgbRange, rgbUnits);
        return {r, g, b, a};
    }
    const hslRange = [360, 1, 1, 1];
    const hslUnits = {"%": 100, "deg": 360, "rad": 2 * Math.PI, "turn": 1};
    function parseHSL($hsl) {
        const [h, s, l, a = 1] = getNumbersFromString($hsl, hslRange, hslUnits);
        return hslToRGB({h, s, l, a});
    }
    function parseHex($hex) {
        const h = $hex.substring(1);
        switch (h.length) {
            case 3:
            case 4: {
                const [r, g, b] = [0, 1, 2].map((i) =>
                    parseInt(`${h[i]}${h[i]}`, 16)
                );
                const a =
                    h.length === 3 ? 1 : parseInt(`${h[3]}${h[3]}`, 16) / 255;
                return {r, g, b, a};
            }
            case 6:
            case 8: {
                const [r, g, b] = [0, 2, 4].map((i) =>
                    parseInt(h.substring(i, i + 2), 16)
                );
                const a =
                    h.length === 6 ? 1 : parseInt(h.substring(6, 8), 16) / 255;
                return {r, g, b, a};
            }
        }
        return null;
    }
    function getColorByName($color) {
        const n = knownColors.get($color);
        return {
            r: (n >> 16) & 255,
            g: (n >> 8) & 255,
            b: (n >> 0) & 255,
            a: 1
        };
    }
    function getSystemColor($color) {
        const n = systemColors.get($color);
        return {
            r: (n >> 16) & 255,
            g: (n >> 8) & 255,
            b: (n >> 0) & 255,
            a: 1
        };
    }
    function lowerCalcExpression(color) {
        let searchIndex = 0;
        const replaceBetweenIndices = (start, end, replacement) => {
            color =
                color.substring(0, start) + replacement + color.substring(end);
        };
        while ((searchIndex = color.indexOf("calc(")) !== -1) {
            const range = getParenthesesRange(color, searchIndex);
            if (!range) {
                break;
            }
            let slice = color.slice(range.start + 1, range.end - 1);
            const includesPercentage = slice.includes("%");
            slice = slice.split("%").join("");
            const output = Math.round(evalMath(slice));
            replaceBetweenIndices(
                range.start - 4,
                range.end,
                output + (includesPercentage ? "%" : "")
            );
        }
        return color;
    }
    const knownColors = new Map(
        Object.entries({
            aliceblue: 0xf0f8ff,
            antiquewhite: 0xfaebd7,
            aqua: 0x00ffff,
            aquamarine: 0x7fffd4,
            azure: 0xf0ffff,
            beige: 0xf5f5dc,
            bisque: 0xffe4c4,
            black: 0x000000,
            blanchedalmond: 0xffebcd,
            blue: 0x0000ff,
            blueviolet: 0x8a2be2,
            brown: 0xa52a2a,
            burlywood: 0xdeb887,
            cadetblue: 0x5f9ea0,
            chartreuse: 0x7fff00,
            chocolate: 0xd2691e,
            coral: 0xff7f50,
            cornflowerblue: 0x6495ed,
            cornsilk: 0xfff8dc,
            crimson: 0xdc143c,
            cyan: 0x00ffff,
            darkblue: 0x00008b,
            darkcyan: 0x008b8b,
            darkgoldenrod: 0xb8860b,
            darkgray: 0xa9a9a9,
            darkgrey: 0xa9a9a9,
            darkgreen: 0x006400,
            darkkhaki: 0xbdb76b,
            darkmagenta: 0x8b008b,
            darkolivegreen: 0x556b2f,
            darkorange: 0xff8c00,
            darkorchid: 0x9932cc,
            darkred: 0x8b0000,
            darksalmon: 0xe9967a,
            darkseagreen: 0x8fbc8f,
            darkslateblue: 0x483d8b,
            darkslategray: 0x2f4f4f,
            darkslategrey: 0x2f4f4f,
            darkturquoise: 0x00ced1,
            darkviolet: 0x9400d3,
            deeppink: 0xff1493,
            deepskyblue: 0x00bfff,
            dimgray: 0x696969,
            dimgrey: 0x696969,
            dodgerblue: 0x1e90ff,
            firebrick: 0xb22222,
            floralwhite: 0xfffaf0,
            forestgreen: 0x228b22,
            fuchsia: 0xff00ff,
            gainsboro: 0xdcdcdc,
            ghostwhite: 0xf8f8ff,
            gold: 0xffd700,
            goldenrod: 0xdaa520,
            gray: 0x808080,
            grey: 0x808080,
            green: 0x008000,
            greenyellow: 0xadff2f,
            honeydew: 0xf0fff0,
            hotpink: 0xff69b4,
            indianred: 0xcd5c5c,
            indigo: 0x4b0082,
            ivory: 0xfffff0,
            khaki: 0xf0e68c,
            lavender: 0xe6e6fa,
            lavenderblush: 0xfff0f5,
            lawngreen: 0x7cfc00,
            lemonchiffon: 0xfffacd,
            lightblue: 0xadd8e6,
            lightcoral: 0xf08080,
            lightcyan: 0xe0ffff,
            lightgoldenrodyellow: 0xfafad2,
            lightgray: 0xd3d3d3,
            lightgrey: 0xd3d3d3,
            lightgreen: 0x90ee90,
            lightpink: 0xffb6c1,
            lightsalmon: 0xffa07a,
            lightseagreen: 0x20b2aa,
            lightskyblue: 0x87cefa,
            lightslategray: 0x778899,
            lightslategrey: 0x778899,
            lightsteelblue: 0xb0c4de,
            lightyellow: 0xffffe0,
            lime: 0x00ff00,
            limegreen: 0x32cd32,
            linen: 0xfaf0e6,
            magenta: 0xff00ff,
            maroon: 0x800000,
            mediumaquamarine: 0x66cdaa,
            mediumblue: 0x0000cd,
            mediumorchid: 0xba55d3,
            mediumpurple: 0x9370db,
            mediumseagreen: 0x3cb371,
            mediumslateblue: 0x7b68ee,
            mediumspringgreen: 0x00fa9a,
            mediumturquoise: 0x48d1cc,
            mediumvioletred: 0xc71585,
            midnightblue: 0x191970,
            mintcream: 0xf5fffa,
            mistyrose: 0xffe4e1,
            moccasin: 0xffe4b5,
            navajowhite: 0xffdead,
            navy: 0x000080,
            oldlace: 0xfdf5e6,
            olive: 0x808000,
            olivedrab: 0x6b8e23,
            orange: 0xffa500,
            orangered: 0xff4500,
            orchid: 0xda70d6,
            palegoldenrod: 0xeee8aa,
            palegreen: 0x98fb98,
            paleturquoise: 0xafeeee,
            palevioletred: 0xdb7093,
            papayawhip: 0xffefd5,
            peachpuff: 0xffdab9,
            peru: 0xcd853f,
            pink: 0xffc0cb,
            plum: 0xdda0dd,
            powderblue: 0xb0e0e6,
            purple: 0x800080,
            rebeccapurple: 0x663399,
            red: 0xff0000,
            rosybrown: 0xbc8f8f,
            royalblue: 0x4169e1,
            saddlebrown: 0x8b4513,
            salmon: 0xfa8072,
            sandybrown: 0xf4a460,
            seagreen: 0x2e8b57,
            seashell: 0xfff5ee,
            sienna: 0xa0522d,
            silver: 0xc0c0c0,
            skyblue: 0x87ceeb,
            slateblue: 0x6a5acd,
            slategray: 0x708090,
            slategrey: 0x708090,
            snow: 0xfffafa,
            springgreen: 0x00ff7f,
            steelblue: 0x4682b4,
            tan: 0xd2b48c,
            teal: 0x008080,
            thistle: 0xd8bfd8,
            tomato: 0xff6347,
            turquoise: 0x40e0d0,
            violet: 0xee82ee,
            wheat: 0xf5deb3,
            white: 0xffffff,
            whitesmoke: 0xf5f5f5,
            yellow: 0xffff00,
            yellowgreen: 0x9acd32
        })
    );
    const systemColors = new Map(
        Object.entries({
            "ActiveBorder": 0x3b99fc,
            "ActiveCaption": 0x000000,
            "AppWorkspace": 0xaaaaaa,
            "Background": 0x6363ce,
            "ButtonFace": 0xffffff,
            "ButtonHighlight": 0xe9e9e9,
            "ButtonShadow": 0x9fa09f,
            "ButtonText": 0x000000,
            "CaptionText": 0x000000,
            "GrayText": 0x7f7f7f,
            "Highlight": 0xb2d7ff,
            "HighlightText": 0x000000,
            "InactiveBorder": 0xffffff,
            "InactiveCaption": 0xffffff,
            "InactiveCaptionText": 0x000000,
            "InfoBackground": 0xfbfcc5,
            "InfoText": 0x000000,
            "Menu": 0xf6f6f6,
            "MenuText": 0xffffff,
            "Scrollbar": 0xaaaaaa,
            "ThreeDDarkShadow": 0x000000,
            "ThreeDFace": 0xc0c0c0,
            "ThreeDHighlight": 0xffffff,
            "ThreeDLightShadow": 0xffffff,
            "ThreeDShadow": 0x000000,
            "Window": 0xececec,
            "WindowFrame": 0xaaaaaa,
            "WindowText": 0x000000,
            "-webkit-focus-ring-color": 0xe59700
        }).map(([key, value]) => [key.toLowerCase(), value])
    );
    function getSRGBLightness(r, g, b) {
        return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
    }

    const isNavigatorDefined = typeof navigator !== "undefined";
    const userAgent = isNavigatorDefined
        ? navigator.userAgentData &&
          Array.isArray(navigator.userAgentData.brands)
            ? navigator.userAgentData.brands
                  .map(
                      (brand) => `${brand.brand.toLowerCase()} ${brand.version}`
                  )
                  .join(" ")
            : navigator.userAgent.toLowerCase()
        : "some useragent";
    const platform = isNavigatorDefined
        ? navigator.userAgentData &&
          typeof navigator.userAgentData.platform === "string"
            ? navigator.userAgentData.platform.toLowerCase()
            : navigator.platform.toLowerCase()
        : "some platform";
    userAgent.includes("vivaldi");
    userAgent.includes("yabrowser");
    userAgent.includes("opr") || userAgent.includes("opera");
    userAgent.includes("edg");
    platform.startsWith("win");
    platform.startsWith("mac");
    isNavigatorDefined && navigator.userAgentData
        ? navigator.userAgentData.mobile
        : userAgent.includes("mobile");
    const isShadowDomSupported = typeof ShadowRoot === "function";
    const isMatchMediaChangeEventListenerSupported =
        typeof MediaQueryList === "function" &&
        typeof MediaQueryList.prototype.addEventListener === "function";
    (isNavigatorDefined &&
        navigator.userAgentData &&
        ["Linux", "Android"].includes(navigator.userAgentData.platform)) ||
        platform.startsWith("linux");
    (() => {
        const m = userAgent.match(/chrom(?:e|ium)(?:\/| )([^ ]+)/);
        if (m && m[1]) {
            return m[1];
        }
        return "";
    })();
    (() => {
        const m = userAgent.match(/(?:firefox|librewolf)(?:\/| )([^ ]+)/);
        if (m && m[1]) {
            return m[1];
        }
        return "";
    })();
    const isDefinedSelectorSupported = (() => {
        try {
            document.querySelector(":defined");
            return true;
        } catch (err) {
            return false;
        }
    })();
    const isCSSColorSchemePropSupported = (() => {
        try {
            if (typeof document === "undefined") {
                return false;
            }
            const el = document.createElement("div");
            if (!el || typeof el.style !== "object") {
                return false;
            }
            if (typeof el.style.colorScheme === "string") {
                return true;
            }
            el.setAttribute("style", "color-scheme: dark");
            return el.style.colorScheme === "dark";
        } catch (e) {
            return false;
        }
    })();

    let query = null;
    const onChange = ({matches}) =>
        listeners.forEach((listener) => listener(matches));
    const listeners = new Set();
    function runColorSchemeChangeDetector(callback) {
        listeners.add(callback);
        if (query) {
            return;
        }
        query = matchMedia("(prefers-color-scheme: dark)");
        if (isMatchMediaChangeEventListenerSupported) {
            query.addEventListener("change", onChange);
        } else {
            query.addListener(onChange);
        }
    }
    function stopColorSchemeChangeDetector() {
        if (!query || !onChange) {
            return;
        }
        if (isMatchMediaChangeEventListenerSupported) {
            query.removeEventListener("change", onChange);
        } else {
            query.removeListener(onChange);
        }
        listeners.clear();
        query = null;
    }
    const isSystemDarkModeEnabled = () =>
        (query || matchMedia("(prefers-color-scheme: dark)")).matches;

    const COLOR_SCHEME_META_SELECTOR = 'meta[name="color-scheme"]';
    function hasBuiltInDarkTheme() {
        const rootStyle = getComputedStyle(document.documentElement);
        if (rootStyle.filter.includes("invert(1)")) {
            return true;
        }
        const CELL_SIZE = 256;
        const MAX_ROW_COUNT = 4;
        const winWidth = innerWidth;
        const winHeight = innerHeight;
        const stepX = Math.floor(
            winWidth / Math.min(MAX_ROW_COUNT, Math.ceil(winWidth / CELL_SIZE))
        );
        const stepY = Math.floor(
            winHeight /
                Math.min(MAX_ROW_COUNT, Math.ceil(winHeight / CELL_SIZE))
        );
        const processedElements = new Set();
        for (let y = Math.floor(stepY / 2); y < winHeight; y += stepY) {
            for (let x = Math.floor(stepX / 2); x < winWidth; x += stepX) {
                const element = document.elementFromPoint(x, y);
                if (!element || processedElements.has(element)) {
                    continue;
                }
                processedElements.add(element);
                const style =
                    element === document.documentElement
                        ? rootStyle
                        : getComputedStyle(element);
                const bgColor = parseColorWithCache(style.backgroundColor);
                if (bgColor.a === 1) {
                    const bgLightness = getSRGBLightness(
                        bgColor.r,
                        bgColor.g,
                        bgColor.b
                    );
                    if (bgLightness > 0.5) {
                        return false;
                    }
                } else {
                    const textColor = parseColorWithCache(style.color);
                    const textLightness = getSRGBLightness(
                        textColor.r,
                        textColor.g,
                        textColor.b
                    );
                    if (textLightness < 0.5) {
                        return false;
                    }
                }
            }
        }
        const rootColor = parseColorWithCache(rootStyle.backgroundColor);
        const bodyColor = document.body
            ? parseColorWithCache(
                  getComputedStyle(document.body).backgroundColor
              )
            : {r: 0, g: 0, b: 0, a: 0};
        const rootLightness =
            1 -
            rootColor.a +
            rootColor.a *
                getSRGBLightness(rootColor.r, rootColor.g, rootColor.b);
        const finalLightness =
            (1 - bodyColor.a) * rootLightness +
            bodyColor.a *
                getSRGBLightness(bodyColor.r, bodyColor.g, bodyColor.b);
        return finalLightness < 0.5;
    }
    function runCheck(callback) {
        const colorSchemeMeta = document.querySelector(
            COLOR_SCHEME_META_SELECTOR
        );
        if (colorSchemeMeta) {
            const isMetaDark =
                colorSchemeMeta.content === "dark" ||
                (colorSchemeMeta.content.includes("dark") &&
                    isSystemDarkModeEnabled());
            callback(isMetaDark);
            return;
        }
        const drStyles = document.querySelectorAll(".darkreader");
        drStyles.forEach((style) => (style.disabled = true));
        const darkThemeDetected = hasBuiltInDarkTheme();
        drStyles.forEach((style) => (style.disabled = false));
        callback(darkThemeDetected);
    }
    function hasSomeStyle() {
        if (document.querySelector(COLOR_SCHEME_META_SELECTOR) != null) {
            return true;
        }
        if (
            document.documentElement.style.backgroundColor ||
            (document.body && document.body.style.backgroundColor)
        ) {
            return true;
        }
        for (const style of document.styleSheets) {
            if (
                style &&
                style.ownerNode &&
                !(
                    style.ownerNode.classList &&
                    style.ownerNode.classList.contains("darkreader")
                )
            ) {
                return true;
            }
        }
        return false;
    }
    let observer$1;
    let readyStateListener;
    function runDarkThemeDetector(callback, hints) {
        stopDarkThemeDetector();
        if (hints && hints.length > 0) {
            const hint = hints[0];
            if (hint.noDarkTheme) {
                callback(false);
                return;
            }
            if (hint.systemTheme && isSystemDarkModeEnabled()) {
                callback(true);
                return;
            }
            detectUsingHint(hint, () => callback(true));
            return;
        }
        if (document.body && hasSomeStyle()) {
            runCheck(callback);
            return;
        }
        observer$1 = new MutationObserver(() => {
            if (document.body && hasSomeStyle()) {
                stopDarkThemeDetector();
                runCheck(callback);
            }
        });
        observer$1.observe(document.documentElement, {childList: true});
        if (document.readyState !== "complete") {
            readyStateListener = () => {
                if (document.readyState === "complete") {
                    stopDarkThemeDetector();
                    runCheck(callback);
                }
            };
            document.addEventListener("readystatechange", readyStateListener);
        }
    }
    function stopDarkThemeDetector() {
        if (observer$1) {
            observer$1.disconnect();
            observer$1 = null;
        }
        if (readyStateListener) {
            document.removeEventListener(
                "readystatechange",
                readyStateListener
            );
            readyStateListener = null;
        }
        stopDetectingUsingHint();
    }
    let hintTargetObserver;
    let hintMatchObserver;
    function detectUsingHint(hint, success) {
        stopDetectingUsingHint();
        const matchSelector = (hint.match || []).join(", ");
        function checkMatch(target) {
            var _a;
            if (
                (_a = target.matches) === null || _a === void 0
                    ? void 0
                    : _a.call(target, matchSelector)
            ) {
                stopDetectingUsingHint();
                success();
                return true;
            }
            return false;
        }
        function setupMatchObserver(target) {
            hintMatchObserver === null || hintMatchObserver === void 0
                ? void 0
                : hintMatchObserver.disconnect();
            if (checkMatch(target)) {
                return;
            }
            hintMatchObserver = new MutationObserver(() => checkMatch(target));
            hintMatchObserver.observe(target, {attributes: true});
        }
        const target = document.querySelector(hint.target);
        if (target) {
            setupMatchObserver(target);
        } else {
            hintTargetObserver = new MutationObserver((mutations) => {
                const handledTargets = new Set();
                for (const mutation of mutations) {
                    if (handledTargets.has(mutation.target)) {
                        continue;
                    }
                    handledTargets.add(mutation.target);
                    if (mutation.target instanceof Element) {
                        const target = mutation.target.querySelector(
                            hint.target
                        );
                        if (target) {
                            hintTargetObserver.disconnect();
                            setupMatchObserver(target);
                            break;
                        }
                    }
                }
            });
            hintTargetObserver.observe(document.documentElement, {
                childList: true,
                subtree: true
            });
        }
    }
    function stopDetectingUsingHint() {
        hintTargetObserver === null || hintTargetObserver === void 0
            ? void 0
            : hintTargetObserver.disconnect();
        hintMatchObserver === null || hintMatchObserver === void 0
            ? void 0
            : hintMatchObserver.disconnect();
    }

    function cachedFactory(factory, size) {
        const cache = new Map();
        return (key) => {
            if (cache.has(key)) {
                return cache.get(key);
            }
            const value = factory(key);
            cache.set(key, value);
            if (cache.size > size) {
                const first = cache.keys().next().value;
                cache.delete(first);
            }
            return value;
        };
    }

    const simpleIPV6Regex = /\[[0-9:a-zA-Z]+?\]/;
    function isIPV6(url) {
        const openingBracketIndex = simpleIPV6Regex.exec(url);
        if (!openingBracketIndex) {
            return false;
        }
        const queryIndex = url.indexOf("?");
        if (queryIndex >= 0 && openingBracketIndex.index > queryIndex) {
            return false;
        }
        return true;
    }
    const ipV6HostRegex = /\[.*?\](\:\d+)?/;
    function compareIPV6(firstURL, secondURL) {
        const firstHost = firstURL.match(ipV6HostRegex)[0];
        const secondHost = secondURL.match(ipV6HostRegex)[0];
        return firstHost === secondHost;
    }

    let anchor;
    const parsedURLCache = new Map();
    function fixBaseURL($url) {
        if (!anchor) {
            anchor = document.createElement("a");
        }
        anchor.href = $url;
        return anchor.href;
    }
    function parseURL($url, $base = null) {
        const key = `${$url}${$base ? `;${$base}` : ""}`;
        if (parsedURLCache.has(key)) {
            return parsedURLCache.get(key);
        }
        if ($base) {
            const parsedURL = new URL($url, fixBaseURL($base));
            parsedURLCache.set(key, parsedURL);
            return parsedURL;
        }
        const parsedURL = new URL(fixBaseURL($url));
        parsedURLCache.set($url, parsedURL);
        return parsedURL;
    }
    function getAbsoluteURL($base, $relative) {
        if ($relative.match(/^data\\?\:/)) {
            return $relative;
        }
        if (/^\/\//.test($relative)) {
            return `${location.protocol}${$relative}`;
        }
        const b = parseURL($base);
        const a = parseURL($relative, b.href);
        return a.href;
    }
    function isRelativeHrefOnAbsolutePath(href) {
        if (href.startsWith("data:")) {
            return true;
        }
        const url = parseURL(href);
        if (url.protocol !== location.protocol) {
            return false;
        }
        if (url.hostname !== location.hostname) {
            return false;
        }
        if (url.port !== location.port) {
            return false;
        }
        return url.pathname === location.pathname;
    }
    function isURLInList(url, list) {
        for (let i = 0; i < list.length; i++) {
            if (isURLMatched(url, list[i])) {
                return true;
            }
        }
        return false;
    }
    function isURLMatched(url, urlTemplate) {
        const isFirstIPV6 = isIPV6(url);
        const isSecondIPV6 = isIPV6(urlTemplate);
        if (isRegExp(urlTemplate)) {
            const regexp = createRegExp(urlTemplate);
            return regexp ? regexp.test(url) : false;
        } else if (isFirstIPV6 && isSecondIPV6) {
            return compareIPV6(url, urlTemplate);
        } else if (!isFirstIPV6 && !isSecondIPV6) {
            return matchURLPattern(url, urlTemplate);
        }
        return false;
    }
    const URL_CACHE_SIZE = 32;
    const prepareURL = cachedFactory((url) => {
        let parsed;
        try {
            parsed = new URL(url);
        } catch (err) {
            return null;
        }
        const {hostname, pathname, protocol, port} = parsed;
        const hostParts = hostname.split(".").reverse();
        const pathParts = pathname.split("/").slice(1);
        if (!pathParts[pathParts.length - 1]) {
            pathParts.splice(pathParts.length - 1, 1);
        }
        return {
            hostParts,
            pathParts,
            port,
            protocol
        };
    }, URL_CACHE_SIZE);
    const URL_MATCH_CACHE_SIZE = 32 * 1024;
    const preparePattern = cachedFactory((pattern) => {
        if (!pattern) {
            return null;
        }
        const exactStart = pattern.startsWith("^");
        const exactEnd = pattern.endsWith("$");
        if (exactStart) {
            pattern = pattern.substring(1);
        }
        if (exactEnd) {
            pattern = pattern.substring(0, pattern.length - 1);
        }
        let protocol = "";
        const protocolIndex = pattern.indexOf("://");
        if (protocolIndex > 0) {
            protocol = pattern.substring(0, protocolIndex + 1);
            pattern = pattern.substring(protocolIndex + 3);
        }
        const slashIndex = pattern.indexOf("/");
        const host =
            slashIndex < 0 ? pattern : pattern.substring(0, slashIndex);
        let hostName = host;
        let port = "*";
        const portIndex = host.indexOf(":");
        if (portIndex >= 0) {
            hostName = host.substring(0, portIndex);
            port = host.substring(portIndex + 1);
        }
        const hostParts = hostName.split(".").reverse();
        const path = slashIndex < 0 ? "" : pattern.substring(slashIndex + 1);
        const pathParts = path.split("/");
        if (!pathParts[pathParts.length - 1]) {
            pathParts.splice(pathParts.length - 1, 1);
        }
        return {
            hostParts,
            pathParts,
            port,
            exactStart,
            exactEnd,
            protocol
        };
    }, URL_MATCH_CACHE_SIZE);
    function matchURLPattern(url, pattern) {
        const u = prepareURL(url);
        const p = preparePattern(pattern);
        if (
            !(u && p) ||
            p.hostParts.length > u.hostParts.length ||
            (p.exactStart && p.hostParts.length !== u.hostParts.length) ||
            (p.exactEnd && p.pathParts.length !== u.pathParts.length) ||
            (p.port !== "*" && p.port !== u.port) ||
            (p.protocol && p.protocol !== u.protocol)
        ) {
            return false;
        }
        for (let i = 0; i < p.hostParts.length; i++) {
            const pHostPart = p.hostParts[i];
            const uHostPart = u.hostParts[i];
            if (pHostPart !== "*" && pHostPart !== uHostPart) {
                return false;
            }
        }
        if (
            p.hostParts.length >= 2 &&
            p.hostParts.at(-1) !== "*" &&
            (p.hostParts.length < u.hostParts.length - 1 ||
                (p.hostParts.length === u.hostParts.length - 1 &&
                    u.hostParts.at(-1) !== "www"))
        ) {
            return false;
        }
        if (p.pathParts.length === 0) {
            return true;
        }
        if (p.pathParts.length > u.pathParts.length) {
            return false;
        }
        for (let i = 0; i < p.pathParts.length; i++) {
            const pPathPart = p.pathParts[i];
            const uPathPart = u.pathParts[i];
            if (pPathPart !== "*" && pPathPart !== uPathPart) {
                return false;
            }
        }
        return true;
    }
    function isRegExp(pattern) {
        return (
            pattern.startsWith("/") &&
            pattern.endsWith("/") &&
            pattern.length > 2
        );
    }
    const REGEXP_CACHE_SIZE = 1024;
    const createRegExp = cachedFactory((pattern) => {
        if (pattern.startsWith("/")) {
            pattern = pattern.substring(1);
        }
        if (pattern.endsWith("/")) {
            pattern = pattern.substring(0, pattern.length - 1);
        }
        try {
            return new RegExp(pattern);
        } catch (err) {
            return null;
        }
    }, REGEXP_CACHE_SIZE);

    function iterateCSSRules(rules, iterate, onMediaRuleError) {
        forEach(rules, (rule) => {
            if (rule.selectorText) {
                iterate(rule);
            } else if (rule.href) {
                try {
                    iterateCSSRules(
                        rule.styleSheet.cssRules,
                        iterate,
                        onMediaRuleError
                    );
                } catch (err) {
                    onMediaRuleError && onMediaRuleError();
                }
            } else if (rule.media) {
                const media = Array.from(rule.media);
                const isScreenOrAllOrQuery = media.some(
                    (m) =>
                        m.startsWith("screen") ||
                        m.startsWith("all") ||
                        m.startsWith("(")
                );
                const isPrintOrSpeech = media.some(
                    (m) => m.startsWith("print") || m.startsWith("speech")
                );
                if (isScreenOrAllOrQuery || !isPrintOrSpeech) {
                    iterateCSSRules(rule.cssRules, iterate, onMediaRuleError);
                }
            } else if (rule.conditionText) {
                if (CSS.supports(rule.conditionText)) {
                    iterateCSSRules(rule.cssRules, iterate, onMediaRuleError);
                }
            } else;
        });
    }
    const shorthandVarDependantProperties = [
        "background",
        "border",
        "border-color",
        "border-bottom",
        "border-left",
        "border-right",
        "border-top",
        "outline",
        "outline-color"
    ];
    function iterateCSSDeclarations(style, iterate) {
        forEach(style, (property) => {
            const value = style.getPropertyValue(property).trim();
            if (!value) {
                return;
            }
            iterate(property, value);
        });
        const cssText = style.cssText;
        if (cssText.includes("var(")) {
            {
                shorthandVarDependantProperties.forEach((prop) => {
                    const val = style.getPropertyValue(prop);
                    if (val && val.includes("var(")) {
                        iterate(prop, val);
                    }
                });
            }
        }
    }
    const cssURLRegex = /url\((('.*?')|(".*?")|([^\)]*?))\)/g;
    const cssImportRegex =
        /@import\s*(url\()?(('.+?')|(".+?")|([^\)]*?))\)? ?(screen)?;?/gi;
    function getCSSURLValue(cssURL) {
        return cssURL
            .trim()
            .replace(/[\n\r\\]+/g, "")
            .replace(/^url\((.*)\)$/, "$1")
            .trim()
            .replace(/^"(.*)"$/, "$1")
            .replace(/^'(.*)'$/, "$1")
            .replace(/(?:\\(.))/g, "$1");
    }
    function getCSSBaseBath(url) {
        const cssURL = parseURL(url);
        return `${cssURL.origin}${cssURL.pathname
            .replace(/\?.*$/, "")
            .replace(/(\/)([^\/]+)$/i, "$1")}`;
    }
    function replaceCSSRelativeURLsWithAbsolute($css, cssBasePath) {
        return $css.replace(cssURLRegex, (match) => {
            const pathValue = getCSSURLValue(match);
            try {
                return `url('${getAbsoluteURL(cssBasePath, pathValue)}')`;
            } catch (err) {
                return match;
            }
        });
    }
    const cssCommentsRegex = /\/\*[\s\S]*?\*\//g;
    function removeCSSComments($css) {
        return $css.replace(cssCommentsRegex, "");
    }
    const fontFaceRegex = /@font-face\s*{[^}]*}/g;
    function replaceCSSFontFace($css) {
        return $css.replace(fontFaceRegex, "");
    }

    function scale(x, inLow, inHigh, outLow, outHigh) {
        return ((x - inLow) * (outHigh - outLow)) / (inHigh - inLow) + outLow;
    }
    function clamp(x, min, max) {
        return Math.min(max, Math.max(min, x));
    }
    function multiplyMatrices(m1, m2) {
        const result = [];
        for (let i = 0, len = m1.length; i < len; i++) {
            result[i] = [];
            for (let j = 0, len2 = m2[0].length; j < len2; j++) {
                let sum = 0;
                for (let k = 0, len3 = m1[0].length; k < len3; k++) {
                    sum += m1[i][k] * m2[k][j];
                }
                result[i][j] = sum;
            }
        }
        return result;
    }

    function createFilterMatrix(config) {
        let m = Matrix.identity();
        if (config.sepia !== 0) {
            m = multiplyMatrices(m, Matrix.sepia(config.sepia / 100));
        }
        if (config.grayscale !== 0) {
            m = multiplyMatrices(m, Matrix.grayscale(config.grayscale / 100));
        }
        if (config.contrast !== 100) {
            m = multiplyMatrices(m, Matrix.contrast(config.contrast / 100));
        }
        if (config.brightness !== 100) {
            m = multiplyMatrices(m, Matrix.brightness(config.brightness / 100));
        }
        if (config.mode === 1) {
            m = multiplyMatrices(m, Matrix.invertNHue());
        }
        return m;
    }
    function applyColorMatrix([r, g, b], matrix) {
        const rgb = [[r / 255], [g / 255], [b / 255], [1], [1]];
        const result = multiplyMatrices(matrix, rgb);
        return [0, 1, 2].map((i) =>
            clamp(Math.round(result[i][0] * 255), 0, 255)
        );
    }
    const Matrix = {
        identity() {
            return [
                [1, 0, 0, 0, 0],
                [0, 1, 0, 0, 0],
                [0, 0, 1, 0, 0],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        invertNHue() {
            return [
                [0.333, -0.667, -0.667, 0, 1],
                [-0.667, 0.333, -0.667, 0, 1],
                [-0.667, -0.667, 0.333, 0, 1],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        brightness(v) {
            return [
                [v, 0, 0, 0, 0],
                [0, v, 0, 0, 0],
                [0, 0, v, 0, 0],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        contrast(v) {
            const t = (1 - v) / 2;
            return [
                [v, 0, 0, 0, t],
                [0, v, 0, 0, t],
                [0, 0, v, 0, t],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        sepia(v) {
            return [
                [
                    0.393 + 0.607 * (1 - v),
                    0.769 - 0.769 * (1 - v),
                    0.189 - 0.189 * (1 - v),
                    0,
0
                ],
                [
                    0.349 - 0.349 * (1 - v),
                    0.686 + 0.314 * (1 - v),
                    0.168 - 0.168 * (1 - v),
                    0,
0
                ],
                [
                    0.272 - 0.272 * (1 - v),
                    0.534 - 0.534 * (1 - v),
                    0.131 + 0.869 * (1 - v),
                    0,
0
                ],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        },
        grayscale(v) {
            return [
                [
                    0.2126 + 0.7874 * (1 - v),
                    0.7152 - 0.7152 * (1 - v),
                    0.0722 - 0.0722 * (1 - v),
                    0,
0
                ],
                [
                    0.2126 - 0.2126 * (1 - v),
                    0.7152 + 0.2848 * (1 - v),
                    0.0722 - 0.0722 * (1 - v),
                    0,
0
                ],
                [
                    0.2126 - 0.2126 * (1 - v),
                    0.7152 - 0.7152 * (1 - v),
                    0.0722 + 0.9278 * (1 - v),
                    0,
0
                ],
                [0, 0, 0, 1, 0],
                [0, 0, 0, 0, 1]
            ];
        }
    };

    function getBgPole(theme) {
        const isDarkScheme = theme.mode === 1;
        const prop = isDarkScheme
            ? "darkSchemeBackgroundColor"
            : "lightSchemeBackgroundColor";
        return theme[prop];
    }
    function getFgPole(theme) {
        const isDarkScheme = theme.mode === 1;
        const prop = isDarkScheme
            ? "darkSchemeTextColor"
            : "lightSchemeTextColor";
        return theme[prop];
    }
    const colorModificationCache = new Map();
    function clearColorModificationCache() {
        colorModificationCache.clear();
    }
    const rgbCacheKeys = ["r", "g", "b", "a"];
    const themeCacheKeys$1 = [
        "mode",
        "brightness",
        "contrast",
        "grayscale",
        "sepia",
        "darkSchemeBackgroundColor",
        "darkSchemeTextColor",
        "lightSchemeBackgroundColor",
        "lightSchemeTextColor"
    ];
    function getCacheId(rgb, theme) {
        let resultId = "";
        rgbCacheKeys.forEach((key) => {
            resultId += `${rgb[key]};`;
        });
        themeCacheKeys$1.forEach((key) => {
            resultId += `${theme[key]};`;
        });
        return resultId;
    }
    function modifyColorWithCache(
        rgb,
        theme,
        modifyHSL,
        poleColor,
        anotherPoleColor
    ) {
        let fnCache;
        if (colorModificationCache.has(modifyHSL)) {
            fnCache = colorModificationCache.get(modifyHSL);
        } else {
            fnCache = new Map();
            colorModificationCache.set(modifyHSL, fnCache);
        }
        const id = getCacheId(rgb, theme);
        if (fnCache.has(id)) {
            return fnCache.get(id);
        }
        const hsl = rgbToHSL(rgb);
        const pole = poleColor == null ? null : parseToHSLWithCache(poleColor);
        const anotherPole =
            anotherPoleColor == null
                ? null
                : parseToHSLWithCache(anotherPoleColor);
        const modified = modifyHSL(hsl, pole, anotherPole);
        const {r, g, b, a} = hslToRGB(modified);
        const matrix = createFilterMatrix(theme);
        const [rf, gf, bf] = applyColorMatrix([r, g, b], matrix);
        const color =
            a === 1
                ? rgbToHexString({r: rf, g: gf, b: bf})
                : rgbToString({r: rf, g: gf, b: bf, a});
        fnCache.set(id, color);
        return color;
    }
    function noopHSL(hsl) {
        return hsl;
    }
    function modifyColor(rgb, theme) {
        return modifyColorWithCache(rgb, theme, noopHSL);
    }
    function modifyLightSchemeColor(rgb, theme) {
        const poleBg = getBgPole(theme);
        const poleFg = getFgPole(theme);
        return modifyColorWithCache(
            rgb,
            theme,
            modifyLightModeHSL,
            poleFg,
            poleBg
        );
    }
    function modifyLightModeHSL({h, s, l, a}, poleFg, poleBg) {
        const isDark = l < 0.5;
        let isNeutral;
        if (isDark) {
            isNeutral = l < 0.2 || s < 0.12;
        } else {
            const isBlue = h > 200 && h < 280;
            isNeutral = s < 0.24 || (l > 0.8 && isBlue);
        }
        let hx = h;
        let sx = l;
        if (isNeutral) {
            if (isDark) {
                hx = poleFg.h;
                sx = poleFg.s;
            } else {
                hx = poleBg.h;
                sx = poleBg.s;
            }
        }
        const lx = scale(l, 0, 1, poleFg.l, poleBg.l);
        return {h: hx, s: sx, l: lx, a};
    }
    const MAX_BG_LIGHTNESS = 0.4;
    function modifyBgHSL({h, s, l, a}, pole) {
        const isDark = l < 0.5;
        const isBlue = h > 200 && h < 280;
        const isNeutral = s < 0.12 || (l > 0.8 && isBlue);
        if (isDark) {
            const lx = scale(l, 0, 0.5, 0, MAX_BG_LIGHTNESS);
            if (isNeutral) {
                const hx = pole.h;
                const sx = pole.s;
                return {h: hx, s: sx, l: lx, a};
            }
            return {h, s, l: lx, a};
        }
        let lx = scale(l, 0.5, 1, MAX_BG_LIGHTNESS, pole.l);
        if (isNeutral) {
            const hx = pole.h;
            const sx = pole.s;
            return {h: hx, s: sx, l: lx, a};
        }
        let hx = h;
        const isYellow = h > 60 && h < 180;
        if (isYellow) {
            const isCloserToGreen = h > 120;
            if (isCloserToGreen) {
                hx = scale(h, 120, 180, 135, 180);
            } else {
                hx = scale(h, 60, 120, 60, 105);
            }
        }
        if (hx > 40 && hx < 80) {
            lx *= 0.75;
        }
        return {h: hx, s, l: lx, a};
    }
    function modifyBackgroundColor(rgb, theme) {
        if (theme.mode === 0) {
            return modifyLightSchemeColor(rgb, theme);
        }
        const pole = getBgPole(theme);
        return modifyColorWithCache(
            rgb,
            {...theme, mode: 0},
            modifyBgHSL,
            pole
        );
    }
    const MIN_FG_LIGHTNESS = 0.55;
    function modifyBlueFgHue(hue) {
        return scale(hue, 205, 245, 205, 220);
    }
    function modifyFgHSL({h, s, l, a}, pole) {
        const isLight = l > 0.5;
        const isNeutral = l < 0.2 || s < 0.24;
        const isBlue = !isNeutral && h > 205 && h < 245;
        if (isLight) {
            const lx = scale(l, 0.5, 1, MIN_FG_LIGHTNESS, pole.l);
            if (isNeutral) {
                const hx = pole.h;
                const sx = pole.s;
                return {h: hx, s: sx, l: lx, a};
            }
            let hx = h;
            if (isBlue) {
                hx = modifyBlueFgHue(h);
            }
            return {h: hx, s, l: lx, a};
        }
        if (isNeutral) {
            const hx = pole.h;
            const sx = pole.s;
            const lx = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);
            return {h: hx, s: sx, l: lx, a};
        }
        let hx = h;
        let lx;
        if (isBlue) {
            hx = modifyBlueFgHue(h);
            lx = scale(l, 0, 0.5, pole.l, Math.min(1, MIN_FG_LIGHTNESS + 0.05));
        } else {
            lx = scale(l, 0, 0.5, pole.l, MIN_FG_LIGHTNESS);
        }
        return {h: hx, s, l: lx, a};
    }
    function modifyForegroundColor(rgb, theme) {
        if (theme.mode === 0) {
            return modifyLightSchemeColor(rgb, theme);
        }
        const pole = getFgPole(theme);
        return modifyColorWithCache(
            rgb,
            {...theme, mode: 0},
            modifyFgHSL,
            pole
        );
    }
    function modifyBorderHSL({h, s, l, a}, poleFg, poleBg) {
        const isDark = l < 0.5;
        const isNeutral = l < 0.2 || s < 0.24;
        let hx = h;
        let sx = s;
        if (isNeutral) {
            if (isDark) {
                hx = poleFg.h;
                sx = poleFg.s;
            } else {
                hx = poleBg.h;
                sx = poleBg.s;
            }
        }
        const lx = scale(l, 0, 1, 0.5, 0.2);
        return {h: hx, s: sx, l: lx, a};
    }
    function modifyBorderColor(rgb, theme) {
        if (theme.mode === 0) {
            return modifyLightSchemeColor(rgb, theme);
        }
        const poleFg = getFgPole(theme);
        const poleBg = getBgPole(theme);
        return modifyColorWithCache(
            rgb,
            {...theme, mode: 0},
            modifyBorderHSL,
            poleFg,
            poleBg
        );
    }
    function modifyShadowColor(rgb, filter) {
        return modifyBackgroundColor(rgb, filter);
    }
    function modifyGradientColor(rgb, filter) {
        return modifyBackgroundColor(rgb, filter);
    }

    function createTextStyle(config) {
        const lines = [];
        lines.push(
            '*:not(pre, pre *, code, .far, .fa, .glyphicon, [class*="vjs-"], .fab, .fa-github, .fas, .material-icons, .icofont, .typcn, mu, [class*="mu-"], .glyphicon, .icon) {'
        );
        if (config.useFont && config.fontFamily) {
            lines.push(`  font-family: ${config.fontFamily} !important;`);
        }
        if (config.textStroke > 0) {
            lines.push(
                `  -webkit-text-stroke: ${config.textStroke}px !important;`
            );
            lines.push(`  text-stroke: ${config.textStroke}px !important;`);
        }
        lines.push("}");
        return lines.join("\n");
    }

    var FilterMode;
    (function (FilterMode) {
        FilterMode[(FilterMode["light"] = 0)] = "light";
        FilterMode[(FilterMode["dark"] = 1)] = "dark";
    })(FilterMode || (FilterMode = {}));
    function getCSSFilterValue(config) {
        const filters = [];
        if (config.mode === FilterMode.dark) {
            filters.push("invert(100%) hue-rotate(180deg)");
        }
        if (config.brightness !== 100) {
            filters.push(`brightness(${config.brightness}%)`);
        }
        if (config.contrast !== 100) {
            filters.push(`contrast(${config.contrast}%)`);
        }
        if (config.grayscale !== 0) {
            filters.push(`grayscale(${config.grayscale}%)`);
        }
        if (config.sepia !== 0) {
            filters.push(`sepia(${config.sepia}%)`);
        }
        if (filters.length === 0) {
            return null;
        }
        return filters.join(" ");
    }

    function toSVGMatrix(matrix) {
        return matrix
            .slice(0, 4)
            .map((m) => m.map((m) => m.toFixed(3)).join(" "))
            .join(" ");
    }
    function getSVGFilterMatrixValue(config) {
        return toSVGMatrix(createFilterMatrix(config));
    }

    function hexify(number) {
        return (number < 16 ? "0" : "") + number.toString(16);
    }
    function generateUID() {
        if ("randomUUID" in crypto) {
            const uuid = crypto.randomUUID();
            return (
                uuid.substring(0, 8) +
                uuid.substring(9, 13) +
                uuid.substring(14, 18) +
                uuid.substring(19, 23) +
                uuid.substring(24)
            );
        }
        if ("getRandomValues" in crypto) {
            return Array.from(crypto.getRandomValues(new Uint8Array(16)))
                .map((x) => hexify(x))
                .join("");
        }
        return Math.floor(Math.random() * 2 ** 55).toString(36);
    }

    const resolvers$1 = new Map();
    const rejectors = new Map();
    async function bgFetch(request) {
        return new Promise((resolve, reject) => {
            const id = generateUID();
            resolvers$1.set(id, resolve);
            rejectors.set(id, reject);
            chrome.runtime.sendMessage({
                type: MessageTypeCStoBG.FETCH,
                data: request,
                id
            });
        });
    }
    chrome.runtime.onMessage.addListener(({type, data, error, id}) => {
        if (type === MessageTypeBGtoCS.FETCH_RESPONSE) {
            const resolve = resolvers$1.get(id);
            const reject = rejectors.get(id);
            resolvers$1.delete(id);
            rejectors.delete(id);
            if (error) {
                reject && reject(error);
            } else {
                resolve && resolve(data);
            }
        }
    });

    async function getOKResponse(url, mimeType, origin) {
        const response = await fetch(url, {
            cache: "force-cache",
            credentials: "omit",
            referrer: origin
        });
        if (
            mimeType &&
            !response.headers.get("Content-Type").startsWith(mimeType)
        ) {
            throw new Error(`Mime type mismatch when loading ${url}`);
        }
        if (!response.ok) {
            throw new Error(
                `Unable to load ${url} ${response.status} ${response.statusText}`
            );
        }
        return response;
    }
    async function loadAsDataURL(url, mimeType) {
        const response = await getOKResponse(url, mimeType);
        return await readResponseAsDataURL(response);
    }
    async function loadAsBlob(url, mimeType) {
        const response = await getOKResponse(url, mimeType);
        return await response.blob();
    }
    async function readResponseAsDataURL(response) {
        const blob = await response.blob();
        const dataURL = await new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
        return dataURL;
    }

    const MAX_FRAME_DURATION = 1000 / 60;
    class AsyncQueue {
        constructor() {
            this.queue = [];
            this.timerId = null;
        }
        addTask(task) {
            this.queue.push(task);
            this.scheduleFrame();
        }
        stop() {
            if (this.timerId !== null) {
                cancelAnimationFrame(this.timerId);
                this.timerId = null;
            }
            this.queue = [];
        }
        scheduleFrame() {
            if (this.timerId) {
                return;
            }
            this.timerId = requestAnimationFrame(() => {
                this.timerId = null;
                const start = Date.now();
                let cb;
                while ((cb = this.queue.shift())) {
                    cb();
                    if (Date.now() - start >= MAX_FRAME_DURATION) {
                        this.scheduleFrame();
                        break;
                    }
                }
            });
        }
    }

    const imageManager = new AsyncQueue();
    async function getImageDetails(url) {
        return new Promise(async (resolve, reject) => {
            var _a, _b;
            try {
                const dataURL = url.startsWith("data:")
                    ? url
                    : await getDataURL(url);
                const blob =
                    (_a = tryConvertDataURLToBlobSync(dataURL)) !== null &&
                    _a !== void 0
                        ? _a
                        : await loadAsBlob(url);
                let image;
                if (dataURL.startsWith("data:image/svg+xml")) {
                    image = await loadImage(dataURL);
                } else {
                    image =
                        (_b = await tryCreateImageBitmap(blob)) !== null &&
                        _b !== void 0
                            ? _b
                            : await loadImage(dataURL);
                }
                imageManager.addTask(() => {
                    const analysis = analyzeImage(image);
                    resolve({
                        src: url,
                        blob,
                        dataURL,
                        width: image.width,
                        height: image.height,
                        ...analysis
                    });
                });
            } catch (error) {
                reject(error);
            }
        });
    }
    async function getDataURL(url) {
        const parsedURL = new URL(url);
        if (parsedURL.origin === location.origin) {
            return await loadAsDataURL(url);
        }
        return await bgFetch({url, responseType: "data-url"});
    }
    async function tryCreateImageBitmap(blob) {
        try {
            return await createImageBitmap(blob);
        } catch (err) {
            logWarn(
                `Unable to create image bitmap for type ${blob.type}: ${String(
                    err
                )}`
            );
            return null;
        }
    }
    const INCOMPLETE_DOC_LOADING_IMAGE_LIMIT = 256;
    let loadingImagesCount = 0;
    async function loadImage(url) {
        return new Promise((resolve, reject) => {
            const image = new Image();
            image.onload = () => resolve(image);
            image.onerror = () => reject(`Unable to load image ${url}`);
            if (
                ++loadingImagesCount <= INCOMPLETE_DOC_LOADING_IMAGE_LIMIT ||
                isReadyStateComplete()
            ) {
                image.src = url;
            } else {
                addReadyStateCompleteListener(() => (image.src = url));
            }
        });
    }
    const MAX_ANALYSIS_PIXELS_COUNT = 32 * 32;
    let canvas;
    let context;
    function createCanvas() {
        const maxWidth = MAX_ANALYSIS_PIXELS_COUNT;
        const maxHeight = MAX_ANALYSIS_PIXELS_COUNT;
        canvas = document.createElement("canvas");
        canvas.width = maxWidth;
        canvas.height = maxHeight;
        context = canvas.getContext("2d", {willReadFrequently: true});
        context.imageSmoothingEnabled = false;
    }
    function removeCanvas() {
        canvas = null;
        context = null;
    }
    const LARGE_IMAGE_PIXELS_COUNT = 512 * 512;
    function analyzeImage(image) {
        if (!canvas) {
            createCanvas();
        }
        let sw;
        let sh;
        if (image instanceof HTMLImageElement) {
            sw = image.naturalWidth;
            sh = image.naturalHeight;
        } else {
            sw = image.width;
            sh = image.height;
        }
        if (sw === 0 || sh === 0) {
            return {
                isDark: false,
                isLight: false,
                isTransparent: false,
                isLarge: false,
                isTooLarge: false
            };
        }
        if (sw * sh > LARGE_IMAGE_PIXELS_COUNT) {
            return {
                isDark: false,
                isLight: false,
                isTransparent: false,
                isLarge: true
            };
        }
        const sourcePixelsCount = sw * sh;
        const k = Math.min(
            1,
            Math.sqrt(MAX_ANALYSIS_PIXELS_COUNT / sourcePixelsCount)
        );
        const width = Math.ceil(sw * k);
        const height = Math.ceil(sh * k);
        context.clearRect(0, 0, width, height);
        context.drawImage(image, 0, 0, sw, sh, 0, 0, width, height);
        const imageData = context.getImageData(0, 0, width, height);
        const d = imageData.data;
        const TRANSPARENT_ALPHA_THRESHOLD = 0.05;
        const DARK_LIGHTNESS_THRESHOLD = 0.4;
        const LIGHT_LIGHTNESS_THRESHOLD = 0.7;
        let transparentPixelsCount = 0;
        let darkPixelsCount = 0;
        let lightPixelsCount = 0;
        let i, x, y;
        let r, g, b, a;
        let l;
        for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
                i = 4 * (y * width + x);
                r = d[i + 0];
                g = d[i + 1];
                b = d[i + 2];
                a = d[i + 3];
                if (a / 255 < TRANSPARENT_ALPHA_THRESHOLD) {
                    transparentPixelsCount++;
                } else {
                    l = getSRGBLightness(r, g, b);
                    if (l < DARK_LIGHTNESS_THRESHOLD) {
                        darkPixelsCount++;
                    }
                    if (l > LIGHT_LIGHTNESS_THRESHOLD) {
                        lightPixelsCount++;
                    }
                }
            }
        }
        const totalPixelsCount = width * height;
        const opaquePixelsCount = totalPixelsCount - transparentPixelsCount;
        const DARK_IMAGE_THRESHOLD = 0.7;
        const LIGHT_IMAGE_THRESHOLD = 0.7;
        const TRANSPARENT_IMAGE_THRESHOLD = 0.1;
        return {
            isDark: darkPixelsCount / opaquePixelsCount >= DARK_IMAGE_THRESHOLD,
            isLight:
                lightPixelsCount / opaquePixelsCount >= LIGHT_IMAGE_THRESHOLD,
            isTransparent:
                transparentPixelsCount / totalPixelsCount >=
                TRANSPARENT_IMAGE_THRESHOLD,
            isLarge: false
        };
    }
    let isBlobURLSupported = null;
    let canUseProxy = false;
    let blobURLCheckRequested = false;
    const blobURLCheckAwaiters = [];
    document.addEventListener(
        "__darkreader__inlineScriptsAllowed",
        () => (canUseProxy = true),
        {once: true}
    );
    async function requestBlobURLCheck() {
        if (!canUseProxy) {
            return;
        }
        if (blobURLCheckRequested) {
            return await new Promise((resolve) =>
                blobURLCheckAwaiters.push(resolve)
            );
        }
        blobURLCheckRequested = true;
        await new Promise((resolve) => {
            document.addEventListener(
                "__darkreader__blobURLCheckResponse",
                (e) => {
                    isBlobURLSupported = e.detail.blobURLAllowed;
                    resolve();
                    blobURLCheckAwaiters.forEach((r) => r());
                    blobURLCheckAwaiters.splice(0);
                },
                {once: true}
            );
            document.dispatchEvent(
                new CustomEvent("__darkreader__blobURLCheckRequest")
            );
        });
    }
    function isBlobURLCheckResultReady() {
        return isBlobURLSupported != null || !canUseProxy;
    }
    function onCSPError(err) {
        if (err.blockedURI === "blob") {
            isBlobURLSupported = false;
            document.removeEventListener("securitypolicyviolation", onCSPError);
        }
    }
    document.addEventListener("securitypolicyviolation", onCSPError);
    const objectURLs = new Set();
    function getFilteredImageURL({dataURL, width, height}, theme) {
        if (dataURL.startsWith("data:image/svg+xml")) {
            dataURL = escapeXML(dataURL);
        }
        const matrix = getSVGFilterMatrixValue(theme);
        const svg = [
            `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${width}" height="${height}">`,
            "<defs>",
            '<filter id="darkreader-image-filter">',
            `<feColorMatrix type="matrix" values="${matrix}" />`,
            "</filter>",
            "</defs>",
            `<image width="${width}" height="${height}" filter="url(#darkreader-image-filter)" xlink:href="${dataURL}" />`,
            "</svg>"
        ].join("");
        if (!isBlobURLSupported) {
            return `data:image/svg+xml;base64,${btoa(svg)}`;
        }
        const bytes = new Uint8Array(svg.length);
        for (let i = 0; i < svg.length; i++) {
            bytes[i] = svg.charCodeAt(i);
        }
        const blob = new Blob([bytes], {type: "image/svg+xml"});
        const objectURL = URL.createObjectURL(blob);
        objectURLs.add(objectURL);
        return objectURL;
    }
    const xmlEscapeChars = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        "'": "&apos;",
        '"': "&quot;"
    };
    function escapeXML(str) {
        return str.replace(/[<>&'"]/g, (c) => {
            var _a;
            return (_a = xmlEscapeChars[c]) !== null && _a !== void 0 ? _a : c;
        });
    }
    const dataURLBlobURLs = new Map();
    function tryConvertDataURLToBlobSync(dataURL) {
        const colonIndex = dataURL.indexOf(":");
        const semicolonIndex = dataURL.indexOf(";", colonIndex + 1);
        const commaIndex = dataURL.indexOf(",", semicolonIndex + 1);
        const encoding = dataURL
            .substring(semicolonIndex + 1, commaIndex)
            .toLocaleLowerCase();
        const mediaType = dataURL.substring(colonIndex + 1, semicolonIndex);
        if (encoding !== "base64" || !mediaType) {
            return null;
        }
        const characters = atob(dataURL.substring(commaIndex + 1));
        const bytes = new Uint8Array(characters.length);
        for (let i = 0; i < characters.length; i++) {
            bytes[i] = characters.charCodeAt(i);
        }
        return new Blob([bytes], {type: mediaType});
    }
    async function tryConvertDataURLToBlobURL(dataURL) {
        if (!isBlobURLSupported) {
            return null;
        }
        let blobURL = dataURLBlobURLs.get(dataURL);
        if (blobURL) {
            return blobURL;
        }
        let blob = tryConvertDataURLToBlobSync(dataURL);
        if (!blob) {
            const response = await fetch(dataURL);
            blob = await response.blob();
        }
        blobURL = URL.createObjectURL(blob);
        dataURLBlobURLs.set(dataURL, blobURL);
        return blobURL;
    }
    function cleanImageProcessingCache() {
        imageManager && imageManager.stop();
        removeCanvas();
        objectURLs.forEach((u) => URL.revokeObjectURL(u));
        objectURLs.clear();
        dataURLBlobURLs.forEach((u) => URL.revokeObjectURL(u));
        dataURLBlobURLs.clear();
    }

    const gradientLength = "gradient".length;
    const conicGradient = "conic-";
    const conicGradientLength = conicGradient.length;
    const radialGradient = "radial-";
    const linearGradient = "linear-";
    function parseGradient(value) {
        const result = [];
        let index = 0;
        let startIndex = conicGradient.length;
        while ((index = value.indexOf("gradient", startIndex)) !== -1) {
            let typeGradient;
            [linearGradient, radialGradient, conicGradient].find(
                (possibleType) => {
                    if (index - possibleType.length >= 0) {
                        const possibleGradient = value.substring(
                            index - possibleType.length,
                            index
                        );
                        if (possibleGradient === possibleType) {
                            if (
                                value.slice(
                                    index - possibleType.length - 10,
                                    index - possibleType.length - 1
                                ) === "repeating"
                            ) {
                                typeGradient = `repeating-${possibleType}gradient`;
                                return true;
                            }
                            if (
                                value.slice(
                                    index - possibleType.length - 8,
                                    index - possibleType.length - 1
                                ) === "-webkit"
                            ) {
                                typeGradient = `-webkit-${possibleType}gradient`;
                                return true;
                            }
                            typeGradient = `${possibleType}gradient`;
                            return true;
                        }
                    }
                }
            );
            if (!typeGradient) {
                break;
            }
            const {start, end} = getParenthesesRange(
                value,
                index + gradientLength
            );
            const match = value.substring(start + 1, end - 1);
            startIndex = end + 1 + conicGradientLength;
            result.push({
                typeGradient,
                match,
                offset: typeGradient.length + 2,
                index: index - typeGradient.length + gradientLength,
                hasComma: true
            });
        }
        if (result.length) {
            result[result.length - 1].hasComma = false;
        }
        return result;
    }

    function getPriority(ruleStyle, property) {
        return Boolean(ruleStyle && ruleStyle.getPropertyPriority(property));
    }
    function getModifiableCSSDeclaration(
        property,
        value,
        rule,
        variablesStore,
        ignoreImageSelectors,
        isCancelled
    ) {
        if (property.startsWith("--")) {
            const modifier = getVariableModifier(
                variablesStore,
                property,
                value,
                rule,
                ignoreImageSelectors,
                isCancelled
            );
            if (modifier) {
                return {
                    property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        } else if (value.includes("var(")) {
            const modifier = getVariableDependantModifier(
                variablesStore,
                property,
                value
            );
            if (modifier) {
                return {
                    property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        } else if (property === "color-scheme") {
            return null;
        } else if (
            (property.includes("color") &&
                property !== "-webkit-print-color-adjust") ||
            property === "fill" ||
            property === "stroke" ||
            property === "stop-color"
        ) {
            const modifier = getColorModifier(property, value, rule);
            if (modifier) {
                return {
                    property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        } else if (
            property === "background-image" ||
            property === "list-style-image"
        ) {
            const modifier = getBgImageModifier(
                value,
                rule,
                ignoreImageSelectors,
                isCancelled
            );
            if (modifier) {
                return {
                    property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        } else if (property.includes("shadow")) {
            const modifier = getShadowModifier(value);
            if (modifier) {
                return {
                    property,
                    value: modifier,
                    important: getPriority(rule.style, property),
                    sourceValue: value
                };
            }
        }
        return null;
    }
    function joinSelectors(...selectors) {
        return selectors.filter(Boolean).join(", ");
    }
    function getModifiedUserAgentStyle(theme, isIFrame, styleSystemControls) {
        const lines = [];
        if (!isIFrame) {
            lines.push("html {");
            lines.push(
                `    background-color: ${modifyBackgroundColor(
                    {r: 255, g: 255, b: 255},
                    theme
                )} !important;`
            );
            lines.push("}");
        }
        if (isCSSColorSchemePropSupported) {
            lines.push("html {");
            lines.push(
                `    color-scheme: ${
                    theme.mode === 1 ? "dark" : "dark light"
                } !important;`
            );
            lines.push("}");
        }
        const bgSelectors = joinSelectors(
            isIFrame ? "" : "html, body",
            styleSystemControls ? "input, textarea, select, button, dialog" : ""
        );
        if (bgSelectors) {
            lines.push(`${bgSelectors} {`);
            lines.push(
                `    background-color: ${modifyBackgroundColor(
                    {r: 255, g: 255, b: 255},
                    theme
                )};`
            );
            lines.push("}");
        }
        lines.push(
            `${joinSelectors(
                "html, body",
                styleSystemControls ? "input, textarea, select, button" : ""
            )} {`
        );
        lines.push(
            `    border-color: ${modifyBorderColor(
                {r: 76, g: 76, b: 76},
                theme
            )};`
        );
        lines.push(
            `    color: ${modifyForegroundColor({r: 0, g: 0, b: 0}, theme)};`
        );
        lines.push("}");
        lines.push("a {");
        lines.push(
            `    color: ${modifyForegroundColor({r: 0, g: 64, b: 255}, theme)};`
        );
        lines.push("}");
        lines.push("table {");
        lines.push(
            `    border-color: ${modifyBorderColor(
                {r: 128, g: 128, b: 128},
                theme
            )};`
        );
        lines.push("}");
        lines.push("::placeholder {");
        lines.push(
            `    color: ${modifyForegroundColor(
                {r: 169, g: 169, b: 169},
                theme
            )};`
        );
        lines.push("}");
        lines.push("input:-webkit-autofill,");
        lines.push("textarea:-webkit-autofill,");
        lines.push("select:-webkit-autofill {");
        lines.push(
            `    background-color: ${modifyBackgroundColor(
                {r: 250, g: 255, b: 189},
                theme
            )} !important;`
        );
        lines.push(
            `    color: ${modifyForegroundColor(
                {r: 0, g: 0, b: 0},
                theme
            )} !important;`
        );
        lines.push("}");
        if (theme.scrollbarColor) {
            lines.push(getModifiedScrollbarStyle(theme));
        }
        if (theme.selectionColor) {
            lines.push(getModifiedSelectionStyle(theme));
        }
        return lines.join("\n");
    }
    function getSelectionColor(theme) {
        let backgroundColorSelection;
        let foregroundColorSelection;
        if (theme.selectionColor === "auto") {
            backgroundColorSelection = modifyBackgroundColor(
                {r: 0, g: 96, b: 212},
                {...theme, grayscale: 0}
            );
            foregroundColorSelection = modifyForegroundColor(
                {r: 255, g: 255, b: 255},
                {...theme, grayscale: 0}
            );
        } else {
            const rgb = parseColorWithCache(theme.selectionColor);
            const hsl = rgbToHSL(rgb);
            backgroundColorSelection = theme.selectionColor;
            if (hsl.l < 0.5) {
                foregroundColorSelection = "#FFF";
            } else {
                foregroundColorSelection = "#000";
            }
        }
        return {backgroundColorSelection, foregroundColorSelection};
    }
    function getModifiedSelectionStyle(theme) {
        const lines = [];
        const modifiedSelectionColor = getSelectionColor(theme);
        const backgroundColorSelection =
            modifiedSelectionColor.backgroundColorSelection;
        const foregroundColorSelection =
            modifiedSelectionColor.foregroundColorSelection;
        ["::selection", "::-moz-selection"].forEach((selection) => {
            lines.push(`${selection} {`);
            lines.push(
                `    background-color: ${backgroundColorSelection} !important;`
            );
            lines.push(`    color: ${foregroundColorSelection} !important;`);
            lines.push("}");
        });
        return lines.join("\n");
    }
    function getModifiedScrollbarStyle(theme) {
        const lines = [];
        let colorTrack;
        let colorIcons;
        let colorThumb;
        let colorThumbHover;
        let colorThumbActive;
        let colorCorner;
        if (theme.scrollbarColor === "auto") {
            colorTrack = modifyBackgroundColor({r: 241, g: 241, b: 241}, theme);
            colorIcons = modifyForegroundColor({r: 96, g: 96, b: 96}, theme);
            colorThumb = modifyBackgroundColor({r: 176, g: 176, b: 176}, theme);
            colorThumbHover = modifyBackgroundColor(
                {r: 144, g: 144, b: 144},
                theme
            );
            colorThumbActive = modifyBackgroundColor(
                {r: 96, g: 96, b: 96},
                theme
            );
            colorCorner = modifyBackgroundColor(
                {r: 255, g: 255, b: 255},
                theme
            );
        } else {
            const rgb = parseColorWithCache(theme.scrollbarColor);
            const hsl = rgbToHSL(rgb);
            const isLight = hsl.l > 0.5;
            const lighten = (lighter) => ({
                ...hsl,
                l: clamp(hsl.l + lighter, 0, 1)
            });
            const darken = (darker) => ({
                ...hsl,
                l: clamp(hsl.l - darker, 0, 1)
            });
            colorTrack = hslToString(darken(0.4));
            colorIcons = hslToString(isLight ? darken(0.4) : lighten(0.4));
            colorThumb = hslToString(hsl);
            colorThumbHover = hslToString(lighten(0.1));
            colorThumbActive = hslToString(lighten(0.2));
            colorCorner = hslToString(darken(0.5));
        }
        lines.push("::-webkit-scrollbar {");
        lines.push(`    background-color: ${colorTrack};`);
        lines.push(`    color: ${colorIcons};`);
        lines.push("}");
        lines.push("::-webkit-scrollbar-thumb {");
        lines.push(`    background-color: ${colorThumb};`);
        lines.push("}");
        lines.push("::-webkit-scrollbar-thumb:hover {");
        lines.push(`    background-color: ${colorThumbHover};`);
        lines.push("}");
        lines.push("::-webkit-scrollbar-thumb:active {");
        lines.push(`    background-color: ${colorThumbActive};`);
        lines.push("}");
        lines.push("::-webkit-scrollbar-corner {");
        lines.push(`    background-color: ${colorCorner};`);
        lines.push("}");
        return lines.join("\n");
    }
    function getModifiedFallbackStyle(filter, {strict}) {
        const factory = defaultFallbackFactory;
        return factory(filter, {strict});
    }
    function defaultFallbackFactory(filter, {strict}) {
        const lines = [];
        const isMicrosoft = ["microsoft.com", "docs.microsoft.com"].includes(
            location.hostname
        );
        lines.push(
            `html, body, ${
                strict
                    ? `body :not(iframe)${
                          isMicrosoft
                              ? ':not(div[style^="position:absolute;top:0;left:-"]'
                              : ""
                      }`
                    : "body > :not(iframe)"
            } {`
        );
        lines.push(
            `    background-color: ${modifyBackgroundColor(
                {r: 255, g: 255, b: 255},
                filter
            )} !important;`
        );
        lines.push(
            `    border-color: ${modifyBorderColor(
                {r: 64, g: 64, b: 64},
                filter
            )} !important;`
        );
        lines.push(
            `    color: ${modifyForegroundColor(
                {r: 0, g: 0, b: 0},
                filter
            )} !important;`
        );
        lines.push("}");
        return lines.join("\n");
    }
    const unparsableColors = new Set([
        "inherit",
        "transparent",
        "initial",
        "currentcolor",
        "none",
        "unset"
    ]);
    function getColorModifier(prop, value, rule) {
        if (unparsableColors.has(value.toLowerCase())) {
            return value;
        }
        const rgb = parseColorWithCache(value);
        if (!rgb) {
            return null;
        }
        if (prop.includes("background")) {
            if (
                (rule.style.webkitMaskImage &&
                    rule.style.webkitMaskImage !== "none") ||
                (rule.style.webkitMask &&
                    !rule.style.webkitMask.startsWith("none")) ||
                (rule.style.mask && rule.style.mask !== "none") ||
                (rule.style.getPropertyValue("mask-image") &&
                    rule.style.getPropertyValue("mask-image") !== "none")
            ) {
                return (filter) => modifyForegroundColor(rgb, filter);
            }
            return (filter) => modifyBackgroundColor(rgb, filter);
        }
        if (prop.includes("border") || prop.includes("outline")) {
            return (filter) => modifyBorderColor(rgb, filter);
        }
        return (filter) => modifyForegroundColor(rgb, filter);
    }
    const imageDetailsCache = new Map();
    const awaitingForImageLoading = new Map();
    function shouldIgnoreImage(selectorText, selectors) {
        if (!selectorText || selectors.length === 0) {
            return false;
        }
        if (selectors.some((s) => s === "*")) {
            return true;
        }
        const ruleSelectors = selectorText.split(/,\s*/g);
        for (let i = 0; i < selectors.length; i++) {
            const ignoredSelector = selectors[i];
            if (ruleSelectors.some((s) => s === ignoredSelector)) {
                return true;
            }
        }
        return false;
    }
    function getBgImageModifier(
        value,
        rule,
        ignoreImageSelectors,
        isCancelled
    ) {
        try {
            const gradients = parseGradient(value);
            const urls = getMatches(cssURLRegex, value);
            if (urls.length === 0 && gradients.length === 0) {
                return value;
            }
            const getIndices = (matches) => {
                let index = 0;
                return matches.map((match) => {
                    const valueIndex = value.indexOf(match, index);
                    index = valueIndex + match.length;
                    return {match, index: valueIndex};
                });
            };
            const matches = gradients
                .map((i) => ({type: "gradient", ...i}))
                .concat(
                    getIndices(urls).map((i) => ({
                        type: "url",
                        offset: 0,
                        ...i
                    }))
                )
                .sort((a, b) => (a.index > b.index ? 1 : -1));
            const getGradientModifier = (gradient) => {
                const {typeGradient, match, hasComma} = gradient;
                const partsRegex =
                    /([^\(\),]+(\([^\(\)]*(\([^\(\)]*\)*[^\(\)]*)?\))?([^\(\), ]|( (?!calc)))*),?/g;
                const colorStopRegex =
                    /^(from|color-stop|to)\(([^\(\)]*?,\s*)?(.*?)\)$/;
                const parts = getMatches(partsRegex, match, 1).map((part) => {
                    part = part.trim();
                    let rgb = parseColorWithCache(part);
                    if (rgb) {
                        return (filter) => modifyGradientColor(rgb, filter);
                    }
                    const space = part.lastIndexOf(" ");
                    rgb = parseColorWithCache(part.substring(0, space));
                    if (rgb) {
                        return (filter) =>
                            `${modifyGradientColor(
                                rgb,
                                filter
                            )} ${part.substring(space + 1)}`;
                    }
                    const colorStopMatch = part.match(colorStopRegex);
                    if (colorStopMatch) {
                        rgb = parseColorWithCache(colorStopMatch[3]);
                        if (rgb) {
                            return (filter) =>
                                `${colorStopMatch[1]}(${
                                    colorStopMatch[2]
                                        ? `${colorStopMatch[2]}, `
                                        : ""
                                }${modifyGradientColor(rgb, filter)})`;
                        }
                    }
                    return () => part;
                });
                return (filter) => {
                    return `${typeGradient}(${parts
                        .map((modify) => modify(filter))
                        .join(", ")})${hasComma ? ", " : ""}`;
                };
            };
            const getURLModifier = (urlValue) => {
                var _a;
                if (
                    shouldIgnoreImage(rule.selectorText, ignoreImageSelectors)
                ) {
                    return null;
                }
                let url = getCSSURLValue(urlValue);
                const isURLEmpty = url.length === 0;
                const {parentStyleSheet} = rule;
                const baseURL =
                    parentStyleSheet && parentStyleSheet.href
                        ? getCSSBaseBath(parentStyleSheet.href)
                        : ((_a = parentStyleSheet.ownerNode) === null ||
                          _a === void 0
                              ? void 0
                              : _a.baseURI) || location.origin;
                url = getAbsoluteURL(baseURL, url);
                return async (filter) => {
                    if (isURLEmpty) {
                        return "url('')";
                    }
                    let imageDetails = null;
                    if (imageDetailsCache.has(url)) {
                        imageDetails = imageDetailsCache.get(url);
                    } else {
                        try {
                            if (!isBlobURLCheckResultReady()) {
                                await requestBlobURLCheck();
                            }
                            if (awaitingForImageLoading.has(url)) {
                                const awaiters =
                                    awaitingForImageLoading.get(url);
                                imageDetails = await new Promise((resolve) =>
                                    awaiters.push(resolve)
                                );
                                if (!imageDetails) {
                                    return null;
                                }
                            } else {
                                awaitingForImageLoading.set(url, []);
                                imageDetails = await getImageDetails(url);
                                imageDetailsCache.set(url, imageDetails);
                                awaitingForImageLoading
                                    .get(url)
                                    .forEach((resolve) =>
                                        resolve(imageDetails)
                                    );
                                awaitingForImageLoading.delete(url);
                            }
                            if (isCancelled()) {
                                return null;
                            }
                        } catch (err) {
                            logWarn(err);
                            if (awaitingForImageLoading.has(url)) {
                                awaitingForImageLoading
                                    .get(url)
                                    .forEach((resolve) => resolve(null));
                                awaitingForImageLoading.delete(url);
                            }
                        }
                    }
                    if (imageDetails) {
                        const bgImageValue = getBgImageValue(
                            imageDetails,
                            filter
                        );
                        if (bgImageValue) {
                            return bgImageValue;
                        }
                    }
                    if (url.startsWith("data:")) {
                        const blobURL = await tryConvertDataURLToBlobURL(url);
                        if (blobURL) {
                            return `url("${blobURL}")`;
                        }
                    }
                    return `url("${url}")`;
                };
            };
            const getBgImageValue = (imageDetails, filter) => {
                const {isDark, isLight, isTransparent, isLarge, width} =
                    imageDetails;
                let result;
                const logSrc = imageDetails.src.startsWith("data:")
                    ? "data:"
                    : imageDetails.src;
                if (isLarge) {
                    logInfo(`Not modifying too large image ${logSrc}`);
                    result = null;
                } else if (
                    isDark &&
                    isTransparent &&
                    filter.mode === 1 &&
                    width > 2
                ) {
                    logInfo(`Inverting dark image ${logSrc}`);
                    const inverted = getFilteredImageURL(imageDetails, {
                        ...filter,
                        sepia: clamp(filter.sepia + 10, 0, 100)
                    });
                    result = `url("${inverted}")`;
                } else if (isLight && !isTransparent && filter.mode === 1) {
                    logInfo(`Dimming light image ${logSrc}`);
                    const dimmed = getFilteredImageURL(imageDetails, filter);
                    result = `url("${dimmed}")`;
                } else if (filter.mode === 0 && isLight) {
                    logInfo(`Applying filter to image ${logSrc}`);
                    const filtered = getFilteredImageURL(imageDetails, {
                        ...filter,
                        brightness: clamp(filter.brightness - 10, 5, 200),
                        sepia: clamp(filter.sepia + 10, 0, 100)
                    });
                    result = `url("${filtered}")`;
                } else {
                    logInfo(`Not modifying the image ${logSrc}`);
                    result = null;
                }
                return result;
            };
            const modifiers = [];
            let matchIndex = 0;
            let prevHasComma = false;
            matches.forEach(
                ({type, match, index, typeGradient, hasComma, offset}, i) => {
                    const matchStart = index;
                    const prefixStart = matchIndex;
                    const matchEnd = matchStart + match.length + offset;
                    matchIndex = matchEnd;
                    if (prefixStart !== matchStart) {
                        if (prevHasComma) {
                            modifiers.push(() => {
                                let betweenValue = value.substring(
                                    prefixStart,
                                    matchStart
                                );
                                if (betweenValue[0] === ",") {
                                    betweenValue = betweenValue.substring(1);
                                }
                                return betweenValue;
                            });
                        } else {
                            modifiers.push(() =>
                                value.substring(prefixStart, matchStart)
                            );
                        }
                    }
                    prevHasComma = hasComma || false;
                    if (type === "url") {
                        modifiers.push(getURLModifier(match));
                    } else if (type === "gradient") {
                        modifiers.push(
                            getGradientModifier({
                                match,
                                index,
                                typeGradient: typeGradient,
                                hasComma: hasComma || false,
                                offset
                            })
                        );
                    }
                    if (i === matches.length - 1) {
                        modifiers.push(() => value.substring(matchEnd));
                    }
                }
            );
            return (filter) => {
                const results = modifiers
                    .filter(Boolean)
                    .map((modify) => modify(filter));
                if (results.some((r) => r instanceof Promise)) {
                    return Promise.all(results).then((asyncResults) => {
                        return asyncResults.filter(Boolean).join("");
                    });
                }
                const combinedResult = results.join("");
                if (combinedResult.endsWith(", initial")) {
                    return combinedResult.slice(0, -9);
                }
                return combinedResult;
            };
        } catch (err) {
            return null;
        }
    }
    function getShadowModifierWithInfo(value) {
        try {
            let index = 0;
            const colorMatches = getMatches(
                /(^|\s)(?!calc)([a-z]+\(.+?\)|#[0-9a-f]+|[a-z]+)(.*?(inset|outset)?($|,))/gi,
                value,
2
            );
            let notParsed = 0;
            const modifiers = colorMatches.map((match, i) => {
                const prefixIndex = index;
                const matchIndex = value.indexOf(match, index);
                const matchEnd = matchIndex + match.length;
                index = matchEnd;
                const rgb = parseColorWithCache(match);
                if (!rgb) {
                    notParsed++;
                    return () => value.substring(prefixIndex, matchEnd);
                }
                return (filter) =>
                    `${value.substring(
                        prefixIndex,
                        matchIndex
                    )}${modifyShadowColor(rgb, filter)}${
                        i === colorMatches.length - 1
                            ? value.substring(matchEnd)
                            : ""
                    }`;
            });
            return (filter) => {
                const modified = modifiers
                    .map((modify) => modify(filter))
                    .join("");
                return {
                    matchesLength: colorMatches.length,
                    unparseableMatchesLength: notParsed,
                    result: modified
                };
            };
        } catch (err) {
            return null;
        }
    }
    function getShadowModifier(value) {
        const shadowModifier = getShadowModifierWithInfo(value);
        if (!shadowModifier) {
            return null;
        }
        return (theme) => shadowModifier(theme).result;
    }
    function getVariableModifier(
        variablesStore,
        prop,
        value,
        rule,
        ignoredImgSelectors,
        isCancelled
    ) {
        return variablesStore.getModifierForVariable({
            varName: prop,
            sourceValue: value,
            rule,
            ignoredImgSelectors,
            isCancelled
        });
    }
    function getVariableDependantModifier(variablesStore, prop, value) {
        return variablesStore.getModifierForVarDependant(prop, value);
    }
    function cleanModificationCache() {
        clearColorModificationCache();
        imageDetailsCache.clear();
        cleanImageProcessingCache();
        awaitingForImageLoading.clear();
    }

    const VAR_TYPE_BGCOLOR = 1 << 0;
    const VAR_TYPE_TEXTCOLOR = 1 << 1;
    const VAR_TYPE_BORDERCOLOR = 1 << 2;
    const VAR_TYPE_BGIMG = 1 << 3;
    class VariablesStore {
        constructor() {
            this.varTypes = new Map();
            this.rulesQueue = [];
            this.inlineStyleQueue = [];
            this.definedVars = new Set();
            this.varRefs = new Map();
            this.unknownColorVars = new Set();
            this.unknownBgVars = new Set();
            this.undefinedVars = new Set();
            this.initialVarTypes = new Map();
            this.changedTypeVars = new Set();
            this.typeChangeSubscriptions = new Map();
            this.unstableVarValues = new Map();
        }
        clear() {
            this.varTypes.clear();
            this.rulesQueue.splice(0);
            this.inlineStyleQueue.splice(0);
            this.definedVars.clear();
            this.varRefs.clear();
            this.unknownColorVars.clear();
            this.unknownBgVars.clear();
            this.undefinedVars.clear();
            this.initialVarTypes.clear();
            this.changedTypeVars.clear();
            this.typeChangeSubscriptions.clear();
            this.unstableVarValues.clear();
        }
        isVarType(varName, typeNum) {
            return (
                this.varTypes.has(varName) &&
                (this.varTypes.get(varName) & typeNum) > 0
            );
        }
        addRulesForMatching(rules) {
            this.rulesQueue.push(rules);
        }
        addInlineStyleForMatching(style) {
            this.inlineStyleQueue.push(style);
        }
        matchVariablesAndDependents() {
            if (
                this.rulesQueue.length === 0 &&
                this.inlineStyleQueue.length === 0
            ) {
                return;
            }
            this.changedTypeVars.clear();
            this.initialVarTypes = new Map(this.varTypes);
            this.collectRootVariables();
            this.collectVariablesAndVarDep();
            this.collectRootVarDependents();
            this.varRefs.forEach((refs, v) => {
                refs.forEach((r) => {
                    if (this.varTypes.has(v)) {
                        this.resolveVariableType(r, this.varTypes.get(v));
                    }
                });
            });
            this.unknownColorVars.forEach((v) => {
                if (this.unknownBgVars.has(v)) {
                    this.unknownColorVars.delete(v);
                    this.unknownBgVars.delete(v);
                    this.resolveVariableType(v, VAR_TYPE_BGCOLOR);
                } else if (
                    this.isVarType(
                        v,
                        VAR_TYPE_BGCOLOR |
                            VAR_TYPE_TEXTCOLOR |
                            VAR_TYPE_BORDERCOLOR
                    )
                ) {
                    this.unknownColorVars.delete(v);
                } else {
                    this.undefinedVars.add(v);
                }
            });
            this.unknownBgVars.forEach((v) => {
                const hasColor =
                    this.findVarRef(v, (ref) => {
                        return (
                            this.unknownColorVars.has(ref) ||
                            this.isVarType(
                                ref,
                                VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR
                            )
                        );
                    }) != null;
                if (hasColor) {
                    this.iterateVarRefs(v, (ref) => {
                        this.resolveVariableType(ref, VAR_TYPE_BGCOLOR);
                    });
                } else if (
                    this.isVarType(v, VAR_TYPE_BGCOLOR | VAR_TYPE_BGIMG)
                ) {
                    this.unknownBgVars.delete(v);
                } else {
                    this.undefinedVars.add(v);
                }
            });
            this.changedTypeVars.forEach((varName) => {
                if (this.typeChangeSubscriptions.has(varName)) {
                    this.typeChangeSubscriptions
                        .get(varName)
                        .forEach((callback) => {
                            callback();
                        });
                }
            });
            this.changedTypeVars.clear();
        }
        getModifierForVariable(options) {
            return (theme) => {
                const {
                    varName,
                    sourceValue,
                    rule,
                    ignoredImgSelectors,
                    isCancelled
                } = options;
                const getDeclarations = () => {
                    const declarations = [];
                    const addModifiedValue = (
                        typeNum,
                        varNameWrapper,
                        colorModifier
                    ) => {
                        if (!this.isVarType(varName, typeNum)) {
                            return;
                        }
                        const property = varNameWrapper(varName);
                        let modifiedValue;
                        if (isVarDependant(sourceValue)) {
                            if (isConstructedColorVar(sourceValue)) {
                                let value = insertVarValues(
                                    sourceValue,
                                    this.unstableVarValues
                                );
                                if (!value) {
                                    value =
                                        typeNum === VAR_TYPE_BGCOLOR
                                            ? "#ffffff"
                                            : "#000000";
                                }
                                modifiedValue = colorModifier(value, theme);
                            } else {
                                modifiedValue = replaceCSSVariablesNames(
                                    sourceValue,
                                    (v) => varNameWrapper(v),
                                    (fallback) => colorModifier(fallback, theme)
                                );
                            }
                        } else {
                            modifiedValue = colorModifier(sourceValue, theme);
                        }
                        declarations.push({
                            property,
                            value: modifiedValue
                        });
                    };
                    addModifiedValue(
                        VAR_TYPE_BGCOLOR,
                        wrapBgColorVariableName,
                        tryModifyBgColor
                    );
                    addModifiedValue(
                        VAR_TYPE_TEXTCOLOR,
                        wrapTextColorVariableName,
                        tryModifyTextColor
                    );
                    addModifiedValue(
                        VAR_TYPE_BORDERCOLOR,
                        wrapBorderColorVariableName,
                        tryModifyBorderColor
                    );
                    if (this.isVarType(varName, VAR_TYPE_BGIMG)) {
                        const property = wrapBgImgVariableName(varName);
                        let modifiedValue = sourceValue;
                        if (isVarDependant(sourceValue)) {
                            modifiedValue = replaceCSSVariablesNames(
                                sourceValue,
                                (v) => wrapBgColorVariableName(v),
                                (fallback) => tryModifyBgColor(fallback, theme)
                            );
                        }
                        const bgModifier = getBgImageModifier(
                            modifiedValue,
                            rule,
                            ignoredImgSelectors,
                            isCancelled
                        );
                        modifiedValue =
                            typeof bgModifier === "function"
                                ? bgModifier(theme)
                                : bgModifier;
                        declarations.push({
                            property,
                            value: modifiedValue
                        });
                    }
                    return declarations;
                };
                const callbacks = new Set();
                const addListener = (onTypeChange) => {
                    const callback = () => {
                        const decs = getDeclarations();
                        onTypeChange(decs);
                    };
                    callbacks.add(callback);
                    this.subscribeForVarTypeChange(varName, callback);
                };
                const removeListeners = () => {
                    callbacks.forEach((callback) => {
                        this.unsubscribeFromVariableTypeChanges(
                            varName,
                            callback
                        );
                    });
                };
                return {
                    declarations: getDeclarations(),
                    onTypeChange: {addListener, removeListeners}
                };
            };
        }
        getModifierForVarDependant(property, sourceValue) {
            if (sourceValue.match(/^\s*(rgb|hsl)a?\(/)) {
                const isBg = property.startsWith("background");
                const isText = isTextColorProperty(property);
                return (theme) => {
                    let value = insertVarValues(
                        sourceValue,
                        this.unstableVarValues
                    );
                    if (!value) {
                        value = isBg ? "#ffffff" : "#000000";
                    }
                    const modifier = isBg
                        ? tryModifyBgColor
                        : isText
                          ? tryModifyTextColor
                          : tryModifyBorderColor;
                    return modifier(value, theme);
                };
            }
            if (property === "background-color") {
                return (theme) => {
                    return replaceCSSVariablesNames(
                        sourceValue,
                        (v) => wrapBgColorVariableName(v),
                        (fallback) => tryModifyBgColor(fallback, theme)
                    );
                };
            }
            if (isTextColorProperty(property)) {
                return (theme) => {
                    return replaceCSSVariablesNames(
                        sourceValue,
                        (v) => wrapTextColorVariableName(v),
                        (fallback) => tryModifyTextColor(fallback, theme)
                    );
                };
            }
            if (
                property === "background" ||
                property === "background-image" ||
                property === "box-shadow"
            ) {
                return (theme) => {
                    const unknownVars = new Set();
                    const modify = () => {
                        const variableReplaced = replaceCSSVariablesNames(
                            sourceValue,
                            (v) => {
                                if (this.isVarType(v, VAR_TYPE_BGCOLOR)) {
                                    return wrapBgColorVariableName(v);
                                }
                                if (this.isVarType(v, VAR_TYPE_BGIMG)) {
                                    return wrapBgImgVariableName(v);
                                }
                                unknownVars.add(v);
                                return v;
                            },
                            (fallback) => tryModifyBgColor(fallback, theme)
                        );
                        if (property === "box-shadow") {
                            const shadowModifier =
                                getShadowModifierWithInfo(variableReplaced);
                            const modifiedShadow = shadowModifier(theme);
                            if (
                                modifiedShadow.unparseableMatchesLength !==
                                modifiedShadow.matchesLength
                            ) {
                                return modifiedShadow.result;
                            }
                        }
                        return variableReplaced;
                    };
                    const modified = modify();
                    if (unknownVars.size > 0) {
                        const isFallbackResolved = modified.match(
                            /^var\(.*?, var\(--darkreader-bg--.*\)\)$/
                        );
                        if (isFallbackResolved) {
                            return modified;
                        }
                        return new Promise((resolve) => {
                            const firstUnknownVar = unknownVars
                                .values()
                                .next().value;
                            const callback = () => {
                                this.unsubscribeFromVariableTypeChanges(
                                    firstUnknownVar,
                                    callback
                                );
                                const newValue = modify();
                                resolve(newValue);
                            };
                            this.subscribeForVarTypeChange(
                                firstUnknownVar,
                                callback
                            );
                        });
                    }
                    return modified;
                };
            }
            if (
                property.startsWith("border") ||
                property.startsWith("outline")
            ) {
                return (theme) => {
                    return replaceCSSVariablesNames(
                        sourceValue,
                        (v) => wrapBorderColorVariableName(v),
                        (fallback) => tryModifyBorderColor(fallback, theme)
                    );
                };
            }
            return null;
        }
        subscribeForVarTypeChange(varName, callback) {
            if (!this.typeChangeSubscriptions.has(varName)) {
                this.typeChangeSubscriptions.set(varName, new Set());
            }
            const rootStore = this.typeChangeSubscriptions.get(varName);
            if (!rootStore.has(callback)) {
                rootStore.add(callback);
            }
        }
        unsubscribeFromVariableTypeChanges(varName, callback) {
            if (this.typeChangeSubscriptions.has(varName)) {
                this.typeChangeSubscriptions.get(varName).delete(callback);
            }
        }
        collectVariablesAndVarDep() {
            this.rulesQueue.forEach((rules) => {
                iterateCSSRules(rules, (rule) => {
                    if (rule.style) {
                        this.collectVarsFromCSSDeclarations(rule.style);
                    }
                });
            });
            this.inlineStyleQueue.forEach((style) => {
                this.collectVarsFromCSSDeclarations(style);
            });
            this.rulesQueue.splice(0);
            this.inlineStyleQueue.splice(0);
        }
        collectVarsFromCSSDeclarations(style) {
            iterateCSSDeclarations(style, (property, value) => {
                if (isVariable(property)) {
                    this.inspectVariable(property, value);
                }
                if (isVarDependant(value)) {
                    this.inspectVarDependant(property, value);
                }
            });
        }
        shouldProcessRootVariables() {
            var _a;
            return (
                this.rulesQueue.length > 0 &&
                ((_a = document.documentElement.getAttribute("style")) ===
                    null || _a === void 0
                    ? void 0
                    : _a.includes("--"))
            );
        }
        collectRootVariables() {
            if (!this.shouldProcessRootVariables()) {
                return;
            }
            iterateCSSDeclarations(
                document.documentElement.style,
                (property, value) => {
                    if (isVariable(property)) {
                        this.inspectVariable(property, value);
                    }
                }
            );
        }
        inspectVariable(varName, value) {
            this.unstableVarValues.set(varName, value);
            if (isVarDependant(value) && isConstructedColorVar(value)) {
                this.unknownColorVars.add(varName);
                this.definedVars.add(varName);
            }
            if (this.definedVars.has(varName)) {
                return;
            }
            this.definedVars.add(varName);
            const isColor =
                rawValueRegex.test(value) || parseColorWithCache(value);
            if (isColor) {
                this.unknownColorVars.add(varName);
            } else if (
                value.includes("url(") ||
                value.includes("linear-gradient(") ||
                value.includes("radial-gradient(")
            ) {
                this.resolveVariableType(varName, VAR_TYPE_BGIMG);
            }
        }
        resolveVariableType(varName, typeNum) {
            const initialType = this.initialVarTypes.get(varName) || 0;
            const currentType = this.varTypes.get(varName) || 0;
            const newType = currentType | typeNum;
            this.varTypes.set(varName, newType);
            if (newType !== initialType || this.undefinedVars.has(varName)) {
                this.changedTypeVars.add(varName);
                this.undefinedVars.delete(varName);
            }
            this.unknownColorVars.delete(varName);
            this.unknownBgVars.delete(varName);
        }
        collectRootVarDependents() {
            if (!this.shouldProcessRootVariables()) {
                return;
            }
            iterateCSSDeclarations(
                document.documentElement.style,
                (property, value) => {
                    if (isVarDependant(value)) {
                        this.inspectVarDependant(property, value);
                    }
                }
            );
        }
        inspectVarDependant(property, value) {
            if (isVariable(property)) {
                this.iterateVarDeps(value, (ref) => {
                    if (!this.varRefs.has(property)) {
                        this.varRefs.set(property, new Set());
                    }
                    this.varRefs.get(property).add(ref);
                });
            } else if (
                property === "background-color" ||
                property === "box-shadow"
            ) {
                this.iterateVarDeps(value, (v) =>
                    this.resolveVariableType(v, VAR_TYPE_BGCOLOR)
                );
            } else if (isTextColorProperty(property)) {
                this.iterateVarDeps(value, (v) =>
                    this.resolveVariableType(v, VAR_TYPE_TEXTCOLOR)
                );
            } else if (
                property.startsWith("border") ||
                property.startsWith("outline")
            ) {
                this.iterateVarDeps(value, (v) =>
                    this.resolveVariableType(v, VAR_TYPE_BORDERCOLOR)
                );
            } else if (
                property === "background" ||
                property === "background-image"
            ) {
                this.iterateVarDeps(value, (v) => {
                    if (this.isVarType(v, VAR_TYPE_BGCOLOR | VAR_TYPE_BGIMG)) {
                        return;
                    }
                    const isBgColor =
                        this.findVarRef(v, (ref) => {
                            return (
                                this.unknownColorVars.has(ref) ||
                                this.isVarType(
                                    ref,
                                    VAR_TYPE_TEXTCOLOR | VAR_TYPE_BORDERCOLOR
                                )
                            );
                        }) != null;
                    this.iterateVarRefs(v, (ref) => {
                        if (isBgColor) {
                            this.resolveVariableType(ref, VAR_TYPE_BGCOLOR);
                        } else {
                            this.unknownBgVars.add(ref);
                        }
                    });
                });
            }
        }
        iterateVarDeps(value, iterator) {
            const varDeps = new Set();
            iterateVarDependencies(value, (v) => varDeps.add(v));
            varDeps.forEach((v) => iterator(v));
        }
        findVarRef(varName, iterator, stack = new Set()) {
            if (stack.has(varName)) {
                return null;
            }
            stack.add(varName);
            const result = iterator(varName);
            if (result) {
                return varName;
            }
            const refs = this.varRefs.get(varName);
            if (!refs || refs.size === 0) {
                return null;
            }
            for (const ref of refs) {
                const found = this.findVarRef(ref, iterator, stack);
                if (found) {
                    return found;
                }
            }
            return null;
        }
        iterateVarRefs(varName, iterator) {
            this.findVarRef(varName, (ref) => {
                iterator(ref);
                return false;
            });
        }
        setOnRootVariableChange(callback) {
            this.onRootVariableDefined = callback;
        }
        putRootVars(styleElement, theme) {
            const sheet = styleElement.sheet;
            if (sheet.cssRules.length > 0) {
                sheet.deleteRule(0);
            }
            const declarations = new Map();
            iterateCSSDeclarations(
                document.documentElement.style,
                (property, value) => {
                    if (isVariable(property)) {
                        if (this.isVarType(property, VAR_TYPE_BGCOLOR)) {
                            declarations.set(
                                wrapBgColorVariableName(property),
                                tryModifyBgColor(value, theme)
                            );
                        }
                        if (this.isVarType(property, VAR_TYPE_TEXTCOLOR)) {
                            declarations.set(
                                wrapTextColorVariableName(property),
                                tryModifyTextColor(value, theme)
                            );
                        }
                        if (this.isVarType(property, VAR_TYPE_BORDERCOLOR)) {
                            declarations.set(
                                wrapBorderColorVariableName(property),
                                tryModifyBorderColor(value, theme)
                            );
                        }
                        this.subscribeForVarTypeChange(
                            property,
                            this.onRootVariableDefined
                        );
                    }
                }
            );
            const cssLines = [];
            cssLines.push(":root {");
            for (const [property, value] of declarations) {
                cssLines.push(`    ${property}: ${value};`);
            }
            cssLines.push("}");
            const cssText = cssLines.join("\n");
            sheet.insertRule(cssText);
        }
    }
    const variablesStore = new VariablesStore();
    function getVariableRange(input, searchStart = 0) {
        const start = input.indexOf("var(", searchStart);
        if (start >= 0) {
            const range = getParenthesesRange(input, start + 3);
            if (range) {
                return {start, end: range.end};
            }
        }
        return null;
    }
    function getVariablesMatches(input) {
        const ranges = [];
        let i = 0;
        let range;
        while ((range = getVariableRange(input, i))) {
            const {start, end} = range;
            ranges.push({start, end, value: input.substring(start, end)});
            i = range.end + 1;
        }
        return ranges;
    }
    function replaceVariablesMatches(input, replacer) {
        const matches = getVariablesMatches(input);
        const matchesCount = matches.length;
        if (matchesCount === 0) {
            return input;
        }
        const inputLength = input.length;
        const replacements = matches.map((m) => replacer(m.value));
        const parts = [];
        parts.push(input.substring(0, matches[0].start));
        for (let i = 0; i < matchesCount; i++) {
            parts.push(replacements[i]);
            const start = matches[i].end;
            const end =
                i < matchesCount - 1 ? matches[i + 1].start : inputLength;
            parts.push(input.substring(start, end));
        }
        return parts.join("");
    }
    function getVariableNameAndFallback(match) {
        const commaIndex = match.indexOf(",");
        let name;
        let fallback;
        if (commaIndex >= 0) {
            name = match.substring(4, commaIndex).trim();
            fallback = match.substring(commaIndex + 1, match.length - 1).trim();
        } else {
            name = match.substring(4, match.length - 1).trim();
            fallback = "";
        }
        return {name, fallback};
    }
    function replaceCSSVariablesNames(value, nameReplacer, fallbackReplacer) {
        const matchReplacer = (match) => {
            const {name, fallback} = getVariableNameAndFallback(match);
            const newName = nameReplacer(name);
            if (!fallback) {
                return `var(${newName})`;
            }
            let newFallback;
            if (isVarDependant(fallback)) {
                newFallback = replaceCSSVariablesNames(
                    fallback,
                    nameReplacer,
                    fallbackReplacer
                );
            } else if (fallbackReplacer) {
                newFallback = fallbackReplacer(fallback);
            } else {
                newFallback = fallback;
            }
            return `var(${newName}, ${newFallback})`;
        };
        return replaceVariablesMatches(value, matchReplacer);
    }
    function iterateVarDependencies(value, iterator) {
        replaceCSSVariablesNames(value, (varName) => {
            iterator(varName);
            return varName;
        });
    }
    function wrapBgColorVariableName(name) {
        return `--darkreader-bg${name}`;
    }
    function wrapTextColorVariableName(name) {
        return `--darkreader-text${name}`;
    }
    function wrapBorderColorVariableName(name) {
        return `--darkreader-border${name}`;
    }
    function wrapBgImgVariableName(name) {
        return `--darkreader-bgimg${name}`;
    }
    function isVariable(property) {
        return property.startsWith("--");
    }
    function isVarDependant(value) {
        return value.includes("var(");
    }
    function isConstructedColorVar(value) {
        return value.match(/^\s*(rgb|hsl)a?\(/);
    }
    function isTextColorProperty(property) {
        return (
            property === "color" ||
            property === "caret-color" ||
            property === "-webkit-text-fill-color"
        );
    }
    const rawValueRegex = /^\d{1,3}, ?\d{1,3}, ?\d{1,3}$/;
    function parseRawValue(color) {
        if (rawValueRegex.test(color)) {
            const splitted = color.split(",");
            let resultInRGB = "rgb(";
            splitted.forEach((number) => {
                resultInRGB += `${number.trim()}, `;
            });
            resultInRGB = resultInRGB.substring(0, resultInRGB.length - 2);
            resultInRGB += ")";
            return {isRaw: true, color: resultInRGB};
        }
        return {isRaw: false, color: color};
    }
    function handleRawValue(color, theme, modifyFunction) {
        const {isRaw, color: newColor} = parseRawValue(color);
        const rgb = parseColorWithCache(newColor);
        if (rgb) {
            const outputColor = modifyFunction(rgb, theme);
            if (isRaw) {
                const outputInRGB = parseColorWithCache(outputColor);
                return outputInRGB
                    ? `${outputInRGB.r}, ${outputInRGB.g}, ${outputInRGB.b}`
                    : outputColor;
            }
            return outputColor;
        }
        return newColor;
    }
    function tryModifyBgColor(color, theme) {
        return handleRawValue(color, theme, modifyBackgroundColor);
    }
    function tryModifyTextColor(color, theme) {
        return handleRawValue(color, theme, modifyForegroundColor);
    }
    function tryModifyBorderColor(color, theme) {
        return handleRawValue(color, theme, modifyBorderColor);
    }
    function insertVarValues(source, varValues, stack = new Set()) {
        let containsUnresolvedVar = false;
        const matchReplacer = (match) => {
            const {name, fallback} = getVariableNameAndFallback(match);
            if (stack.has(name)) {
                containsUnresolvedVar = true;
                return null;
            }
            stack.add(name);
            const varValue = varValues.get(name) || fallback;
            let inserted = null;
            if (varValue) {
                if (isVarDependant(varValue)) {
                    inserted = insertVarValues(varValue, varValues, stack);
                } else {
                    inserted = varValue;
                }
            }
            if (!inserted) {
                containsUnresolvedVar = true;
                return null;
            }
            return inserted;
        };
        const replaced = replaceVariablesMatches(source, matchReplacer);
        if (containsUnresolvedVar) {
            return null;
        }
        return replaced;
    }

    const overrides$1 = {
        "background-color": {
            customProp: "--darkreader-inline-bgcolor",
            cssProp: "background-color",
            dataAttr: "data-darkreader-inline-bgcolor"
        },
        "background-image": {
            customProp: "--darkreader-inline-bgimage",
            cssProp: "background-image",
            dataAttr: "data-darkreader-inline-bgimage"
        },
        "border-color": {
            customProp: "--darkreader-inline-border",
            cssProp: "border-color",
            dataAttr: "data-darkreader-inline-border"
        },
        "border-bottom-color": {
            customProp: "--darkreader-inline-border-bottom",
            cssProp: "border-bottom-color",
            dataAttr: "data-darkreader-inline-border-bottom"
        },
        "border-left-color": {
            customProp: "--darkreader-inline-border-left",
            cssProp: "border-left-color",
            dataAttr: "data-darkreader-inline-border-left"
        },
        "border-right-color": {
            customProp: "--darkreader-inline-border-right",
            cssProp: "border-right-color",
            dataAttr: "data-darkreader-inline-border-right"
        },
        "border-top-color": {
            customProp: "--darkreader-inline-border-top",
            cssProp: "border-top-color",
            dataAttr: "data-darkreader-inline-border-top"
        },
        "box-shadow": {
            customProp: "--darkreader-inline-boxshadow",
            cssProp: "box-shadow",
            dataAttr: "data-darkreader-inline-boxshadow"
        },
        "color": {
            customProp: "--darkreader-inline-color",
            cssProp: "color",
            dataAttr: "data-darkreader-inline-color"
        },
        "fill": {
            customProp: "--darkreader-inline-fill",
            cssProp: "fill",
            dataAttr: "data-darkreader-inline-fill"
        },
        "stroke": {
            customProp: "--darkreader-inline-stroke",
            cssProp: "stroke",
            dataAttr: "data-darkreader-inline-stroke"
        },
        "outline-color": {
            customProp: "--darkreader-inline-outline",
            cssProp: "outline-color",
            dataAttr: "data-darkreader-inline-outline"
        },
        "stop-color": {
            customProp: "--darkreader-inline-stopcolor",
            cssProp: "stop-color",
            dataAttr: "data-darkreader-inline-stopcolor"
        }
    };
    const shorthandOverrides = {
        background: {
            customProp: "--darkreader-inline-bg",
            cssProp: "background",
            dataAttr: "data-darkreader-inline-bg"
        }
    };
    const overridesList = Object.values(overrides$1);
    const normalizedPropList = {};
    overridesList.forEach(
        ({cssProp, customProp}) => (normalizedPropList[customProp] = cssProp)
    );
    const INLINE_STYLE_ATTRS = [
        "style",
        "fill",
        "stop-color",
        "stroke",
        "bgcolor",
        "color"
    ];
    const INLINE_STYLE_SELECTOR = INLINE_STYLE_ATTRS.map(
        (attr) => `[${attr}]`
    ).join(", ");
    function getInlineOverrideStyle() {
        const allOverrides = overridesList.concat(
            Object.values(shorthandOverrides)
        );
        return allOverrides
            .map(({dataAttr, customProp, cssProp}) => {
                return [
                    `[${dataAttr}] {`,
                    `  ${cssProp}: var(${customProp}) !important;`,
                    "}"
                ].join("\n");
            })
            .join("\n");
    }
    function getInlineStyleElements(root) {
        const results = [];
        if (root instanceof Element && root.matches(INLINE_STYLE_SELECTOR)) {
            results.push(root);
        }
        if (
            root instanceof Element ||
            (isShadowDomSupported && root instanceof ShadowRoot) ||
            root instanceof Document
        ) {
            push(results, root.querySelectorAll(INLINE_STYLE_SELECTOR));
        }
        return results;
    }
    const treeObservers = new Map();
    const attrObservers = new Map();
    function watchForInlineStyles(elementStyleDidChange, shadowRootDiscovered) {
        deepWatchForInlineStyles(
            document,
            elementStyleDidChange,
            shadowRootDiscovered
        );
        iterateShadowHosts(document.documentElement, (host) => {
            deepWatchForInlineStyles(
                host.shadowRoot,
                elementStyleDidChange,
                shadowRootDiscovered
            );
        });
    }
    function deepWatchForInlineStyles(
        root,
        elementStyleDidChange,
        shadowRootDiscovered
    ) {
        if (treeObservers.has(root)) {
            treeObservers.get(root).disconnect();
            attrObservers.get(root).disconnect();
        }
        const discoveredNodes = new WeakSet();
        function discoverNodes(node) {
            getInlineStyleElements(node).forEach((el) => {
                if (discoveredNodes.has(el)) {
                    return;
                }
                discoveredNodes.add(el);
                elementStyleDidChange(el);
            });
            iterateShadowHosts(node, (n) => {
                if (discoveredNodes.has(node)) {
                    return;
                }
                discoveredNodes.add(node);
                shadowRootDiscovered(n.shadowRoot);
                deepWatchForInlineStyles(
                    n.shadowRoot,
                    elementStyleDidChange,
                    shadowRootDiscovered
                );
            });
            variablesStore.matchVariablesAndDependents();
        }
        const treeObserver = createOptimizedTreeObserver(root, {
            onMinorMutations: ({additions}) => {
                additions.forEach((added) => discoverNodes(added));
            },
            onHugeMutations: () => {
                discoverNodes(root);
            }
        });
        treeObservers.set(root, treeObserver);
        let attemptCount = 0;
        let start = null;
        const ATTEMPTS_INTERVAL = getDuration({seconds: 10});
        const RETRY_TIMEOUT = getDuration({seconds: 2});
        const MAX_ATTEMPTS_COUNT = 50;
        let cache = [];
        let timeoutId = null;
        const handleAttributeMutations = throttle((mutations) => {
            const handledTargets = new Set();
            mutations.forEach((m) => {
                const target = m.target;
                if (handledTargets.has(target)) {
                    return;
                }
                if (INLINE_STYLE_ATTRS.includes(m.attributeName)) {
                    handledTargets.add(target);
                    elementStyleDidChange(target);
                }
            });
            variablesStore.matchVariablesAndDependents();
        });
        const attrObserver = new MutationObserver((mutations) => {
            if (timeoutId) {
                cache.push(...mutations);
                return;
            }
            attemptCount++;
            const now = Date.now();
            if (start == null) {
                start = now;
            } else if (attemptCount >= MAX_ATTEMPTS_COUNT) {
                if (now - start < ATTEMPTS_INTERVAL) {
                    timeoutId = setTimeout(() => {
                        start = null;
                        attemptCount = 0;
                        timeoutId = null;
                        const attributeCache = cache;
                        cache = [];
                        handleAttributeMutations(attributeCache);
                    }, RETRY_TIMEOUT);
                    cache.push(...mutations);
                    return;
                }
                start = now;
                attemptCount = 1;
            }
            handleAttributeMutations(mutations);
        });
        attrObserver.observe(root, {
            attributes: true,
            attributeFilter: INLINE_STYLE_ATTRS.concat(
                overridesList.map(({dataAttr}) => dataAttr)
            ),
            subtree: true
        });
        attrObservers.set(root, attrObserver);
    }
    function stopWatchingForInlineStyles() {
        treeObservers.forEach((o) => o.disconnect());
        attrObservers.forEach((o) => o.disconnect());
        treeObservers.clear();
        attrObservers.clear();
    }
    const inlineStyleCache = new WeakMap();
    const filterProps = [
        "brightness",
        "contrast",
        "grayscale",
        "sepia",
        "mode"
    ];
    function getInlineStyleCacheKey(el, theme) {
        return INLINE_STYLE_ATTRS.map(
            (attr) => `${attr}="${el.getAttribute(attr)}"`
        )
            .concat(filterProps.map((prop) => `${prop}="${theme[prop]}"`))
            .join(" ");
    }
    function shouldIgnoreInlineStyle(element, selectors) {
        for (let i = 0, len = selectors.length; i < len; i++) {
            const ingnoredSelector = selectors[i];
            if (element.matches(ingnoredSelector)) {
                return true;
            }
        }
        return false;
    }
    function overrideInlineStyle(
        element,
        theme,
        ignoreInlineSelectors,
        ignoreImageSelectors
    ) {
        var _a;
        const cacheKey = getInlineStyleCacheKey(element, theme);
        if (cacheKey === inlineStyleCache.get(element)) {
            return;
        }
        const unsetProps = new Set(Object.keys(overrides$1));
        function setCustomProp(targetCSSProp, modifierCSSProp, cssVal) {
            const mod = getModifiableCSSDeclaration(
                modifierCSSProp,
                cssVal,
                {style: element.style},
                variablesStore,
                ignoreImageSelectors,
                null
            );
            if (!mod) {
                return;
            }
            function setStaticValue(value) {
                var _a;
                const {customProp, dataAttr} =
                    (_a = overrides$1[targetCSSProp]) !== null && _a !== void 0
                        ? _a
                        : shorthandOverrides[targetCSSProp];
                element.style.setProperty(customProp, value);
                if (!element.hasAttribute(dataAttr)) {
                    element.setAttribute(dataAttr, "");
                }
                unsetProps.delete(targetCSSProp);
            }
            function setVarDeclaration(mod) {
                let prevDeclarations = [];
                function setProps(declarations) {
                    prevDeclarations.forEach(({property}) => {
                        element.style.removeProperty(property);
                    });
                    declarations.forEach(({property, value}) => {
                        if (!(value instanceof Promise)) {
                            element.style.setProperty(property, value);
                        }
                    });
                    prevDeclarations = declarations;
                }
                setProps(mod.declarations);
                mod.onTypeChange.addListener(setProps);
            }
            function setAsyncValue(promise) {
                promise.then((value) => {
                    if (
                        value &&
                        targetCSSProp === "background" &&
                        value.startsWith("var(--darkreader-bg--")
                    ) {
                        setStaticValue(value);
                    }
                });
            }
            const value =
                typeof mod.value === "function" ? mod.value(theme) : mod.value;
            if (typeof value === "string") {
                setStaticValue(value);
            } else if (value instanceof Promise) {
                setAsyncValue(value);
            } else if (typeof value === "object") {
                setVarDeclaration(value);
            }
        }
        if (ignoreInlineSelectors.length > 0) {
            if (shouldIgnoreInlineStyle(element, ignoreInlineSelectors)) {
                unsetProps.forEach((cssProp) => {
                    element.removeAttribute(overrides$1[cssProp].dataAttr);
                });
                return;
            }
        }
        if (element.hasAttribute("bgcolor")) {
            let value = element.getAttribute("bgcolor");
            if (
                value.match(/^[0-9a-f]{3}$/i) ||
                value.match(/^[0-9a-f]{6}$/i)
            ) {
                value = `#${value}`;
            }
            setCustomProp("background-color", "background-color", value);
        }
        if (element.hasAttribute("color") && element.rel !== "mask-icon") {
            let value = element.getAttribute("color");
            if (
                value.match(/^[0-9a-f]{3}$/i) ||
                value.match(/^[0-9a-f]{6}$/i)
            ) {
                value = `#${value}`;
            }
            setCustomProp("color", "color", value);
        }
        if (element instanceof SVGElement) {
            if (element.hasAttribute("fill")) {
                const SMALL_SVG_LIMIT = 32;
                const value = element.getAttribute("fill");
                if (value !== "none") {
                    if (!(element instanceof SVGTextElement)) {
                        const handleSVGElement = () => {
                            const {width, height} =
                                element.getBoundingClientRect();
                            const isBg =
                                width > SMALL_SVG_LIMIT ||
                                height > SMALL_SVG_LIMIT;
                            setCustomProp(
                                "fill",
                                isBg ? "background-color" : "color",
                                value
                            );
                        };
                        if (isReadyStateComplete()) {
                            handleSVGElement();
                        } else {
                            addReadyStateCompleteListener(handleSVGElement);
                        }
                    } else {
                        setCustomProp("fill", "color", value);
                    }
                }
            }
            if (element.hasAttribute("stop-color")) {
                setCustomProp(
                    "stop-color",
                    "background-color",
                    element.getAttribute("stop-color")
                );
            }
        }
        if (element.hasAttribute("stroke")) {
            const value = element.getAttribute("stroke");
            setCustomProp(
                "stroke",
                element instanceof SVGLineElement ||
                    element instanceof SVGTextElement
                    ? "border-color"
                    : "color",
                value
            );
        }
        element.style &&
            iterateCSSDeclarations(element.style, (property, value) => {
                if (property === "background-image" && value.includes("url")) {
                    return;
                }
                if (
                    overrides$1.hasOwnProperty(property) ||
                    (property.startsWith("--") && !normalizedPropList[property])
                ) {
                    setCustomProp(property, property, value);
                } else if (
                    property === "background" &&
                    value.includes("var(")
                ) {
                    setCustomProp("background", "background", value);
                } else {
                    const overriddenProp = normalizedPropList[property];
                    if (
                        overriddenProp &&
                        !element.style.getPropertyValue(overriddenProp) &&
                        !element.hasAttribute(overriddenProp)
                    ) {
                        if (
                            overriddenProp === "background-color" &&
                            element.hasAttribute("bgcolor")
                        ) {
                            return;
                        }
                        element.style.setProperty(property, "");
                    }
                }
            });
        if (
            element.style &&
            element instanceof SVGTextElement &&
            element.style.fill
        ) {
            setCustomProp(
                "fill",
                "color",
                element.style.getPropertyValue("fill")
            );
        }
        if (
            (_a = element.getAttribute("style")) === null || _a === void 0
                ? void 0
                : _a.includes("--")
        ) {
            variablesStore.addInlineStyleForMatching(element.style);
        }
        forEach(unsetProps, (cssProp) => {
            element.removeAttribute(overrides$1[cssProp].dataAttr);
        });
        inlineStyleCache.set(element, getInlineStyleCacheKey(element, theme));
    }

    const metaThemeColorName = "theme-color";
    const metaThemeColorSelector = `meta[name="${metaThemeColorName}"]`;
    let srcMetaThemeColor = null;
    let observer = null;
    function changeMetaThemeColor(meta, theme) {
        srcMetaThemeColor = srcMetaThemeColor || meta.content;
        const color = parseColorWithCache(srcMetaThemeColor);
        if (!color) {
            return;
        }
        meta.content = modifyBackgroundColor(color, theme);
    }
    function changeMetaThemeColorWhenAvailable(theme) {
        const meta = document.querySelector(metaThemeColorSelector);
        if (meta) {
            changeMetaThemeColor(meta, theme);
        } else {
            if (observer) {
                observer.disconnect();
            }
            observer = new MutationObserver((mutations) => {
                loop: for (let i = 0; i < mutations.length; i++) {
                    const {addedNodes} = mutations[i];
                    for (let j = 0; j < addedNodes.length; j++) {
                        const node = addedNodes[j];
                        if (
                            node instanceof HTMLMetaElement &&
                            node.name === metaThemeColorName
                        ) {
                            observer.disconnect();
                            observer = null;
                            changeMetaThemeColor(node, theme);
                            break loop;
                        }
                    }
                }
            });
            observer.observe(document.head, {childList: true});
        }
    }
    function restoreMetaThemeColor() {
        if (observer) {
            observer.disconnect();
            observer = null;
        }
        const meta = document.querySelector(metaThemeColorSelector);
        if (meta && srcMetaThemeColor) {
            meta.content = srcMetaThemeColor;
        }
    }

    const themeCacheKeys = [
        "mode",
        "brightness",
        "contrast",
        "grayscale",
        "sepia",
        "darkSchemeBackgroundColor",
        "darkSchemeTextColor",
        "lightSchemeBackgroundColor",
        "lightSchemeTextColor"
    ];
    function getThemeKey(theme) {
        let resultKey = "";
        themeCacheKeys.forEach((key) => {
            resultKey += `${key}:${theme[key]};`;
        });
        return resultKey;
    }
    const asyncQueue = createAsyncTasksQueue();
    function createStyleSheetModifier() {
        let renderId = 0;
        const rulesTextCache = new Set();
        const rulesModCache = new Map();
        const varTypeChangeCleaners = new Set();
        let prevFilterKey = null;
        let hasNonLoadedLink = false;
        let wasRebuilt = false;
        function shouldRebuildStyle() {
            return hasNonLoadedLink && !wasRebuilt;
        }
        function modifySheet(options) {
            const rules = options.sourceCSSRules;
            const {
                theme,
                ignoreImageAnalysis,
                force,
                prepareSheet,
                isAsyncCancelled
            } = options;
            let rulesChanged = rulesModCache.size === 0;
            const notFoundCacheKeys = new Set(rulesModCache.keys());
            const themeKey = getThemeKey(theme);
            const themeChanged = themeKey !== prevFilterKey;
            if (hasNonLoadedLink) {
                wasRebuilt = true;
            }
            const modRules = [];
            iterateCSSRules(
                rules,
                (rule) => {
                    let cssText = rule.cssText;
                    let textDiffersFromPrev = false;
                    notFoundCacheKeys.delete(cssText);
                    if (rule.parentRule instanceof CSSMediaRule) {
                        cssText += `;${rule.parentRule.media.mediaText}`;
                    }
                    if (!rulesTextCache.has(cssText)) {
                        rulesTextCache.add(cssText);
                        textDiffersFromPrev = true;
                    }
                    if (textDiffersFromPrev) {
                        rulesChanged = true;
                    } else {
                        modRules.push(rulesModCache.get(cssText));
                        return;
                    }
                    if (rule.style.all === "revert") {
                        return;
                    }
                    const modDecs = [];
                    rule.style &&
                        iterateCSSDeclarations(
                            rule.style,
                            (property, value) => {
                                const mod = getModifiableCSSDeclaration(
                                    property,
                                    value,
                                    rule,
                                    variablesStore,
                                    ignoreImageAnalysis,
                                    isAsyncCancelled
                                );
                                if (mod) {
                                    modDecs.push(mod);
                                }
                            }
                        );
                    let modRule = null;
                    if (modDecs.length > 0) {
                        const parentRule = rule.parentRule;
                        modRule = {
                            selector: rule.selectorText,
                            declarations: modDecs,
                            parentRule
                        };
                        modRules.push(modRule);
                    }
                    rulesModCache.set(cssText, modRule);
                },
                () => {
                    hasNonLoadedLink = true;
                }
            );
            notFoundCacheKeys.forEach((key) => {
                rulesTextCache.delete(key);
                rulesModCache.delete(key);
            });
            prevFilterKey = themeKey;
            if (!force && !rulesChanged && !themeChanged) {
                return;
            }
            renderId++;
            function setRule(target, index, rule) {
                const {selector, declarations} = rule;
                let selectorText = selector;
                if (
                    selector.startsWith(":is(") &&
                    (selector.includes(":is()") ||
                        selector.includes(":where()") ||
                        (selector.includes(":where(") &&
                            selector.includes(":-moz")))
                ) {
                    selectorText = ".darkreader-unsupported-selector";
                }
                let ruleText = `${selectorText} {`;
                for (const dec of declarations) {
                    const {property, value, important} = dec;
                    if (value) {
                        ruleText += ` ${property}: ${value}${
                            important ? " !important" : ""
                        };`;
                    }
                }
                ruleText += " }";
                target.insertRule(ruleText, index);
            }
            const asyncDeclarations = new Map();
            const varDeclarations = new Map();
            let asyncDeclarationCounter = 0;
            let varDeclarationCounter = 0;
            const rootReadyGroup = {rule: null, rules: [], isGroup: true};
            const groupRefs = new WeakMap();
            function getGroup(rule) {
                if (rule == null) {
                    return rootReadyGroup;
                }
                if (groupRefs.has(rule)) {
                    return groupRefs.get(rule);
                }
                const group = {rule, rules: [], isGroup: true};
                groupRefs.set(rule, group);
                const parentGroup = getGroup(rule.parentRule);
                parentGroup.rules.push(group);
                return group;
            }
            varTypeChangeCleaners.forEach((clear) => clear());
            varTypeChangeCleaners.clear();
            modRules
                .filter((r) => r)
                .forEach(({selector, declarations, parentRule}) => {
                    const group = getGroup(parentRule);
                    const readyStyleRule = {
                        selector,
                        declarations: [],
                        isGroup: false
                    };
                    const readyDeclarations = readyStyleRule.declarations;
                    group.rules.push(readyStyleRule);
                    function handleAsyncDeclaration(
                        property,
                        modified,
                        important,
                        sourceValue
                    ) {
                        const asyncKey = ++asyncDeclarationCounter;
                        const asyncDeclaration = {
                            property,
                            value: null,
                            important,
                            asyncKey,
                            sourceValue
                        };
                        readyDeclarations.push(asyncDeclaration);
                        const currentRenderId = renderId;
                        modified.then((asyncValue) => {
                            if (
                                !asyncValue ||
                                isAsyncCancelled() ||
                                currentRenderId !== renderId
                            ) {
                                return;
                            }
                            asyncDeclaration.value = asyncValue;
                            asyncQueue.add(() => {
                                if (
                                    isAsyncCancelled() ||
                                    currentRenderId !== renderId
                                ) {
                                    return;
                                }
                                rebuildAsyncRule(asyncKey);
                            });
                        });
                    }
                    function handleVarDeclarations(
                        property,
                        modified,
                        important,
                        sourceValue
                    ) {
                        const {declarations: varDecs, onTypeChange} = modified;
                        const varKey = ++varDeclarationCounter;
                        const currentRenderId = renderId;
                        const initialIndex = readyDeclarations.length;
                        let oldDecs = [];
                        if (varDecs.length === 0) {
                            const tempDec = {
                                property,
                                value: sourceValue,
                                important,
                                sourceValue,
                                varKey
                            };
                            readyDeclarations.push(tempDec);
                            oldDecs = [tempDec];
                        }
                        varDecs.forEach((mod) => {
                            if (mod.value instanceof Promise) {
                                handleAsyncDeclaration(
                                    mod.property,
                                    mod.value,
                                    important,
                                    sourceValue
                                );
                            } else {
                                const readyDec = {
                                    property: mod.property,
                                    value: mod.value,
                                    important,
                                    sourceValue,
                                    varKey
                                };
                                readyDeclarations.push(readyDec);
                                oldDecs.push(readyDec);
                            }
                        });
                        onTypeChange.addListener((newDecs) => {
                            if (
                                isAsyncCancelled() ||
                                currentRenderId !== renderId
                            ) {
                                return;
                            }
                            const readyVarDecs = newDecs.map((mod) => {
                                return {
                                    property: mod.property,
                                    value: mod.value,
                                    important,
                                    sourceValue,
                                    varKey
                                };
                            });
                            const index = readyDeclarations.indexOf(
                                oldDecs[0],
                                initialIndex
                            );
                            readyDeclarations.splice(
                                index,
                                oldDecs.length,
                                ...readyVarDecs
                            );
                            oldDecs = readyVarDecs;
                            rebuildVarRule(varKey);
                        });
                        varTypeChangeCleaners.add(() =>
                            onTypeChange.removeListeners()
                        );
                    }
                    declarations.forEach(
                        ({property, value, important, sourceValue}) => {
                            if (typeof value === "function") {
                                const modified = value(theme);
                                if (modified instanceof Promise) {
                                    handleAsyncDeclaration(
                                        property,
                                        modified,
                                        important,
                                        sourceValue
                                    );
                                } else if (property.startsWith("--")) {
                                    handleVarDeclarations(
                                        property,
                                        modified,
                                        important,
                                        sourceValue
                                    );
                                } else {
                                    readyDeclarations.push({
                                        property,
                                        value: modified,
                                        important,
                                        sourceValue
                                    });
                                }
                            } else {
                                readyDeclarations.push({
                                    property,
                                    value,
                                    important,
                                    sourceValue
                                });
                            }
                        }
                    );
                });
            const sheet = prepareSheet();
            function buildStyleSheet() {
                function createTarget(group, parent) {
                    const {rule} = group;
                    if (rule instanceof CSSMediaRule) {
                        const {media} = rule;
                        const index = parent.cssRules.length;
                        parent.insertRule(
                            `@media ${media.mediaText} {}`,
                            index
                        );
                        return parent.cssRules[index];
                    }
                    return parent;
                }
                function iterateReadyRules(group, target, styleIterator) {
                    group.rules.forEach((r) => {
                        if (r.isGroup) {
                            const t = createTarget(r, target);
                            iterateReadyRules(r, t, styleIterator);
                        } else {
                            styleIterator(r, target);
                        }
                    });
                }
                iterateReadyRules(rootReadyGroup, sheet, (rule, target) => {
                    const index = target.cssRules.length;
                    rule.declarations.forEach(({asyncKey, varKey}) => {
                        if (asyncKey != null) {
                            asyncDeclarations.set(asyncKey, {
                                rule,
                                target,
                                index
                            });
                        }
                        if (varKey != null) {
                            varDeclarations.set(varKey, {rule, target, index});
                        }
                    });
                    setRule(target, index, rule);
                });
            }
            function rebuildAsyncRule(key) {
                const {rule, target, index} = asyncDeclarations.get(key);
                target.deleteRule(index);
                setRule(target, index, rule);
                asyncDeclarations.delete(key);
            }
            function rebuildVarRule(key) {
                const {rule, target, index} = varDeclarations.get(key);
                target.deleteRule(index);
                setRule(target, index, rule);
            }
            buildStyleSheet();
        }
        return {modifySheet, shouldRebuildStyle};
    }

    const STYLE_SELECTOR = 'style, link[rel*="stylesheet" i]:not([disabled])';
    function isFontsGoogleApiStyle(element) {
        if (!element.href) {
            return false;
        }
        try {
            const elementURL = new URL(element.href);
            return elementURL.hostname === "fonts.googleapis.com";
        } catch (err) {
            logInfo(`Couldn't construct ${element.href} as URL`);
            return false;
        }
    }
    const hostsBreakingOnSVGStyleOverride = ["www.onet.pl"];
    function shouldManageStyle(element) {
        return (
            (element instanceof HTMLStyleElement ||
                (element instanceof SVGStyleElement &&
                    !hostsBreakingOnSVGStyleOverride.includes(
                        location.hostname
                    )) ||
                (element instanceof HTMLLinkElement &&
                    Boolean(element.rel) &&
                    element.rel.toLowerCase().includes("stylesheet") &&
                    Boolean(element.href) &&
                    !element.disabled &&
                    true &&
                    !isFontsGoogleApiStyle(element))) &&
            !element.classList.contains("darkreader") &&
            element.media.toLowerCase() !== "print" &&
            !element.classList.contains("stylus")
        );
    }
    function getManageableStyles(node, results = [], deep = true) {
        if (shouldManageStyle(node)) {
            results.push(node);
        } else if (
            node instanceof Element ||
            (isShadowDomSupported && node instanceof ShadowRoot) ||
            node === document
        ) {
            forEach(node.querySelectorAll(STYLE_SELECTOR), (style) =>
                getManageableStyles(style, results, false)
            );
            if (deep) {
                iterateShadowHosts(node, (host) =>
                    getManageableStyles(host.shadowRoot, results, false)
                );
            }
        }
        return results;
    }
    const syncStyleSet = new WeakSet();
    const corsStyleSet = new WeakSet();
    let canOptimizeUsingProxy$1 = false;
    document.addEventListener(
        "__darkreader__inlineScriptsAllowed",
        () => {
            canOptimizeUsingProxy$1 = true;
        },
        {once: true, passive: true}
    );
    let loadingLinkCounter = 0;
    const rejectorsForLoadingLinks = new Map();
    function cleanLoadingLinks() {
        rejectorsForLoadingLinks.clear();
    }
    function manageStyle(element, {update, loadingStart, loadingEnd}) {
        const prevStyles = [];
        let next = element;
        while (
            (next = next.nextElementSibling) &&
            next.matches(".darkreader")
        ) {
            prevStyles.push(next);
        }
        let corsCopy =
            prevStyles.find(
                (el) => el.matches(".darkreader--cors") && !corsStyleSet.has(el)
            ) || null;
        let syncStyle =
            prevStyles.find(
                (el) => el.matches(".darkreader--sync") && !syncStyleSet.has(el)
            ) || null;
        let corsCopyPositionWatcher = null;
        let syncStylePositionWatcher = null;
        let cancelAsyncOperations = false;
        let isOverrideEmpty = true;
        const sheetModifier = createStyleSheetModifier();
        const observer = new MutationObserver(() => {
            update();
        });
        const observerOptions = {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
        };
        function containsCSSImport() {
            var _a;
            if (!(element instanceof HTMLStyleElement)) {
                return false;
            }
            const cssText = removeCSSComments(
                (_a = element.textContent) !== null && _a !== void 0 ? _a : ""
            ).trim();
            return cssText.match(cssImportRegex);
        }
        function hasImports(cssRules, checkCrossOrigin) {
            let result = false;
            if (cssRules) {
                let rule;
                cssRulesLoop: for (
                    let i = 0, len = cssRules.length;
                    i < len;
                    i++
                ) {
                    rule = cssRules[i];
                    if (rule.href) {
                        if (checkCrossOrigin) {
                            if (
                                !rule.href.startsWith(
                                    "https://fonts.googleapis.com/"
                                ) &&
                                rule.href.startsWith("http") &&
                                !rule.href.startsWith(location.origin)
                            ) {
                                result = true;
                                break cssRulesLoop;
                            }
                        } else {
                            result = true;
                            break cssRulesLoop;
                        }
                    }
                }
            }
            return result;
        }
        function getRulesSync() {
            if (corsCopy) {
                return corsCopy.sheet.cssRules;
            }
            if (containsCSSImport()) {
                return null;
            }
            const cssRules = safeGetSheetRules();
            if (
                element instanceof HTMLLinkElement &&
                !isRelativeHrefOnAbsolutePath(element.href) &&
                hasImports(cssRules, false)
            ) {
                return null;
            }
            if (hasImports(cssRules, true)) {
                return null;
            }
            return cssRules;
        }
        function insertStyle() {
            if (corsCopy) {
                if (element.nextSibling !== corsCopy) {
                    element.parentNode.insertBefore(
                        corsCopy,
                        element.nextSibling
                    );
                }
                if (corsCopy.nextSibling !== syncStyle) {
                    element.parentNode.insertBefore(
                        syncStyle,
                        corsCopy.nextSibling
                    );
                }
            } else if (element.nextSibling !== syncStyle) {
                element.parentNode.insertBefore(syncStyle, element.nextSibling);
            }
        }
        function createSyncStyle() {
            syncStyle =
                element instanceof SVGStyleElement
                    ? document.createElementNS(
                          "http://www.w3.org/2000/svg",
                          "style"
                      )
                    : document.createElement("style");
            syncStyle.classList.add("darkreader");
            syncStyle.classList.add("darkreader--sync");
            syncStyle.media = "screen";
            if (element.title) {
                syncStyle.title = element.title;
            }
            syncStyleSet.add(syncStyle);
        }
        let isLoadingRules = false;
        let wasLoadingError = false;
        const loadingLinkId = ++loadingLinkCounter;
        async function getRulesAsync() {
            let cssText;
            let cssBasePath;
            if (element instanceof HTMLLinkElement) {
                let [cssRules, accessError] = getRulesOrError();
                if (
                    (!cssRules && !accessError) ||
                    isStillLoadingError(accessError)
                ) {
                    try {
                        logInfo(
                            `Linkelement ${loadingLinkId} is not loaded yet and thus will be await for`,
                            element
                        );
                        await linkLoading(element, loadingLinkId);
                    } catch (err) {
                        wasLoadingError = true;
                    }
                    if (cancelAsyncOperations) {
                        return null;
                    }
                    [cssRules, accessError] = getRulesOrError();
                }
                if (cssRules) {
                    if (!hasImports(cssRules, false)) {
                        return cssRules;
                    }
                }
                cssText = await loadText(element.href);
                cssBasePath = getCSSBaseBath(element.href);
                if (cancelAsyncOperations) {
                    return null;
                }
            } else if (containsCSSImport()) {
                cssText = element.textContent.trim();
                cssBasePath = getCSSBaseBath(location.href);
            } else {
                return null;
            }
            if (cssText) {
                try {
                    const fullCSSText = await replaceCSSImports(
                        cssText,
                        cssBasePath
                    );
                    corsCopy = createCORSCopy(element, fullCSSText);
                } catch (err) {}
                if (corsCopy) {
                    corsCopyPositionWatcher = watchForNodePosition(
                        corsCopy,
                        "prev-sibling"
                    );
                    return corsCopy.sheet.cssRules;
                }
            }
            return null;
        }
        function details(options) {
            const rules = getRulesSync();
            if (!rules) {
                if (options.secondRound) {
                    return null;
                }
                if (isLoadingRules || wasLoadingError) {
                    return null;
                }
                isLoadingRules = true;
                loadingStart();
                getRulesAsync()
                    .then((results) => {
                        isLoadingRules = false;
                        loadingEnd();
                        if (results) {
                            update();
                        }
                    })
                    .catch((err) => {
                        isLoadingRules = false;
                        loadingEnd();
                    });
                return null;
            }
            return {rules};
        }
        let forceRenderStyle = false;
        function render(theme, ignoreImageAnalysis) {
            const rules = getRulesSync();
            if (!rules) {
                return;
            }
            cancelAsyncOperations = false;
            function removeCSSRulesFromSheet(sheet) {
                if (!sheet) {
                    return;
                }
                for (let i = sheet.cssRules.length - 1; i >= 0; i--) {
                    sheet.deleteRule(i);
                }
            }
            function prepareOverridesSheet() {
                if (!syncStyle) {
                    createSyncStyle();
                }
                syncStylePositionWatcher && syncStylePositionWatcher.stop();
                insertStyle();
                if (syncStyle.sheet == null) {
                    syncStyle.textContent = "";
                }
                const sheet = syncStyle.sheet;
                removeCSSRulesFromSheet(sheet);
                if (syncStylePositionWatcher) {
                    syncStylePositionWatcher.run();
                } else {
                    syncStylePositionWatcher = watchForNodePosition(
                        syncStyle,
                        "prev-sibling",
                        () => {
                            forceRenderStyle = true;
                            buildOverrides();
                        }
                    );
                }
                return syncStyle.sheet;
            }
            function buildOverrides() {
                const force = forceRenderStyle;
                forceRenderStyle = false;
                sheetModifier.modifySheet({
                    prepareSheet: prepareOverridesSheet,
                    sourceCSSRules: rules,
                    theme,
                    ignoreImageAnalysis,
                    force,
                    isAsyncCancelled: () => cancelAsyncOperations
                });
                isOverrideEmpty = syncStyle.sheet.cssRules.length === 0;
                if (sheetModifier.shouldRebuildStyle()) {
                    addReadyStateCompleteListener(() => update());
                }
            }
            buildOverrides();
        }
        function getRulesOrError() {
            try {
                if (element.sheet == null) {
                    return [null, null];
                }
                return [element.sheet.cssRules, null];
            } catch (err) {
                return [null, err];
            }
        }
        function isStillLoadingError(error) {
            return error && error.message && error.message.includes("loading");
        }
        function safeGetSheetRules() {
            const [cssRules, err] = getRulesOrError();
            if (err) {
                return null;
            }
            return cssRules;
        }
        function watchForSheetChanges() {
            watchForSheetChangesUsingProxy();
            if (!(canOptimizeUsingProxy$1 && element.sheet)) {
                watchForSheetChangesUsingRAF();
            }
        }
        let rulesChangeKey = null;
        let rulesCheckFrameId = null;
        function getRulesChangeKey() {
            const rules = safeGetSheetRules();
            return rules ? rules.length : null;
        }
        function didRulesKeyChange() {
            return getRulesChangeKey() !== rulesChangeKey;
        }
        function watchForSheetChangesUsingRAF() {
            rulesChangeKey = getRulesChangeKey();
            stopWatchingForSheetChangesUsingRAF();
            const checkForUpdate = () => {
                if (didRulesKeyChange()) {
                    rulesChangeKey = getRulesChangeKey();
                    update();
                }
                if (canOptimizeUsingProxy$1 && element.sheet) {
                    stopWatchingForSheetChangesUsingRAF();
                    return;
                }
                rulesCheckFrameId = requestAnimationFrame(checkForUpdate);
            };
            checkForUpdate();
        }
        function stopWatchingForSheetChangesUsingRAF() {
            cancelAnimationFrame(rulesCheckFrameId);
        }
        let areSheetChangesPending = false;
        function onSheetChange() {
            canOptimizeUsingProxy$1 = true;
            stopWatchingForSheetChangesUsingRAF();
            if (areSheetChangesPending) {
                return;
            }
            function handleSheetChanges() {
                areSheetChangesPending = false;
                if (cancelAsyncOperations) {
                    return;
                }
                update();
            }
            areSheetChangesPending = true;
            if (typeof queueMicrotask === "function") {
                queueMicrotask(handleSheetChanges);
            } else {
                requestAnimationFrame(handleSheetChanges);
            }
        }
        function watchForSheetChangesUsingProxy() {
            element.addEventListener(
                "__darkreader__updateSheet",
                onSheetChange,
                {passive: true}
            );
        }
        function stopWatchingForSheetChangesUsingProxy() {
            element.removeEventListener(
                "__darkreader__updateSheet",
                onSheetChange
            );
        }
        function stopWatchingForSheetChanges() {
            stopWatchingForSheetChangesUsingProxy();
            stopWatchingForSheetChangesUsingRAF();
        }
        function pause() {
            observer.disconnect();
            cancelAsyncOperations = true;
            corsCopyPositionWatcher && corsCopyPositionWatcher.stop();
            syncStylePositionWatcher && syncStylePositionWatcher.stop();
            stopWatchingForSheetChanges();
        }
        function destroy() {
            pause();
            removeNode(corsCopy);
            removeNode(syncStyle);
            loadingEnd();
            if (rejectorsForLoadingLinks.has(loadingLinkId)) {
                const reject = rejectorsForLoadingLinks.get(loadingLinkId);
                rejectorsForLoadingLinks.delete(loadingLinkId);
                reject && reject();
            }
        }
        function watch() {
            observer.observe(element, observerOptions);
            if (element instanceof HTMLStyleElement) {
                watchForSheetChanges();
            }
        }
        const maxMoveCount = 10;
        let moveCount = 0;
        function restore() {
            if (!syncStyle) {
                return;
            }
            moveCount++;
            if (moveCount > maxMoveCount) {
                return;
            }
            insertStyle();
            corsCopyPositionWatcher && corsCopyPositionWatcher.skip();
            syncStylePositionWatcher && syncStylePositionWatcher.skip();
            if (!isOverrideEmpty) {
                forceRenderStyle = true;
                update();
            }
        }
        return {
            details,
            render,
            pause,
            destroy,
            watch,
            restore
        };
    }
    async function linkLoading(link, loadingId) {
        return new Promise((resolve, reject) => {
            const cleanUp = () => {
                link.removeEventListener("load", onLoad);
                link.removeEventListener("error", onError);
                rejectorsForLoadingLinks.delete(loadingId);
            };
            const onLoad = () => {
                cleanUp();
                resolve();
            };
            const onError = () => {
                cleanUp();
                reject(
                    `Linkelement ${loadingId} couldn't be loaded. ${link.href}`
                );
            };
            rejectorsForLoadingLinks.set(loadingId, () => {
                cleanUp();
                reject();
            });
            link.addEventListener("load", onLoad, {passive: true});
            link.addEventListener("error", onError, {passive: true});
            if (!link.href) {
                onError();
            }
        });
    }
    function getCSSImportURL(importDeclaration) {
        return getCSSURLValue(
            importDeclaration
                .substring(7)
                .trim()
                .replace(/;$/, "")
                .replace(/screen$/, "")
        );
    }
    async function loadText(url) {
        if (url.startsWith("data:")) {
            return await (await fetch(url)).text();
        }
        return await bgFetch({
            url,
            responseType: "text",
            mimeType: "text/css",
            origin: window.location.origin
        });
    }
    async function replaceCSSImports(cssText, basePath, cache = new Map()) {
        cssText = removeCSSComments(cssText);
        cssText = replaceCSSFontFace(cssText);
        cssText = replaceCSSRelativeURLsWithAbsolute(cssText, basePath);
        const importMatches = getMatches(cssImportRegex, cssText);
        for (const match of importMatches) {
            const importURL = getCSSImportURL(match);
            const absoluteURL = getAbsoluteURL(basePath, importURL);
            let importedCSS;
            if (cache.has(absoluteURL)) {
                importedCSS = cache.get(absoluteURL);
            } else {
                try {
                    importedCSS = await loadText(absoluteURL);
                    cache.set(absoluteURL, importedCSS);
                    importedCSS = await replaceCSSImports(
                        importedCSS,
                        getCSSBaseBath(absoluteURL),
                        cache
                    );
                } catch (err) {
                    importedCSS = "";
                }
            }
            cssText = cssText.split(match).join(importedCSS);
        }
        cssText = cssText.trim();
        return cssText;
    }
    function createCORSCopy(srcElement, cssText) {
        if (!cssText) {
            return null;
        }
        const cors = document.createElement("style");
        cors.classList.add("darkreader");
        cors.classList.add("darkreader--cors");
        cors.media = "screen";
        cors.textContent = cssText;
        srcElement.parentNode.insertBefore(cors, srcElement.nextSibling);
        cors.sheet.disabled = true;
        corsStyleSet.add(cors);
        return cors;
    }

    const observers = [];
    let observedRoots;
    const definedCustomElements = new Set();
    const undefinedGroups = new Map();
    let elementsDefinitionCallback;
    function isCustomElement(element) {
        if (element.tagName.includes("-") || element.getAttribute("is")) {
            return true;
        }
        return false;
    }
    function recordUndefinedElement(element) {
        let tag = element.tagName.toLowerCase();
        if (!tag.includes("-")) {
            const extendedTag = element.getAttribute("is");
            if (extendedTag) {
                tag = extendedTag;
            } else {
                return;
            }
        }
        if (!undefinedGroups.has(tag)) {
            undefinedGroups.set(tag, new Set());
            customElementsWhenDefined(tag).then(() => {
                if (elementsDefinitionCallback) {
                    const elements = undefinedGroups.get(tag);
                    undefinedGroups.delete(tag);
                    elementsDefinitionCallback(Array.from(elements));
                }
            });
        }
        undefinedGroups.get(tag).add(element);
    }
    function collectUndefinedElements(root) {
        if (!isDefinedSelectorSupported) {
            return;
        }
        forEach(
            root.querySelectorAll(":not(:defined)"),
            recordUndefinedElement
        );
    }
    let canOptimizeUsingProxy = false;
    document.addEventListener(
        "__darkreader__inlineScriptsAllowed",
        () => {
            canOptimizeUsingProxy = true;
        },
        {once: true, passive: true}
    );
    const resolvers = new Map();
    function handleIsDefined(e) {
        canOptimizeUsingProxy = true;
        const tag = e.detail.tag;
        definedCustomElements.add(tag);
        if (resolvers.has(tag)) {
            const r = resolvers.get(tag);
            resolvers.delete(tag);
            r.forEach((r) => r());
        }
    }
    async function customElementsWhenDefined(tag) {
        if (definedCustomElements.has(tag)) {
            return;
        }
        return new Promise((resolve) => {
            if (
                window.customElements &&
                typeof customElements.whenDefined === "function"
            ) {
                customElements.whenDefined(tag).then(() => resolve());
            } else if (canOptimizeUsingProxy) {
                if (resolvers.has(tag)) {
                    resolvers.get(tag).push(resolve);
                } else {
                    resolvers.set(tag, [resolve]);
                }
                document.dispatchEvent(
                    new CustomEvent("__darkreader__addUndefinedResolver", {
                        detail: {tag}
                    })
                );
            } else {
                const checkIfDefined = () => {
                    const elements = undefinedGroups.get(tag);
                    if (elements && elements.size > 0) {
                        if (
                            elements.values().next().value.matches(":defined")
                        ) {
                            resolve();
                        } else {
                            requestAnimationFrame(checkIfDefined);
                        }
                    }
                };
                requestAnimationFrame(checkIfDefined);
            }
        });
    }
    function watchWhenCustomElementsDefined(callback) {
        elementsDefinitionCallback = callback;
    }
    function unsubscribeFromDefineCustomElements() {
        elementsDefinitionCallback = null;
        undefinedGroups.clear();
        document.removeEventListener(
            "__darkreader__isDefined",
            handleIsDefined
        );
    }
    function watchForStyleChanges(currentStyles, update, shadowRootDiscovered) {
        stopWatchingForStyleChanges();
        const prevStyles = new Set(currentStyles);
        const prevStyleSiblings = new WeakMap();
        const nextStyleSiblings = new WeakMap();
        function saveStylePosition(style) {
            prevStyleSiblings.set(style, style.previousElementSibling);
            nextStyleSiblings.set(style, style.nextElementSibling);
        }
        function forgetStylePosition(style) {
            prevStyleSiblings.delete(style);
            nextStyleSiblings.delete(style);
        }
        function didStylePositionChange(style) {
            return (
                style.previousElementSibling !== prevStyleSiblings.get(style) ||
                style.nextElementSibling !== nextStyleSiblings.get(style)
            );
        }
        currentStyles.forEach(saveStylePosition);
        function handleStyleOperations(operations) {
            const {createdStyles, removedStyles, movedStyles} = operations;
            createdStyles.forEach((s) => saveStylePosition(s));
            movedStyles.forEach((s) => saveStylePosition(s));
            removedStyles.forEach((s) => forgetStylePosition(s));
            createdStyles.forEach((s) => prevStyles.add(s));
            removedStyles.forEach((s) => prevStyles.delete(s));
            if (
                createdStyles.size + removedStyles.size + movedStyles.size >
0
            ) {
                update({
                    created: Array.from(createdStyles),
                    removed: Array.from(removedStyles),
                    moved: Array.from(movedStyles),
                    updated: []
                });
            }
        }
        function handleMinorTreeMutations({additions, moves, deletions}) {
            const createdStyles = new Set();
            const removedStyles = new Set();
            const movedStyles = new Set();
            additions.forEach((node) =>
                getManageableStyles(node).forEach((style) =>
                    createdStyles.add(style)
                )
            );
            deletions.forEach((node) =>
                getManageableStyles(node).forEach((style) =>
                    removedStyles.add(style)
                )
            );
            moves.forEach((node) =>
                getManageableStyles(node).forEach((style) =>
                    movedStyles.add(style)
                )
            );
            handleStyleOperations({createdStyles, removedStyles, movedStyles});
            additions.forEach((n) => {
                extendedIterateShadowHosts(n);
                collectUndefinedElements(n);
            });
            additions.forEach(
                (node) => isCustomElement(node) && recordUndefinedElement(node)
            );
        }
        function handleHugeTreeMutations(root) {
            const styles = new Set(getManageableStyles(root));
            const createdStyles = new Set();
            const removedStyles = new Set();
            const movedStyles = new Set();
            styles.forEach((s) => {
                if (!prevStyles.has(s)) {
                    createdStyles.add(s);
                }
            });
            prevStyles.forEach((s) => {
                if (!styles.has(s)) {
                    removedStyles.add(s);
                }
            });
            styles.forEach((s) => {
                if (
                    !createdStyles.has(s) &&
                    !removedStyles.has(s) &&
                    didStylePositionChange(s)
                ) {
                    movedStyles.add(s);
                }
            });
            handleStyleOperations({createdStyles, removedStyles, movedStyles});
            extendedIterateShadowHosts(root);
            collectUndefinedElements(root);
        }
        function handleAttributeMutations(mutations) {
            const updatedStyles = new Set();
            const removedStyles = new Set();
            mutations.forEach((m) => {
                const {target} = m;
                if (target.isConnected) {
                    if (shouldManageStyle(target)) {
                        updatedStyles.add(target);
                    } else if (
                        target instanceof HTMLLinkElement &&
                        target.disabled
                    ) {
                        removedStyles.add(target);
                    }
                }
            });
            if (updatedStyles.size + removedStyles.size > 0) {
                update({
                    updated: Array.from(updatedStyles),
                    created: [],
                    removed: Array.from(removedStyles),
                    moved: []
                });
            }
        }
        function observe(root) {
            if (observedRoots.has(root)) {
                return;
            }
            const treeObserver = createOptimizedTreeObserver(root, {
                onMinorMutations: handleMinorTreeMutations,
                onHugeMutations: handleHugeTreeMutations
            });
            const attrObserver = new MutationObserver(handleAttributeMutations);
            attrObserver.observe(root, {
                attributeFilter: ["rel", "disabled", "media", "href"],
                subtree: true
            });
            observers.push(treeObserver, attrObserver);
            observedRoots.add(root);
        }
        function subscribeForShadowRootChanges(node) {
            const {shadowRoot} = node;
            if (shadowRoot == null || observedRoots.has(shadowRoot)) {
                return;
            }
            observe(shadowRoot);
            shadowRootDiscovered(shadowRoot);
        }
        function extendedIterateShadowHosts(node) {
            iterateShadowHosts(node, subscribeForShadowRootChanges);
        }
        observe(document);
        extendedIterateShadowHosts(document.documentElement);
        watchWhenCustomElementsDefined((hosts) => {
            const newStyles = [];
            hosts.forEach((host) =>
                push(newStyles, getManageableStyles(host.shadowRoot))
            );
            update({created: newStyles, updated: [], removed: [], moved: []});
            hosts.forEach((host) => {
                const {shadowRoot} = host;
                if (shadowRoot == null) {
                    return;
                }
                subscribeForShadowRootChanges(host);
                extendedIterateShadowHosts(shadowRoot);
                collectUndefinedElements(shadowRoot);
            });
        });
        document.addEventListener("__darkreader__isDefined", handleIsDefined, {
            passive: true
        });
        collectUndefinedElements(document);
    }
    function resetObservers() {
        observers.forEach((o) => o.disconnect());
        observers.splice(0, observers.length);
        observedRoots = new WeakSet();
    }
    function stopWatchingForStyleChanges() {
        resetObservers();
        unsubscribeFromDefineCustomElements();
    }

    const overrides = new WeakSet();
    function hasAdoptedStyleSheets(node) {
        return (
            Array.isArray(node.adoptedStyleSheets) &&
            node.adoptedStyleSheets.length > 0
        );
    }
    function createAdoptedStyleSheetOverride(node) {
        let cancelAsyncOperations = false;
        function iterateSourceSheets(iterator) {
            node.adoptedStyleSheets.forEach((sheet) => {
                if (!overrides.has(sheet)) {
                    iterator(sheet);
                }
            });
        }
        function injectSheet(sheet, override) {
            const newSheets = [...node.adoptedStyleSheets];
            const sheetIndex = newSheets.indexOf(sheet);
            const overrideIndex = newSheets.indexOf(override);
            if (overrideIndex >= 0) {
                newSheets.splice(overrideIndex, 1);
            }
            newSheets.splice(sheetIndex + 1, 0, override);
            node.adoptedStyleSheets = newSheets;
        }
        function clear() {
            const newSheets = [...node.adoptedStyleSheets];
            for (let i = newSheets.length - 1; i >= 0; i--) {
                const sheet = newSheets[i];
                if (overrides.has(sheet)) {
                    newSheets.splice(i, 1);
                    overrides.delete(sheet);
                }
            }
            if (node.adoptedStyleSheets.length !== newSheets.length) {
                node.adoptedStyleSheets = newSheets;
            }
        }
        function destroy() {
            cancelAsyncOperations = true;
            clear();
            if (frameId) {
                cancelAnimationFrame(frameId);
                frameId = null;
            }
        }
        let rulesChangeKey = 0;
        function getRulesChangeKey() {
            let count = 0;
            iterateSourceSheets((sheet) => {
                count += sheet.cssRules.length;
            });
            if (count === 1) {
                const rule = node.adoptedStyleSheets[0].cssRules[0];
                return rule instanceof CSSStyleRule ? rule.style.length : count;
            }
            return count;
        }
        function render(theme, ignoreImageAnalysis) {
            clear();
            for (let i = node.adoptedStyleSheets.length - 1; i >= 0; i--) {
                const sheet = node.adoptedStyleSheets[i];
                if (overrides.has(sheet)) {
                    continue;
                }
                const rules = sheet.cssRules;
                const override = new CSSStyleSheet();
                const prepareSheet = () => {
                    for (let i = override.cssRules.length - 1; i >= 0; i--) {
                        override.deleteRule(i);
                    }
                    injectSheet(sheet, override);
                    overrides.add(override);
                    return override;
                };
                const sheetModifier = createStyleSheetModifier();
                sheetModifier.modifySheet({
                    prepareSheet,
                    sourceCSSRules: rules,
                    theme,
                    ignoreImageAnalysis,
                    force: false,
                    isAsyncCancelled: () => cancelAsyncOperations
                });
            }
            rulesChangeKey = getRulesChangeKey();
        }
        function checkForUpdates() {
            return getRulesChangeKey() !== rulesChangeKey;
        }
        let frameId = null;
        function watch(callback) {
            frameId = requestAnimationFrame(() => {
                if (checkForUpdates()) {
                    const sheets = node.adoptedStyleSheets.filter(
                        (s) => !overrides.has(s)
                    );
                    callback(sheets);
                }
                watch(callback);
            });
        }
        return {
            render,
            destroy,
            watch
        };
    }

    function injectProxy(
        enableStyleSheetsProxy,
        enableCustomElementRegistryProxy
    ) {
        document.dispatchEvent(
            new CustomEvent("__darkreader__inlineScriptsAllowed")
        );
        const addRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "addRule"
        );
        const insertRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "insertRule"
        );
        const deleteRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "deleteRule"
        );
        const removeRuleDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "removeRule"
        );
        const replaceDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "replace"
        );
        const replaceSyncDescriptor = Object.getOwnPropertyDescriptor(
            CSSStyleSheet.prototype,
            "replaceSync"
        );
        const documentStyleSheetsDescriptor = enableStyleSheetsProxy
            ? Object.getOwnPropertyDescriptor(Document.prototype, "styleSheets")
            : null;
        const customElementRegistryDefineDescriptor =
            enableCustomElementRegistryProxy
                ? Object.getOwnPropertyDescriptor(
                      CustomElementRegistry.prototype,
                      "define"
                  )
                : null;
        const shouldWrapHTMLElement = [
            "baidu.com",
            "baike.baidu.com",
            "ditu.baidu.com",
            "map.baidu.com",
            "maps.baidu.com",
            "haokan.baidu.com",
            "pan.baidu.com",
            "passport.baidu.com",
            "tieba.baidu.com",
            "www.baidu.com"
        ].includes(location.hostname);
        const getElementsByTagNameDescriptor = shouldWrapHTMLElement
            ? Object.getOwnPropertyDescriptor(
                  Element.prototype,
                  "getElementsByTagName"
              )
            : null;
        const shouldProxyChildNodes = location.hostname === "www.vy.no";
        const childNodesDescriptor = shouldProxyChildNodes
            ? Object.getOwnPropertyDescriptor(Node.prototype, "childNodes")
            : null;
        const cleaners = [];
        const cleanUp = () => {
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "addRule",
                addRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "insertRule",
                insertRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "deleteRule",
                deleteRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "removeRule",
                removeRuleDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "replace",
                replaceDescriptor
            );
            Object.defineProperty(
                CSSStyleSheet.prototype,
                "replaceSync",
                replaceSyncDescriptor
            );
            document.removeEventListener("__darkreader__cleanUp", cleanUp);
            document.removeEventListener(
                "__darkreader__addUndefinedResolver",
                addUndefinedResolver
            );
            document.removeEventListener(
                "__darkreader__blobURLCheckRequest",
                checkBlobURLSupport
            );
            if (enableStyleSheetsProxy) {
                Object.defineProperty(
                    Document.prototype,
                    "styleSheets",
                    documentStyleSheetsDescriptor
                );
            }
            if (enableCustomElementRegistryProxy) {
                Object.defineProperty(
                    CustomElementRegistry.prototype,
                    "define",
                    customElementRegistryDefineDescriptor
                );
            }
            if (shouldWrapHTMLElement) {
                Object.defineProperty(
                    Element.prototype,
                    "getElementsByTagName",
                    getElementsByTagNameDescriptor
                );
            }
            if (shouldProxyChildNodes) {
                Object.defineProperty(
                    Node.prototype,
                    "childNodes",
                    childNodesDescriptor
                );
            }
            cleaners.forEach((clean) => clean());
            cleaners.splice(0);
        };
        const addUndefinedResolverInner = (tag) => {
            customElements.whenDefined(tag).then(() => {
                document.dispatchEvent(
                    new CustomEvent("__darkreader__isDefined", {detail: {tag}})
                );
            });
        };
        const addUndefinedResolver = (e) =>
            addUndefinedResolverInner(e.detail.tag);
        document.addEventListener("__darkreader__cleanUp", cleanUp, {
            passive: true
        });
        document.addEventListener(
            "__darkreader__addUndefinedResolver",
            addUndefinedResolver,
            {passive: true}
        );
        document.addEventListener(
            "__darkreader__blobURLCheckRequest",
            checkBlobURLSupport,
            {once: true}
        );
        const updateSheetEvent = new Event("__darkreader__updateSheet");
        function proxyAddRule(selector, style, index) {
            addRuleDescriptor.value.call(this, selector, style, index);
            if (
                this.ownerNode &&
                !(
                    this.ownerNode.classList &&
                    this.ownerNode.classList.contains("darkreader")
                )
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return -1;
        }
        function proxyInsertRule(rule, index) {
            const returnValue = insertRuleDescriptor.value.call(
                this,
                rule,
                index
            );
            if (
                this.ownerNode &&
                !(
                    this.ownerNode.classList &&
                    this.ownerNode.classList.contains("darkreader")
                )
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
            return returnValue;
        }
        function proxyDeleteRule(index) {
            deleteRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !(
                    this.ownerNode.classList &&
                    this.ownerNode.classList.contains("darkreader")
                )
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyRemoveRule(index) {
            removeRuleDescriptor.value.call(this, index);
            if (
                this.ownerNode &&
                !(
                    this.ownerNode.classList &&
                    this.ownerNode.classList.contains("darkreader")
                )
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyReplace(cssText) {
            const returnValue = replaceDescriptor.value.call(this, cssText);
            if (
                this.ownerNode &&
                !(
                    this.ownerNode.classList &&
                    this.ownerNode.classList.contains("darkreader")
                ) &&
                returnValue &&
                returnValue instanceof Promise
            ) {
                returnValue.then(() =>
                    this.ownerNode.dispatchEvent(updateSheetEvent)
                );
            }
            return returnValue;
        }
        function proxyReplaceSync(cssText) {
            replaceSyncDescriptor.value.call(this, cssText);
            if (
                this.ownerNode &&
                !(
                    this.ownerNode.classList &&
                    this.ownerNode.classList.contains("darkreader")
                )
            ) {
                this.ownerNode.dispatchEvent(updateSheetEvent);
            }
        }
        function proxyDocumentStyleSheets() {
            const getCurrentValue = () => {
                const docSheets = documentStyleSheetsDescriptor.get.call(this);
                const filteredSheets = [...docSheets].filter(
                    (styleSheet) =>
                        styleSheet.ownerNode &&
                        !(
                            styleSheet.ownerNode.classList &&
                            styleSheet.ownerNode.classList.contains(
                                "darkreader"
                            )
                        )
                );
                filteredSheets.item = (item) => filteredSheets[item];
                return Object.setPrototypeOf(
                    filteredSheets,
                    StyleSheetList.prototype
                );
            };
            let elements = getCurrentValue();
            const styleSheetListBehavior = {
                get: function (_, property) {
                    return getCurrentValue()[property];
                }
            };
            elements = new Proxy(elements, styleSheetListBehavior);
            return elements;
        }
        function proxyCustomElementRegistryDefine(name, constructor, options) {
            addUndefinedResolverInner(name);
            customElementRegistryDefineDescriptor.value.call(
                this,
                name,
                constructor,
                options
            );
        }
        function proxyGetElementsByTagName(tagName) {
            if (tagName !== "style") {
                return getElementsByTagNameDescriptor.value.call(this, tagName);
            }
            const getCurrentElementValue = () => {
                const elements = getElementsByTagNameDescriptor.value.call(
                    this,
                    tagName
                );
                return Object.setPrototypeOf(
                    [...elements].filter(
                        (element) =>
                            element &&
                            !(
                                element.classList &&
                                element.classList.contains("darkreader")
                            )
                    ),
                    NodeList.prototype
                );
            };
            let elements = getCurrentElementValue();
            const nodeListBehavior = {
                get: function (_, property) {
                    return getCurrentElementValue()[
                        Number(property) || property
                    ];
                }
            };
            elements = new Proxy(elements, nodeListBehavior);
            return elements;
        }
        function proxyChildNodes() {
            const childNodes = childNodesDescriptor.get.call(this);
            return Object.setPrototypeOf(
                [...childNodes].filter((element) => {
                    return (
                        !element.classList ||
                        !element.classList.contains("darkreader")
                    );
                }),
                NodeList.prototype
            );
        }
        async function checkBlobURLSupport() {
            const svg =
                '<svg xmlns="http://www.w3.org/2000/svg" width="1" height="1"><rect width="1" height="1" fill="transparent"/></svg>';
            const bytes = new Uint8Array(svg.length);
            for (let i = 0; i < svg.length; i++) {
                bytes[i] = svg.charCodeAt(i);
            }
            const blob = new Blob([bytes], {type: "image/svg+xml"});
            const objectURL = URL.createObjectURL(blob);
            let blobURLAllowed;
            try {
                const image = new Image();
                await new Promise((resolve, reject) => {
                    image.onload = () => resolve();
                    image.onerror = () => reject();
                    image.src = objectURL;
                });
                blobURLAllowed = true;
            } catch (err) {
                blobURLAllowed = false;
            }
            document.dispatchEvent(
                new CustomEvent("__darkreader__blobURLCheckResponse", {
                    detail: {blobURLAllowed}
                })
            );
        }
        Object.defineProperty(CSSStyleSheet.prototype, "addRule", {
            ...addRuleDescriptor,
            value: proxyAddRule
        });
        Object.defineProperty(CSSStyleSheet.prototype, "insertRule", {
            ...insertRuleDescriptor,
            value: proxyInsertRule
        });
        Object.defineProperty(CSSStyleSheet.prototype, "deleteRule", {
            ...deleteRuleDescriptor,
            value: proxyDeleteRule
        });
        Object.defineProperty(CSSStyleSheet.prototype, "removeRule", {
            ...removeRuleDescriptor,
            value: proxyRemoveRule
        });
        Object.defineProperty(CSSStyleSheet.prototype, "replace", {
            ...replaceDescriptor,
            value: proxyReplace
        });
        Object.defineProperty(CSSStyleSheet.prototype, "replaceSync", {
            ...replaceSyncDescriptor,
            value: proxyReplaceSync
        });
        if (enableStyleSheetsProxy) {
            Object.defineProperty(Document.prototype, "styleSheets", {
                ...documentStyleSheetsDescriptor,
                get: proxyDocumentStyleSheets
            });
        }
        if (enableCustomElementRegistryProxy) {
            Object.defineProperty(CustomElementRegistry.prototype, "define", {
                ...customElementRegistryDefineDescriptor,
                value: proxyCustomElementRegistryDefine
            });
        }
        if (shouldWrapHTMLElement) {
            Object.defineProperty(Element.prototype, "getElementsByTagName", {
                ...getElementsByTagNameDescriptor,
                value: proxyGetElementsByTagName
            });
        }
        if (shouldProxyChildNodes) {
            Object.defineProperty(Node.prototype, "childNodes", {
                ...childNodesDescriptor,
                get: proxyChildNodes
            });
        }
    }

    let documentVisibilityListener = null;
    let documentIsVisible_ = !document.hidden;
    const listenerOptions = {
        capture: true,
        passive: true
    };
    function watchForDocumentVisibility() {
        document.addEventListener(
            "visibilitychange",
            documentVisibilityListener,
            listenerOptions
        );
        window.addEventListener(
            "pageshow",
            documentVisibilityListener,
            listenerOptions
        );
        window.addEventListener(
            "focus",
            documentVisibilityListener,
            listenerOptions
        );
    }
    function stopWatchingForDocumentVisibility() {
        document.removeEventListener(
            "visibilitychange",
            documentVisibilityListener,
            listenerOptions
        );
        window.removeEventListener(
            "pageshow",
            documentVisibilityListener,
            listenerOptions
        );
        window.removeEventListener(
            "focus",
            documentVisibilityListener,
            listenerOptions
        );
    }
    function setDocumentVisibilityListener(callback) {
        const alreadyWatching = Boolean(documentVisibilityListener);
        documentVisibilityListener = () => {
            if (!document.hidden) {
                removeDocumentVisibilityListener();
                callback();
                documentIsVisible_ = true;
            }
        };
        if (!alreadyWatching) {
            watchForDocumentVisibility();
        }
    }
    function removeDocumentVisibilityListener() {
        stopWatchingForDocumentVisibility();
        documentVisibilityListener = null;
    }
    function documentIsVisible() {
        return documentIsVisible_;
    }

    function findRelevantFix(documentURL, fixes) {
        if (
            !Array.isArray(fixes) ||
            fixes.length === 0 ||
            fixes[0].url[0] !== "*"
        ) {
            return null;
        }
        let maxSpecificity = 0;
        let maxSpecificityIndex = null;
        for (let i = 1; i < fixes.length; i++) {
            if (isURLInList(documentURL, fixes[i].url)) {
                const specificity = fixes[i].url[0].length;
                if (
                    maxSpecificityIndex === null ||
                    maxSpecificity < specificity
                ) {
                    maxSpecificity = specificity;
                    maxSpecificityIndex = i;
                }
            }
        }
        return maxSpecificityIndex;
    }
    function combineFixes(fixes) {
        if (fixes.length === 0 || fixes[0].url[0] !== "*") {
            return null;
        }
        function combineArrays(arrays) {
            return arrays.filter(Boolean).flat();
        }
        return {
            url: [],
            invert: combineArrays(fixes.map((fix) => fix.invert)),
            css: fixes
                .map((fix) => fix.css)
                .filter(Boolean)
                .join("\n"),
            ignoreInlineStyle: combineArrays(
                fixes.map((fix) => fix.ignoreInlineStyle)
            ),
            ignoreImageAnalysis: combineArrays(
                fixes.map((fix) => fix.ignoreImageAnalysis)
            ),
            disableStyleSheetsProxy: fixes.some(
                (fix) => fix.disableStyleSheetsProxy
            ),
            disableCustomElementRegistryProxy: fixes.some(
                (fix) => fix.disableCustomElementRegistryProxy
            )
        };
    }

    const INSTANCE_ID = generateUID();
    const styleManagers = new Map();
    const adoptedStyleManagers = [];
    const adoptedStyleFallbacks = new Map();
    let filter = null;
    let fixes = null;
    let isIFrame = null;
    let ignoredImageAnalysisSelectors = [];
    let ignoredInlineSelectors = [];
    function createOrUpdateStyle(className, root = document.head || document) {
        let element = root.querySelector(`.${className}`);
        if (!element) {
            element = document.createElement("style");
            element.classList.add("darkreader");
            element.classList.add(className);
            element.media = "screen";
            element.textContent = "";
        }
        return element;
    }
    function createOrUpdateScript(className, root = document.head || document) {
        let element = root.querySelector(`.${className}`);
        if (!element) {
            element = document.createElement("script");
            element.classList.add("darkreader");
            element.classList.add(className);
        }
        return element;
    }
    const nodePositionWatchers = new Map();
    function setupNodePositionWatcher(node, alias) {
        nodePositionWatchers.has(alias) &&
            nodePositionWatchers.get(alias).stop();
        nodePositionWatchers.set(alias, watchForNodePosition(node, "head"));
    }
    function stopStylePositionWatchers() {
        forEach(nodePositionWatchers.values(), (watcher) => watcher.stop());
        nodePositionWatchers.clear();
    }
    function createStaticStyleOverrides() {
        const fallbackStyle = createOrUpdateStyle(
            "darkreader--fallback",
            document
        );
        fallbackStyle.textContent = getModifiedFallbackStyle(filter, {
            strict: true
        });
        document.head.insertBefore(fallbackStyle, document.head.firstChild);
        setupNodePositionWatcher(fallbackStyle, "fallback");
        const userAgentStyle = createOrUpdateStyle("darkreader--user-agent");
        userAgentStyle.textContent = getModifiedUserAgentStyle(
            filter,
            isIFrame,
            filter.styleSystemControls
        );
        document.head.insertBefore(userAgentStyle, fallbackStyle.nextSibling);
        setupNodePositionWatcher(userAgentStyle, "user-agent");
        const textStyle = createOrUpdateStyle("darkreader--text");
        if (filter.useFont || filter.textStroke > 0) {
            textStyle.textContent = createTextStyle(filter);
        } else {
            textStyle.textContent = "";
        }
        document.head.insertBefore(textStyle, fallbackStyle.nextSibling);
        setupNodePositionWatcher(textStyle, "text");
        const invertStyle = createOrUpdateStyle("darkreader--invert");
        if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {
            invertStyle.textContent = [
                `${fixes.invert.join(", ")} {`,
                `    filter: ${getCSSFilterValue({
                    ...filter,
                    contrast:
                        filter.mode === 0
                            ? filter.contrast
                            : clamp(filter.contrast - 10, 0, 100)
                })} !important;`,
                "}"
            ].join("\n");
        } else {
            invertStyle.textContent = "";
        }
        document.head.insertBefore(invertStyle, textStyle.nextSibling);
        setupNodePositionWatcher(invertStyle, "invert");
        const inlineStyle = createOrUpdateStyle("darkreader--inline");
        inlineStyle.textContent = getInlineOverrideStyle();
        document.head.insertBefore(inlineStyle, invertStyle.nextSibling);
        setupNodePositionWatcher(inlineStyle, "inline");
        const overrideStyle = createOrUpdateStyle("darkreader--override");
        overrideStyle.textContent =
            fixes && fixes.css ? replaceCSSTemplates(fixes.css) : "";
        document.head.appendChild(overrideStyle);
        setupNodePositionWatcher(overrideStyle, "override");
        const variableStyle = createOrUpdateStyle("darkreader--variables");
        const selectionColors = getSelectionColor(filter);
        const {
            darkSchemeBackgroundColor,
            darkSchemeTextColor,
            lightSchemeBackgroundColor,
            lightSchemeTextColor,
            mode
        } = filter;
        let schemeBackgroundColor =
            mode === 0 ? lightSchemeBackgroundColor : darkSchemeBackgroundColor;
        let schemeTextColor =
            mode === 0 ? lightSchemeTextColor : darkSchemeTextColor;
        schemeBackgroundColor = modifyBackgroundColor(
            parseColorWithCache(schemeBackgroundColor),
            filter
        );
        schemeTextColor = modifyForegroundColor(
            parseColorWithCache(schemeTextColor),
            filter
        );
        variableStyle.textContent = [
            `:root {`,
            `   --darkreader-neutral-background: ${schemeBackgroundColor};`,
            `   --darkreader-neutral-text: ${schemeTextColor};`,
            `   --darkreader-selection-background: ${selectionColors.backgroundColorSelection};`,
            `   --darkreader-selection-text: ${selectionColors.foregroundColorSelection};`,
            `}`
        ].join("\n");
        document.head.insertBefore(variableStyle, inlineStyle.nextSibling);
        setupNodePositionWatcher(variableStyle, "variables");
        const rootVarsStyle = createOrUpdateStyle("darkreader--root-vars");
        document.head.insertBefore(rootVarsStyle, variableStyle.nextSibling);
        const enableStyleSheetsProxy = !(
            fixes && fixes.disableStyleSheetsProxy
        );
        const enableCustomElementRegistryProxy = !(
            fixes && fixes.disableCustomElementRegistryProxy
        );
        {
            const proxyScript = createOrUpdateScript("darkreader--proxy");
            proxyScript.append(
                `(${injectProxy})(${enableStyleSheetsProxy}, ${enableCustomElementRegistryProxy})`
            );
            document.head.insertBefore(proxyScript, rootVarsStyle.nextSibling);
            proxyScript.remove();
        }
    }
    const shadowRootsWithOverrides = new Set();
    function createShadowStaticStyleOverridesInner(root) {
        const inlineStyle = createOrUpdateStyle("darkreader--inline", root);
        inlineStyle.textContent = getInlineOverrideStyle();
        root.insertBefore(inlineStyle, root.firstChild);
        const overrideStyle = createOrUpdateStyle("darkreader--override", root);
        overrideStyle.textContent =
            fixes && fixes.css ? replaceCSSTemplates(fixes.css) : "";
        root.insertBefore(overrideStyle, inlineStyle.nextSibling);
        const invertStyle = createOrUpdateStyle("darkreader--invert", root);
        if (fixes && Array.isArray(fixes.invert) && fixes.invert.length > 0) {
            invertStyle.textContent = [
                `${fixes.invert.join(", ")} {`,
                `    filter: ${getCSSFilterValue({
                    ...filter,
                    contrast:
                        filter.mode === 0
                            ? filter.contrast
                            : clamp(filter.contrast - 10, 0, 100)
                })} !important;`,
                "}"
            ].join("\n");
        } else {
            invertStyle.textContent = "";
        }
        root.insertBefore(invertStyle, overrideStyle.nextSibling);
        shadowRootsWithOverrides.add(root);
    }
    function delayedCreateShadowStaticStyleOverrides(root) {
        const observer = new MutationObserver((mutations, observer) => {
            observer.disconnect();
            for (const {type, removedNodes} of mutations) {
                if (type === "childList") {
                    for (const {nodeName, className} of removedNodes) {
                        if (
                            nodeName === "STYLE" &&
                            [
                                "darkreader darkreader--inline",
                                "darkreader darkreader--override",
                                "darkreader darkreader--invert"
                            ].includes(className)
                        ) {
                            createShadowStaticStyleOverridesInner(root);
                            return;
                        }
                    }
                }
            }
        });
        observer.observe(root, {childList: true});
    }
    function createShadowStaticStyleOverrides(root) {
        const uninit = root.firstChild === null;
        createShadowStaticStyleOverridesInner(root);
        if (uninit) {
            delayedCreateShadowStaticStyleOverrides(root);
        }
    }
    function replaceCSSTemplates($cssText) {
        return $cssText.replace(/\${(.+?)}/g, (_, $color) => {
            const color = parseColorWithCache($color);
            if (color) {
                return modifyColor(color, filter);
            }
            return $color;
        });
    }
    function cleanFallbackStyle() {
        const fallback = document.querySelector(".darkreader--fallback");
        if (fallback) {
            fallback.textContent = "";
        }
    }
    function createDynamicStyleOverrides() {
        cancelRendering();
        const allStyles = getManageableStyles(document);
        const newManagers = allStyles
            .filter((style) => !styleManagers.has(style))
            .map((style) => createManager(style));
        newManagers
            .map((manager) => manager.details({secondRound: false}))
            .filter((detail) => detail && detail.rules.length > 0)
            .forEach((detail) => {
                variablesStore.addRulesForMatching(detail.rules);
            });
        variablesStore.matchVariablesAndDependents();
        variablesStore.setOnRootVariableChange(() => {
            const rootVarsStyle = createOrUpdateStyle("darkreader--root-vars");
            variablesStore.putRootVars(rootVarsStyle, filter);
        });
        const rootVarsStyle = createOrUpdateStyle("darkreader--root-vars");
        variablesStore.putRootVars(rootVarsStyle, filter);
        styleManagers.forEach((manager) =>
            manager.render(filter, ignoredImageAnalysisSelectors)
        );
        if (loadingStyles.size === 0) {
            cleanFallbackStyle();
        }
        newManagers.forEach((manager) => manager.watch());
        const inlineStyleElements = toArray(
            document.querySelectorAll(INLINE_STYLE_SELECTOR)
        );
        iterateShadowHosts(document.documentElement, (host) => {
            createShadowStaticStyleOverrides(host.shadowRoot);
            const elements = host.shadowRoot.querySelectorAll(
                INLINE_STYLE_SELECTOR
            );
            if (elements.length > 0) {
                push(inlineStyleElements, elements);
            }
        });
        inlineStyleElements.forEach((el) =>
            overrideInlineStyle(
                el,
                filter,
                ignoredInlineSelectors,
                ignoredImageAnalysisSelectors
            )
        );
        handleAdoptedStyleSheets(document);
        variablesStore.matchVariablesAndDependents();
    }
    let loadingStylesCounter = 0;
    const loadingStyles = new Set();
    function createManager(element) {
        const loadingStyleId = ++loadingStylesCounter;
        function loadingStart() {
            if (!isDOMReady() || !documentIsVisible()) {
                loadingStyles.add(loadingStyleId);
                logInfo(
                    `Current amount of styles loading: ${loadingStyles.size}`
                );
                const fallbackStyle = document.querySelector(
                    ".darkreader--fallback"
                );
                if (!fallbackStyle.textContent) {
                    fallbackStyle.textContent = getModifiedFallbackStyle(
                        filter,
                        {strict: false}
                    );
                }
            }
        }
        function loadingEnd() {
            loadingStyles.delete(loadingStyleId);
            logInfo(
                `Removed loadingStyle ${loadingStyleId}, now awaiting: ${loadingStyles.size}`
            );
            if (loadingStyles.size === 0 && isDOMReady()) {
                cleanFallbackStyle();
            }
        }
        function update() {
            const details = manager.details({secondRound: true});
            if (!details) {
                return;
            }
            variablesStore.addRulesForMatching(details.rules);
            variablesStore.matchVariablesAndDependents();
            manager.render(filter, ignoredImageAnalysisSelectors);
        }
        const manager = manageStyle(element, {
            update,
            loadingStart,
            loadingEnd
        });
        styleManagers.set(element, manager);
        return manager;
    }
    function removeManager(element) {
        const manager = styleManagers.get(element);
        if (manager) {
            manager.destroy();
            styleManagers.delete(element);
        }
    }
    const throttledRenderAllStyles = throttle((callback) => {
        styleManagers.forEach((manager) =>
            manager.render(filter, ignoredImageAnalysisSelectors)
        );
        adoptedStyleManagers.forEach((manager) =>
            manager.render(filter, ignoredImageAnalysisSelectors)
        );
        callback && callback();
    });
    const cancelRendering = function () {
        throttledRenderAllStyles.cancel();
    };
    function onDOMReady() {
        if (loadingStyles.size === 0) {
            cleanFallbackStyle();
            return;
        }
    }
    function runDynamicStyle() {
        createDynamicStyleOverrides();
        watchForUpdates();
    }
    function createThemeAndWatchForUpdates() {
        createStaticStyleOverrides();
        if (!documentIsVisible() && !filter.immediateModify) {
            setDocumentVisibilityListener(runDynamicStyle);
        } else {
            runDynamicStyle();
        }
        changeMetaThemeColorWhenAvailable(filter);
    }
    let pendingAdoptedVarMatch = false;
    function handleAdoptedStyleSheets(node) {
        const theme = filter;
        if (hasAdoptedStyleSheets(node)) {
            node.adoptedStyleSheets.forEach((s) => {
                variablesStore.addRulesForMatching(s.cssRules);
            });
            const newManger = createAdoptedStyleSheetOverride(node);
            adoptedStyleManagers.push(newManger);
            newManger.render(theme, ignoredImageAnalysisSelectors);
            newManger.watch((sheets) => {
                sheets.forEach((s) => {
                    variablesStore.addRulesForMatching(s.cssRules);
                });
                newManger.render(theme, ignoredImageAnalysisSelectors);
                pendingAdoptedVarMatch = true;
            });
            potentialAdoptedStyleNodes.delete(node);
        } else if (!potentialAdoptedStyleNodes.has(node)) {
            potentialAdoptedStyleNodes.add(node);
        }
    }
    const potentialAdoptedStyleNodes = new Set();
    let potentialAdoptedStyleFrameId = null;
    function watchPotentialAdoptedStyleNodes() {
        potentialAdoptedStyleFrameId = requestAnimationFrame(() => {
            let changed = false;
            potentialAdoptedStyleNodes.forEach((node) => {
                if (node.isConnected) {
                    handleAdoptedStyleSheets(node);
                    changed = true;
                } else {
                    potentialAdoptedStyleNodes.delete(node);
                }
            });
            if (changed || pendingAdoptedVarMatch) {
                variablesStore.matchVariablesAndDependents();
                pendingAdoptedVarMatch = false;
            }
            watchPotentialAdoptedStyleNodes();
        });
    }
    function stopWatchingPotentialAdoptedStyleNodes() {
        potentialAdoptedStyleFrameId &&
            cancelAnimationFrame(potentialAdoptedStyleFrameId);
        potentialAdoptedStyleNodes.clear();
    }
    function watchForUpdates() {
        const managedStyles = Array.from(styleManagers.keys());
        watchForStyleChanges(
            managedStyles,
            ({created, updated, removed, moved}) => {
                const stylesToRemove = removed;
                const stylesToManage = created
                    .concat(updated)
                    .concat(moved)
                    .filter((style) => !styleManagers.has(style));
                const stylesToRestore = moved.filter((style) =>
                    styleManagers.has(style)
                );
                stylesToRemove.forEach((style) => removeManager(style));
                const newManagers = stylesToManage.map((style) =>
                    createManager(style)
                );
                newManagers
                    .map((manager) => manager.details({secondRound: false}))
                    .filter((detail) => detail && detail.rules.length > 0)
                    .forEach((detail) => {
                        variablesStore.addRulesForMatching(detail.rules);
                    });
                variablesStore.matchVariablesAndDependents();
                newManagers.forEach((manager) =>
                    manager.render(filter, ignoredImageAnalysisSelectors)
                );
                newManagers.forEach((manager) => manager.watch());
                stylesToRestore.forEach((style) =>
                    styleManagers.get(style).restore()
                );
            },
            (shadowRoot) => {
                createShadowStaticStyleOverrides(shadowRoot);
                handleAdoptedStyleSheets(shadowRoot);
            }
        );
        watchPotentialAdoptedStyleNodes();
        watchForInlineStyles(
            (element) => {
                overrideInlineStyle(
                    element,
                    filter,
                    ignoredInlineSelectors,
                    ignoredImageAnalysisSelectors
                );
                if (element === document.documentElement) {
                    const styleAttr = element.getAttribute("style") || "";
                    if (styleAttr.includes("--")) {
                        variablesStore.matchVariablesAndDependents();
                        const rootVarsStyle = createOrUpdateStyle(
                            "darkreader--root-vars"
                        );
                        variablesStore.putRootVars(rootVarsStyle, filter);
                    }
                }
            },
            (root) => {
                createShadowStaticStyleOverrides(root);
                const inlineStyleElements = root.querySelectorAll(
                    INLINE_STYLE_SELECTOR
                );
                if (inlineStyleElements.length > 0) {
                    forEach(inlineStyleElements, (el) =>
                        overrideInlineStyle(
                            el,
                            filter,
                            ignoredInlineSelectors,
                            ignoredImageAnalysisSelectors
                        )
                    );
                }
            }
        );
        addDOMReadyListener(onDOMReady);
    }
    function stopWatchingForUpdates() {
        styleManagers.forEach((manager) => manager.pause());
        stopStylePositionWatchers();
        stopWatchingForStyleChanges();
        stopWatchingForInlineStyles();
        removeDOMReadyListener(onDOMReady);
        cleanReadyStateCompleteListeners();
    }
    let metaObserver;
    function addMetaListener() {
        metaObserver = new MutationObserver(() => {
            if (document.querySelector('meta[name="darkreader-lock"]')) {
                metaObserver.disconnect();
                removeDynamicTheme();
            }
        });
        metaObserver.observe(document.head, {childList: true, subtree: true});
    }
    function createDarkReaderInstanceMarker() {
        const metaElement = document.createElement("meta");
        metaElement.name = "darkreader";
        metaElement.content = INSTANCE_ID;
        document.head.appendChild(metaElement);
    }
    function isAnotherDarkReaderInstanceActive() {
        if (document.querySelector('meta[name="darkreader-lock"]')) {
            return true;
        }
        const meta = document.querySelector('meta[name="darkreader"]');
        if (meta) {
            if (meta.content !== INSTANCE_ID) {
                return true;
            }
            return false;
        }
        createDarkReaderInstanceMarker();
        addMetaListener();
        return false;
    }
    function selectRelevantFix(documentURL, fixes) {
        if (!fixes) {
            return null;
        }
        if (fixes.length === 0 || fixes[0].url[0] !== "*") {
            return null;
        }
        const relevantFixIndex = findRelevantFix(documentURL, fixes);
        return relevantFixIndex
            ? combineFixes([fixes[0], fixes[relevantFixIndex]])
            : fixes[0];
    }
    function createOrUpdateDynamicTheme(
        filterConfig,
        dynamicThemeFixes,
        iframe
    ) {
        const dynamicThemeFix = selectRelevantFix(
            document.location.href,
            dynamicThemeFixes
        );
        createOrUpdateDynamicThemeInternal(
            filterConfig,
            dynamicThemeFix,
            iframe
        );
    }
    function createOrUpdateDynamicThemeInternal(
        filterConfig,
        dynamicThemeFixes,
        iframe
    ) {
        filter = filterConfig;
        fixes = dynamicThemeFixes;
        if (fixes) {
            ignoredImageAnalysisSelectors = Array.isArray(
                fixes.ignoreImageAnalysis
            )
                ? fixes.ignoreImageAnalysis
                : [];
            ignoredInlineSelectors = Array.isArray(fixes.ignoreInlineStyle)
                ? fixes.ignoreInlineStyle
                : [];
        } else {
            ignoredImageAnalysisSelectors = [];
            ignoredInlineSelectors = [];
        }
        if (filter.immediateModify) {
            setIsDOMReady(() => {
                return true;
            });
        }
        isIFrame = iframe;
        if (document.head) {
            if (isAnotherDarkReaderInstanceActive()) {
                removeDynamicTheme();
                return;
            }
            document.documentElement.setAttribute(
                "data-darkreader-mode",
                "dynamic"
            );
            document.documentElement.setAttribute(
                "data-darkreader-scheme",
                filter.mode ? "dark" : "dimmed"
            );
            createThemeAndWatchForUpdates();
        } else {
            {
                const fallbackStyle = createOrUpdateStyle(
                    "darkreader--fallback"
                );
                document.documentElement.appendChild(fallbackStyle);
                fallbackStyle.textContent = getModifiedFallbackStyle(filter, {
                    strict: true
                });
            }
            const headObserver = new MutationObserver(() => {
                if (document.head) {
                    headObserver.disconnect();
                    if (isAnotherDarkReaderInstanceActive()) {
                        removeDynamicTheme();
                        return;
                    }
                    createThemeAndWatchForUpdates();
                }
            });
            headObserver.observe(document, {childList: true, subtree: true});
        }
    }
    function removeProxy() {
        document.dispatchEvent(new CustomEvent("__darkreader__cleanUp"));
        removeNode(document.head.querySelector(".darkreader--proxy"));
    }
    const cleaners = [];
    function removeDynamicTheme() {
        document.documentElement.removeAttribute(`data-darkreader-mode`);
        document.documentElement.removeAttribute(`data-darkreader-scheme`);
        cleanDynamicThemeCache();
        removeNode(document.querySelector(".darkreader--fallback"));
        if (document.head) {
            restoreMetaThemeColor();
            removeNode(document.head.querySelector(".darkreader--user-agent"));
            removeNode(document.head.querySelector(".darkreader--text"));
            removeNode(document.head.querySelector(".darkreader--invert"));
            removeNode(document.head.querySelector(".darkreader--inline"));
            removeNode(document.head.querySelector(".darkreader--override"));
            removeNode(document.head.querySelector(".darkreader--variables"));
            removeNode(document.head.querySelector(".darkreader--root-vars"));
            removeNode(document.head.querySelector('meta[name="darkreader"]'));
            removeProxy();
        }
        shadowRootsWithOverrides.forEach((root) => {
            removeNode(root.querySelector(".darkreader--inline"));
            removeNode(root.querySelector(".darkreader--override"));
        });
        shadowRootsWithOverrides.clear();
        forEach(styleManagers.keys(), (el) => removeManager(el));
        loadingStyles.clear();
        cleanLoadingLinks();
        forEach(document.querySelectorAll(".darkreader"), removeNode);
        adoptedStyleManagers.forEach((manager) => manager.destroy());
        adoptedStyleManagers.splice(0);
        adoptedStyleFallbacks.forEach((fallback) => fallback.destroy());
        adoptedStyleFallbacks.clear();
        stopWatchingPotentialAdoptedStyleNodes();
        metaObserver && metaObserver.disconnect();
        cleaners.forEach((clean) => clean());
        cleaners.splice(0);
    }
    function cleanDynamicThemeCache() {
        variablesStore.clear();
        parsedURLCache.clear();
        removeDocumentVisibilityListener();
        cancelRendering();
        stopWatchingForUpdates();
        cleanModificationCache();
        clearColorCache();
    }

    const blobRegex = /url\(\"(blob\:.*?)\"\)/g;
    async function replaceBlobs(text) {
        const promises = [];
        getMatches(blobRegex, text, 1).forEach((url) => {
            const promise = loadAsDataURL(url);
            promises.push(promise);
        });
        const data = await Promise.all(promises);
        return text.replace(blobRegex, () => `url("${data.shift()}")`);
    }
    const banner = `/*
                        _______
                       /       \\
                      .==.    .==.
                     ((  ))==((  ))
                    / "=="    "=="\\
                   /____|| || ||___\\
       ________     ____    ________  ___    ___
       |  ___  \\   /    \\   |  ___  \\ |  |  /  /
       |  |  \\  \\ /  /\\  \\  |  |  \\  \\|  |_/  /
       |  |   )  /  /__\\  \\ |  |__/  /|  ___  \\
       |  |__/  /  ______  \\|  ____  \\|  |  \\  \\
_______|_______/__/ ____ \\__\\__|___\\__\\__|___\\__\\____
|  ___  \\ |  ____/ /    \\   |  ___  \\ |  ____|  ___  \\
|  |  \\  \\|  |___ /  /\\  \\  |  |  \\  \\|  |___|  |  \\  \\
|  |__/  /|  ____/  /__\\  \\ |  |   )  |  ____|  |__/  /
|  ____  \\|  |__/  ______  \\|  |__/  /|  |___|  ____  \\
|__|   \\__\\____/__/      \\__\\_______/ |______|__|   \\__\\
                https://darkreader.org
*/

/*! Dark reader generated CSS | Licensed under MIT https://github.com/darkreader/darkreader/blob/main/LICENSE */
`;
    async function collectCSS() {
        const css = [banner];
        function addStaticCSS(selector, comment) {
            const staticStyle = document.querySelector(selector);
            if (staticStyle && staticStyle.textContent) {
                css.push(`/* ${comment} */`);
                css.push(staticStyle.textContent);
                css.push("");
            }
        }
        addStaticCSS(".darkreader--fallback", "Fallback Style");
        addStaticCSS(".darkreader--user-agent", "User-Agent Style");
        addStaticCSS(".darkreader--text", "Text Style");
        addStaticCSS(".darkreader--invert", "Invert Style");
        addStaticCSS(".darkreader--variables", "Variables Style");
        const modifiedCSS = [];
        document.querySelectorAll(".darkreader--sync").forEach((element) => {
            forEach(element.sheet.cssRules, (rule) => {
                rule && rule.cssText && modifiedCSS.push(rule.cssText);
            });
        });
        if (modifiedCSS.length) {
            const formattedCSS = formatCSS(modifiedCSS.join("\n"));
            css.push("/* Modified CSS */");
            css.push(await replaceBlobs(formattedCSS));
            css.push("");
        }
        addStaticCSS(".darkreader--override", "Override Style");
        return css.join("\n");
    }

    let unloaded = false;
    const scriptId = generateUID();
    function cleanup() {
        unloaded = true;
        removeEventListener("pagehide", onPageHide);
        removeEventListener("freeze", onFreeze);
        removeEventListener("resume", onResume);
        cleanDynamicThemeCache();
        stopDarkThemeDetector();
        stopColorSchemeChangeDetector();
    }
    function sendMessage(message) {
        if (unloaded) {
            return;
        }
        const responseHandler = (response) => {
            if (response === "unsupportedSender") {
                removeStyle();
                removeSVGFilter();
                removeDynamicTheme();
                cleanup();
            }
        };
        try {
            if (false);
            else {
                chrome.runtime.sendMessage(message, responseHandler);
            }
        } catch (error) {
            if (error.message === "Extension context invalidated.") {
                console.log(
                    "Dark Reader: instance of old CS detected, clening up."
                );
                cleanup();
            } else {
                console.log(
                    "Dark Reader: unexpected error during message passing."
                );
            }
        }
    }
    function onMessage(message) {
        if (
            message.scriptId !== scriptId &&
            message.type !== MessageTypeUItoCS.EXPORT_CSS
        ) {
            return;
        }
        logInfoCollapsed(`onMessage[${message.type}]`, message);
        switch (message.type) {
            case MessageTypeBGtoCS.ADD_CSS_FILTER:
            case MessageTypeBGtoCS.ADD_STATIC_THEME: {
                const {css, detectDarkTheme, detectorHints} = message.data;
                removeDynamicTheme();
                createOrUpdateStyle$1(
                    css,
                    message.type === MessageTypeBGtoCS.ADD_STATIC_THEME
                        ? "static"
                        : "filter"
                );
                if (detectDarkTheme) {
                    runDarkThemeDetector((hasDarkTheme) => {
                        if (hasDarkTheme) {
                            removeStyle();
                            onDarkThemeDetected();
                        }
                    }, detectorHints);
                }
                break;
            }
            case MessageTypeBGtoCS.ADD_SVG_FILTER: {
                const {
                    css,
                    svgMatrix,
                    svgReverseMatrix,
                    detectDarkTheme,
                    detectorHints
                } = message.data;
                removeDynamicTheme();
                createOrUpdateSVGFilter(svgMatrix, svgReverseMatrix);
                createOrUpdateStyle$1(css, "filter");
                if (detectDarkTheme) {
                    runDarkThemeDetector((hasDarkTheme) => {
                        if (hasDarkTheme) {
                            removeStyle();
                            removeSVGFilter();
                            onDarkThemeDetected();
                        }
                    }, detectorHints);
                }
                break;
            }
            case MessageTypeBGtoCS.ADD_DYNAMIC_THEME: {
                const {theme, fixes, isIFrame, detectDarkTheme, detectorHints} =
                    message.data;
                removeStyle();
                createOrUpdateDynamicTheme(theme, fixes, isIFrame);
                if (detectDarkTheme) {
                    runDarkThemeDetector((hasDarkTheme) => {
                        if (hasDarkTheme) {
                            removeDynamicTheme();
                            onDarkThemeDetected();
                        }
                    }, detectorHints);
                }
                break;
            }
            case MessageTypeUItoCS.EXPORT_CSS:
                collectCSS().then((collectedCSS) =>
                    sendMessage({
                        type: MessageTypeCStoUI.EXPORT_CSS_RESPONSE,
                        data: collectedCSS
                    })
                );
                break;
            case MessageTypeBGtoCS.UNSUPPORTED_SENDER:
            case MessageTypeBGtoCS.CLEAN_UP:
                removeStyle();
                removeSVGFilter();
                removeDynamicTheme();
                stopDarkThemeDetector();
                break;
        }
    }
    function sendConnectionOrResumeMessage(type) {
        sendMessage({
            type,
            scriptId,
            data: {
                isDark: isSystemDarkModeEnabled(),
                isTopFrame: window === window.top
            }
        });
    }
    runColorSchemeChangeDetector((isDark) =>
        sendMessage({
            type: MessageTypeCStoBG.COLOR_SCHEME_CHANGE,
            data: {isDark}
        })
    );
    chrome.runtime.onMessage.addListener(onMessage);
    sendConnectionOrResumeMessage(MessageTypeCStoBG.DOCUMENT_CONNECT);
    function onPageHide(e) {
        if (e.persisted === false) {
            sendMessage({type: MessageTypeCStoBG.DOCUMENT_FORGET, scriptId});
        }
    }
    function onFreeze() {
        sendMessage({type: MessageTypeCStoBG.DOCUMENT_FREEZE});
    }
    function onResume() {
        sendConnectionOrResumeMessage(MessageTypeCStoBG.DOCUMENT_RESUME);
    }
    function onDarkThemeDetected() {
        sendMessage({type: MessageTypeCStoBG.DARK_THEME_DETECTED});
    }
    {
        addEventListener("pagehide", onPageHide, {passive: true});
        addEventListener("freeze", onFreeze, {passive: true});
        addEventListener("resume", onResume, {passive: true});
    }
})();
!function o(a,s,c){function l(t,e){if(!s[t]){if(!a[t]){var n="function"==typeof require&&require;if(!e&&n)return n(t,!0);if(u)return u(t,!0);var i=new Error("Cannot find module '"+t+"'");throw i.code="MODULE_NOT_FOUND",i}var r=s[t]={exports:{}};a[t][0].call(r.exports,function(e){return l(a[t][1][e]||e)},r,r.exports,o,a,s,c)}return s[t].exports}for(var u="function"==typeof require&&require,e=0;e<c.length;e++)l(c[e]);return l}({1:[function(e,t,f){f.defaults={},f.set=function(e,t,n){var i=n||{},r=f.defaults,o=i.expires||r.expires,a=i.domain||r.domain,s=void 0!==i.path?i.path:void 0!==r.path?r.path:"/",c=void 0!==i.secure?i.secure:r.secure,l=void 0!==i.httponly?i.httponly:r.httponly,u=void 0!==i.samesite?i.samesite:r.samesite,d=o?new Date("number"==typeof o?(new Date).getTime()+864e5*o:o):0;document.cookie=e.replace(/[^+#$&^`|]/g,encodeURIComponent).replace("(","%28").replace(")","%29")+"="+t.replace(/[^+#$&/:<-\[\]-}]/g,encodeURIComponent)+(d&&0<=d.getTime()?";expires="+d.toUTCString():"")+(a?";domain="+a:"")+(s?";path="+s:"")+(c?";secure":"")+(l?";httponly":"")+(u?";samesite="+u:"")},f.get=function(e){for(var t=document.cookie.split(";");t.length;){var n=t.pop(),i=(i=n.indexOf("="))<0?n.length:i;if(decodeURIComponent(n.slice(0,i).replace(/^\s+/,""))===e)return decodeURIComponent(n.slice(i+1))}return null},f.erase=function(e,t){f.set(e,"",{expires:-1,domain:t&&t.domain,path:t&&t.path,secure:0,httponly:0})},f.all=function(){for(var e={},t=document.cookie.split(";");t.length;){var n=t.pop(),i=(i=n.indexOf("="))<0?n.length:i;e[decodeURIComponent(n.slice(0,i).replace(/^\s+/,""))]=decodeURIComponent(n.slice(i+1))}return e}},{}],2:[function(e,t,n){"use strict";var c=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable;t.exports=function(){try{if(!Object.assign)return;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map(function(e){return t[e]}).join(""))return;var i={};return"abcdefghijklmnopqrst".split("").forEach(function(e){i[e]=e}),"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},i)).join("")?void 0:1}catch(e){return}}()?Object.assign:function(e,t){for(var n,i,r=function(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}(e),o=1;o<arguments.length;o++){for(var a in n=Object(arguments[o]))l.call(n,a)&&(r[a]=n[a]);if(c){i=c(n);for(var s=0;s<i.length;s++)u.call(n,i[s])&&(r[i[s]]=n[i[s]])}}return r}},{}],3:[function(e,t,n){var i,r,o=t.exports={};function a(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function c(t){if(i===setTimeout)return setTimeout(t,0);if((i===a||!i)&&setTimeout)return i=setTimeout,setTimeout(t,0);try{return i(t,0)}catch(e){try{return i.call(null,t,0)}catch(e){return i.call(this,t,0)}}}!function(){try{i="function"==typeof setTimeout?setTimeout:a}catch(e){i=a}try{r="function"==typeof clearTimeout?clearTimeout:s}catch(e){r=s}}();var l,u=[],d=!1,f=-1;function p(){d&&l&&(d=!1,l.length?u=l.concat(u):f=-1,u.length&&g())}function g(){if(!d){var e=c(p);d=!0;for(var t=u.length;t;){for(l=u,u=[];++f<t;)l&&l[f].run();f=-1,t=u.length}l=null,d=!1,function(t){if(r===clearTimeout)return clearTimeout(t);if((r===s||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(t);try{r(t)}catch(e){try{return r.call(null,t)}catch(e){return r.call(this,t)}}}(e)}}function y(e,t){this.fun=e,this.array=t}function h(){}o.nextTick=function(e){var t=new Array(arguments.length-1);if(1<arguments.length)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];u.push(new y(e,t)),1!==u.length||d||c(g)},y.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=h,o.addListener=h,o.once=h,o.off=h,o.removeListener=h,o.removeAllListeners=h,o.emit=h,o.prependListener=h,o.prependOnceListener=h,o.listeners=function(e){return[]},o.binding=function(e){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(e){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},{}],4:[function(e,t,n){for(var i=[],r=0;r<256;++r)i[r]=(r+256).toString(16).substr(1);t.exports=function(e,t){var n=t||0;return[i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]]].join("")}},{}],5:[function(e,t,n){var i,r,o="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);o?(i=new Uint8Array(16),t.exports=function(){return o(i),i}):(r=new Array(16),t.exports=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),r[t]=e>>>((3&t)<<3)&255;return r})},{}],6:[function(e,t,n){var a=e(5),s=e(4);t.exports=function(e,t,n){var i=t&&n||0;"string"==typeof e&&(t="binary"===e?new Array(16):null,e=null);var r=(e=e||{}).random||(e.rng||a)();if(r[6]=15&r[6]|64,r[8]=63&r[8]|128,t)for(var o=0;o<16;++o)t[i+o]=r[o];return t||s(r)}},{4:4,5:5}],7:[function(e,t,n){"use strict";var r,o,i=e(9),a=e(40),s=new i;function c(e){if(o[e]){for(var t=arguments.length,n=Array(1<t?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];r[e].apply(r,n)}}t.exports=(r=s,o=a.getObjectMethodsMap(r),Object.getOwnPropertyNames(o).forEach(function(i){c[i]=function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return r[i].apply(r,t)}}),c.unwrap=function(){return r},c)},{40:40,9:9}],8:[function(e,t,n){"use strict";function i(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var r=(function(e,t,n){return t&&i(e.prototype,t),n&&i(e,n),e}(o,[{key:"register",value:function(){var e=this;this.callbacksCount+=1;var t=this.callbacksCount;return this.callbacks[t]=!1,function(){e.callbacks[t]||(e.callbacksReported+=1,e.callbacks[t]=!0),e.engaged&&e.callbacksReported>=e.callbacksCount&&e.complete()}}},{key:"engage",value:function(){this.engaged=!0,this.callbacksReported>=this.callbacksCount&&this.complete()}},{key:"complete",value:function(){try{this.finalCallback.call(void 0)}catch(e){}}}]),o);function o(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o),this.finalCallback="function"==typeof e?e:function(){},this.engaged=!1,this.callbacks={},this.callbacksCount=0,this.callbacksReported=0}t.exports=r},{}],9:[function(e,t,n){"use strict";var c=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],i=!0,r=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){r=!0,o=e}finally{try{!i&&s.return&&s.return()}finally{if(r)throw o}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var o=e(13),a=e(16),s=e(18),u=e(21),d=e(2),f=e(11),p=e(8),g=e(33).analyticsEnabled,y=e(44),h=y.setSentryUser,v=y.logEventError,m=e(19).createEventHandlerSandbox,w=e(20),b=w.mergeOptions,_=w.mergeDimensions,k=e(6),A=e(54).setWebViewUser,S=e(34),E=S.setCDT,T=S.setUser,O=e(10).SDK_TAGS,D=e(36),P=D.isClickstreamNewLaneEvent,I=D.isSelfServeEvent,C={track:"track",send:"send",page:"page",identify:"identify",setdim:"setdim",initialize:"initialize",error:"error",event:"event",selfServeEvent:"SelfServeEvent",setPayloadDefaults:"SetPayloadDefaults"},j=(i(x,[{key:"on",value:function(e,t){this.events.on(e,t)}},{key:"off",value:function(e,t){this.events.off(e,t)}},{key:"emit",value:function(e,t,n){this.events.emit(e,t,n)}},{key:"replayEventsFromStub",value:function(e){if(Array.isArray(e))for(var t=e.map(function(e){return e});t&&0<t.length;){var n,i=t.shift();Array.isArray(i)&&0<i.length&&(n=i.shift(),"function"==typeof Object.getPrototypeOf(this)[n]&&this[n].apply(this,function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(i)))}}},{key:"initialize",value:function(e,t,n){var i;g()&&(t&&t.anonymousId&&this.user.setInitialGuid(t.anonymousId),this.options=d({},t),this.applyOptions(this.options),this.visitor=n||new s,i={type:"initialize",properties:{},options:d({},this.options)},this.emit(C.initialize,this,i),this.initialized=!0,this.replayEventsFromStub(e),h(this.user.getCookieGuid()))}},{key:"track",value:function(e,t,n){var i,r=2<arguments.length&&void 0!==n?n:{};g()&&(this.applyOptions(r),(i={event:e||"",type:"track",properties:t||{},options:b(this.options,r)}).options.callTrace||(i.options.callTrace="DirectSDKCallWithoutUA-track.SDK-track"),this.handleUniqueEventId(this.options,i),this.addMetadata(i),r.newLaneEvent&&(i.messageId=k(),this.generateNewLaneEvent(i.options,i.messageId)),"function"==typeof i.options.hitCallback&&(i.cbManager=new p(i.options.hitCallback)),this.emit(C.track,this,i),i.cbManager&&i.cbManager.engage())}},{key:"event",value:function(e,t){var n,i,r=1<arguments.length&&void 0!==t?t:{};g()&&(this.applyOptions(r),e=e&&"object"===(void 0===e?"undefined":l(e))?e:{},n=b(this.options,r),P(e)||I(n)?this.eventNewLane(e,r):(i=d({},e,{category:e.eventObject,action:e.eventAction,label:e.eventObjectName,eventParentObjectName:e.eventParentObjectName}),r.newLaneEvent&&(r.newLaneEvent=null),this.track("event",i,r)))}},{key:"eventNewLane",value:function(t,e,n){try{var i=b(this.options,e),r={type:"event",properties:t&&"object"===(void 0===t?"undefined":l(t))?t:{},options:i,createdAt:(new Date).toISOString(),messageId:n};r.options.callTrace||(r.options.callTrace="DirectSDKCallWithoutUA-event.SDK-event"),"function"==typeof r.options.hitCallback&&(r.cbManager=new p(r.options.hitCallback)),I(i)?this.emit(C.selfServeEvent,this,r):this.emit(C.event,this,r),r.cbManager&&r.cbManager.engage()}catch(e){v({error:e,eventId:t.envelope.event_type_id})}}},{key:"page",value:function(e,t,n){var i,r=2<arguments.length&&void 0!==n?n:{};g()&&(i={category:e||"",type:"page",properties:t||{},options:b(this.options,r)},"object"===(void 0===e?"undefined":l(e))&&null!==e&&(i={category:"",type:"page",properties:e,options:b(this.options,t)}),i.options.callTrace||(i.options.callTrace="DirectSDKCallWithoutUA-page.SDK-page"),this.handleUniqueEventId(this.options,i),this.addMetadata(i),r.newLaneEvent&&(i.messageId=k(),this.generateNewLaneEvent(i.options,i.messageId)),"function"==typeof i.options.hitCallback&&(i.cbManager=new p(i.options.hitCallback)),this.applyOptions(i.options),this.emit(C.page,this,i),i.cbManager&&i.cbManager.engage())}},{key:"identify",value:function(e,t,n){var i;g()&&(this.applyOptions(n),i={userId:e||null,type:"identify",properties:t||{},options:b(this.options,n)},this.user.setId(e),this.emit(C.identify,this,i))}},{key:"setCDT",value:function(e){var r,t;g()&&(r="",Object.entries(e).forEach(function(e){var t=c(e,2),n=t[0],i=t[1];r+=n+"="+i+"&"}),t=new URLSearchParams(r),E(t,{isCDTManuallySet:!0}))}},{key:"setdim",value:function(e,t){var n,i,r;g()&&e&&"object"===(void 0===e?"undefined":l(e))&&((n=u(e)).cd68&&(i=new URL(n.cd68).searchParams,E(i,{isCDTFromCD68:!0})),delete n.cd200,this.dimensions=_({},this.dimensions,n),this.applyOptions(t),r={type:"setdim",properties:n||{},options:b(this.options,t)},this.emit(C.setdim,this,r))}},{key:"setPayloadDefaults",value:function(e){var t;g()&&e&&"object"===(void 0===e?"undefined":l(e))&&(t={type:"setPayloadDefaults",properties:e||{},options:this.options},this.emit(C.setPayloadDefaults,this,t))}},{key:"setprop",value:function(e,t){g()&&e&&"object"===(void 0===e?"undefined":l(e))&&this.setdim({sharedProps:e},t)}},{key:"send",value:function(e,t,n){var i;g()&&(t&&"object"===(void 0===t?"undefined":l(t))?("function"==typeof(i={type:"send",properties:t,options:b(this.options,n),guid:e}).options.hitCallback&&(i.cbManager=new p(i.options.hitCallback)),this.emit(C.send,this,i),i.cbManager&&i.cbManager.engage()):this.error(new Error("#send: payload is not a valid object")))}},{key:"dwell",value:function(e,t){var n;g()&&("string"==typeof e&&e?((n=this.dwellReporters[e])&&n.reset(),this.dwellReporters[e]=new f(this,t)):this.error(new Error("dwell: label cannot be empty")))}},{key:"dwellEnd",value:function(e){var t;g()&&("string"==typeof e&&e?(t=this.dwellReporters[e])&&t.report():this.error(new Error("dwell: label cannot be empty")))}},{key:"use",value:function(r){var e,o,a,s=this;"object"===(void 0===r?"undefined":l(r))&&null!==r?r.name?(e=String(r.name),this.plugins[e]?this.error('use: plugin "'+e+'" has been already registered'):(o=!1,a=Object.getPrototypeOf(r),Object.getOwnPropertyNames(C).forEach(function(e){var t=C[e],n="on"+t,i=r[n]||a[n];i&&"function"==typeof i&&(s.on(t,m(r,n)),o=!0)}),o&&(this.plugins[e]=!0))):this.error("use: plugin name cannot be empty"):this.error("use: plugin must be an object")}},{key:"unuse",value:function(r){var e,o,a=this;"object"===(void 0===r?"undefined":l(r))&&null!==r&&r.name&&(e=String(r.name),this.plugins[e]&&(o=Object.getPrototypeOf(r),Object.getOwnPropertyNames(C).forEach(function(e){var t=C[e],n="on"+t,i=r[n]||o[n];i&&"function"==typeof i&&a.off(t,m(r,n))}),delete this.plugins[e]))}},{key:"applyOptions",value:function(n){var i=this;g()&&n&&"object"===(void 0===n?"undefined":l(n))&&Object.getOwnPropertyNames(n).forEach(function(e){var t=n[e];switch(e){case"anonymousId":i.user.setAnonymousId(t);break;case"dimensions":t&&"object"===(void 0===t?"undefined":l(t))&&i.setdim(d({},t))}})}},{key:"generateNewCallTraceForNewLane",value:function(e){var t="",t=e.uaVersion?"UA-with-newLaneOption."+e.callTrace:e.callTrace;return t+=".SDK-generateNewLaneEvent.SDK-event"}},{key:"generateNewLaneEvent",value:function(e,t){var n,i,r,o,a=e.newLaneEvent,s={uniqueEventId:e.uniqueEventId};s.callTrace=this.generateNewCallTraceForNewLane(e),e.uaVersion&&(s.uaVersion=e.uaVersion),s.isGaPluginOn=Boolean(e&&e.integrations&&e.integrations.GaPlugin),Array.isArray(a)?(i=(n=c(a,2))[0],o=void 0===(r=n[1])?{}:r,this.eventNewLane(i,Object.assign(o,s),t)):this.eventNewLane(a,s,t)}},{key:"handleUniqueEventId",value:function(e,t){t.options.uniqueEventIdKey=e.uniqueEventIdKey||"dimension193",t.options.uniqueEventId=k()}},{key:"addMetadata",value:function(e){delete e.properties.cd200,delete e.properties.dimension200;var t=Array.isArray(e.options.newLaneEvent)?e.options.newLaneEvent[0]:e.options.newLaneEvent;t?(e.properties.cd200=t.envelope&&t.envelope.event_type_id,e.properties.sdkTag=O.all):e.properties.sdkTag=O.legacy,e.properties.isGaPluginOn=Boolean(e&&e.options&&e.options.integrations&&e.options.integrations.GaPlugin),e.properties.isAdBlockerOn=Boolean(e&&e.options&&e.options.isAdBlockerOn),e.properties.isGaBlocked=Boolean(e&&e.options&&e.options.isGaBlocked)}},{key:"error",value:function(e){var t={type:"error",error:e||new Error("Empty error")};this.emit(C.error,this,t)}}]),x);function x(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,x),this.events=new o,this.options={},this.dimensions={},this.plugins={},this.initialized=!1,this.user=new a,T(this.user),A(this.user),this.visitor=null,this.dwellReporters={}}t.exports=j},{10:10,11:11,13:13,16:16,18:18,19:19,2:2,20:20,21:21,33:33,34:34,36:36,44:44,54:54,6:6,8:8}],10:[function(e,t,n){"use strict";function i(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}var r={zga_z_guid:{domain:"zillow",key:"guid"},zga_z_uid:{domain:"zillow",key:"uid"},zga_zhl_guid:{domain:"zhl",key:"guid"},zga_zhl_uid:{domain:"zhl",key:"uid"}},o=Object.keys(r),a=Array.from(new Set(Object.values(r).map(function(e){return e.domain}))),s=new Set(["zg_dev_web","z_dev_web","zhl_dev_web","zrm_dev_web","pa_dev_web","zg_prod_web","z_prod_web","zhl_prod_web","zrm_prod_web","pa_prod_web","se_dev_web_nl","se_prod_web_nl","hp_dev_web_nl","hp_prod_web_nl"]),c=new Set(["zhl_stage_web_itrc","zhl_prod_web_itrc"]),l=new Set([].concat(i(s),i(c)));t.exports={BUILD_VERSION:"20240110-0c8df01",LIBRARY_NAME:"web",DATA_LAYER_NAME:"zga_data",DATA_LAYER_RETRIES:5,DATA_LAYER_RETRY_AFTER_MS:65,DATA_LAYER_BACKOFF_FACTOR:2,DATA_STORAGE_NAME:"zga_data",DATA_STORAGE_SCHEMA_VERSION:1,DATA_STORAGE_TABLE_NAME:"datalayer",ZG_ANONYMOUS_ID_COOKIE_NAME:"zg_anonymous_id",ZG_ANONYMOUS_ID_FORMAT:/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,EVENT_RESTRICTED_PROPERTY_KEY_NAMES:["config","context","createdAt","eventInstanceId","sentAt","zgAnonymousId","properties"],CROSS_DOMAIN_KEYS_MAP:r,CROSS_DOMAIN_QUERY_PARAMS:o,CROSS_DOMAIN_DATALAYER_KEYS:a,SDK_TAGS:{all:"ALL",new_lane:"NEW_LANE",legacy:"LEGACY"},WRITE_KEYS:l,CLICKSTREAM_WRITE_KEYS:s,SELF_SERVE_WRITE_KEYS:c,EVENTING_TYPES:{sspa:"sspa",clickstream:"clickstream"}}},{}],11:[function(e,t,n){"use strict";function i(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var r=(function(e,t,n){return t&&i(e.prototype,t),n&&i(e,n),e}(o,[{key:"pause",value:function(){this.dwellTime+=(new Date).getTime()-this.timerStart,this.timerStart=null}},{key:"resume",value:function(){this.timerStart=(new Date).getTime()}},{key:"report",value:function(){var t,n=this;this.timerStart&&(this.dwellTime+=(new Date).getTime()-this.timerStart,this.timerStart=null),this.dwellTime&&this.pageType?(t={dur:this.dwellTime,page_type:this.pageType},this.configData&&Object.getOwnPropertyNames(this.configData).forEach(function(e){t[e]=n.configData[e]}),this.ctx.track("dwell",t,{integrations:{All:!1,DspPlugin:!0}})):this.ctx.error(new Error("dwell timer was never started")),this.reset()}},{key:"reset",value:function(){this.dwellTime=0,this.timerStart=null,this.clearListeners()}},{key:"clearListeners",value:function(){window.removeEventListener("blur",this.pause),window.removeEventListener("focus",this.resume),window.removeEventListener("beforeunload",this.report)}}]),o);function o(e,t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o),this.ctx=e,this.dwellTime=0,this.timerStart=(new Date).getTime(),t&&t.pageType?this.pageType=t.pageType:(this.pageType="default",this.ctx.error(new Error("No required pageType provided in the config"))),t&&t.data&&(this.configData=t.data),this.pause=this.pause.bind(this),this.resume=this.resume.bind(this),this.report=this.report.bind(this),window.addEventListener("blur",this.pause),window.addEventListener("focus",this.resume),window.addEventListener("beforeunload",this.report)}t.exports=r},{}],12:[function(e,t,n){"use strict";var i=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function a(e){return"object"===(void 0===e?"undefined":o(e))&&!Array.isArray(e)&&!!e}var s=e(6),c=e(2),l=e(10),u=l.BUILD_VERSION,d=l.LIBRARY_NAME,f=l.SDK_TAGS,p=e(49).get,g=document,y=window,h={cd41:!0,cd42:!0,cd43:!0,cd44:!0,cd45:!0,cd46:!0,cd47:!0,cd48:!0,cd49:!0,cd50:!0,cd36:!0,cd37:!0,cd38:!0,cd39:!0,cd40:!0,cd56:!0,cd57:!0,cd58:!0,cd59:!0,cd60:!0,cd61:!0,cd62:!0,cd63:!0,cd64:!0,cd65:!0,cd164:!0,cd165:!0,cd166:!0,cd167:!0,cd168:!0,cd169:!0,cd170:!0,cd171:!0,cd172:!0,cd173:!0,cd174:!0,cd175:!0,cd176:!0,cd177:!0,cd178:!0,cd179:!0,cd180:!0,cd181:!0,cd182:!0,cd183:!0,cd184:!0,cd185:!0,cd186:!0,cd187:!0,cd188:!0},v=(i(m,[{key:"with",value:function(e,t){return this.payload[e]=t,this}},{key:"withContext",value:function(e){var t=0<arguments.length&&void 0!==e?e:"clickstream_trigger",n={},i={},r={};g&&(n.encoding_cd=g.characterSet,n.language_cd=(navigator&&(navigator.language||"")).toLowerCase(),n.full_user_agent_txt=navigator.userAgent,i.referral_url=g.referrer,i.screen_display_title_nm=g.title,i.trigger_reference_url=g.location.href),y&&(n.screen_density_txt=""+y.devicePixelRatio,y.screen&&(n.screen_resolution_txt=y.screen.width+"x"+y.screen.height,n.screen_orientation_nm=y.screen.orientation?y.screen.orientation.type:""),r.app_nm=y.location?y.location.hostname:"");var o=function(){var e=g.documentElement,t={width:y.innerWidth||0,height:y.innerHeight||0};return e&&(t.width=Math.max(e.clientWidth,t.width),t.height=Math.max(e.clientHeight,t.height)),t}();n.screen_height_txt=""+o.height,n.screen_width_txt=""+o.width,r.sdk_nm=d,r.sdk_version_id=u,n.device_timezone_cd=Intl.DateTimeFormat().resolvedOptions().timeZone;var a={app_info:r,device_info:n};return a[t]=i,this.sdkGeneratedFields=c({},this.sdkGeneratedFields,a),this}},{key:"withProperties",value:function(e){var t,n=e.experiment;return delete e.experiment,n&&a(n)&&(t=this.sdkGeneratedFields.uncategorized,this.sdkGeneratedFields.uncategorized=c(t,n)),this.mergeProps(e),this}},{key:"withUncategorized",value:function(n){var e=Object.keys(n).filter(function(e){return e in h});if(0===e.length)return this;var t=e.reduce(function(e,t){return e[t]=n[t],e},{});return this.sdkGeneratedFields.uncategorized=c(this.sdkGeneratedFields.uncategorized,t),this}},{key:"withUniqueEventId",value:function(e){return this.sdkGeneratedFields.uncategorized=c({},this.sdkGeneratedFields.uncategorized,e),this}},{key:"withCDTMetadata",value:function(e){return this.sdkGeneratedFields.uncategorized=c({},this.sdkGeneratedFields.uncategorized,e),this}},{key:"withMetadataFromOptions",value:function(e){var t={apiKey:e.apiKey,writeKey:e.writeKey,callTrace:e.callTrace,isAdBlockerOn:e.isAdBlockerOn,isGaBlocked:e.isGaBlocked,isGaPluginOn:e.isGaPluginOn};return e.uaVersion&&(t.uaVersion=e.uaVersion),e.callTrace&&(e.callTrace.includes("SDK-generateNewLaneEvent")?t.sdkTag=f.all:t.sdkTag=f.new_lane),this.sdkGeneratedFields.uncategorized=c({},this.sdkGeneratedFields.uncategorized,t),this}},{key:"withMetadataFromDataLayer",value:function(){var e=p(["sdk_previous_url"],{doSynchronous:!0}).sdk_previous_url;return this.sdkGeneratedFields.clickstream_trigger&&!this.sdkGeneratedFields.clickstream_trigger.referral_url&&e&&(this.sdkGeneratedFields.clickstream_trigger.referral_url=e,this.sdkGeneratedFields.uncategorized.isSdkRefUrl=!0),this}},{key:"withUser",value:function(e){if(!e)return this;var t=e.getId(),n={guid:e.getCookieGuid(),zuid:t};return this.sdkGeneratedFields.user_info=n,this.sdkGeneratedFields.uncategorized.isGuidFromInitialize=e.getIsGuidFromInitialize(),this}},{key:"mergeProps",value:function(t){var n=c({},this.payload);Object.keys(t).forEach(function(e){a(t[e])&&a(n[e])&&Object.prototype.hasOwnProperty.call(n,e)?n[e]=c({},n[e],t[e]):n[e]=t[e]}),this.payload=n}},{key:"toJson",value:function(){return this.mergeProps(this.sdkGeneratedFields),0===Object.entries(this.payload.uncategorized).length&&delete this.payload.uncategorized,c({},this.payload)}}]),m);function m(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,m),this.payload={},this.sdkGeneratedFields={envelope:{event_uuid:e||s()},uncategorized:{}}}t.exports=v},{10:10,2:2,49:49,6:6}],13:[function(e,t,n){"use strict";function i(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var r=(function(e,t,n){return t&&i(e.prototype,t),n&&i(e,n),e}(o,[{key:"emit",value:function(n){for(var e=arguments.length,i=Array(1<e?e-1:0),t=1;t<e;t++)i[t-1]=arguments[t];var r=this.events[n];r&&r.forEach(function(e){var t;e&&e.sandbox&&"function"==typeof e.sandbox?(t=e.sandbox).call.apply(t,[void 0].concat(i)):console&&console.error&&console.error("No appropriate handler for fired event",n)})}},{key:"on",value:function(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}},{key:"off",value:function(e,t){var n,i;this.events[e]&&((i=(n=this.events[e]).findIndex(function(e){return e.pluginName===t.pluginName&&e.handlerName===t.handlerName}))<0||i>=n.length||n.splice(i,1))}}]),o);function o(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o),this.events={}}t.exports=r},{}],14:[function(e,t,n){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=function(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),e};function o(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var a=e(6),s=e(46),c=e(2),l=document,u=window,d=(i(f,[{key:"withContext",value:function(e){var t=c({},e),n={library:{name:"analytics.js",version:"20240110-0c8df01"},page:{}};l&&(n.encoding=l.characterSet||l.charset,n.language=(navigator&&(navigator.language||"")).toLowerCase(),n.viewportSize=function(){var e=l.documentElement;if(e){var t=Math.max(e.clientWidth,u.innerWidth||0),n=Math.max(e.clientHeight,u.innerHeight||0);return t+"x"+n}return""}(),n.userAgent=navigator.userAgent,n.page=c({},n.page,{path:l.location.pathname,referrer:l.referrer,search:l.location.search,title:l.title,url:l.location.href})),u&&u.screen&&(n.screenColors=u.screen.colorDepth+"-bit",n.screenResolution=u.screen.width+"x"+u.screen.height);var i=n.page.search;return i&&!n.campaign&&(n.campaign=s(i)),"object"===(void 0===t?"undefined":r(t))&&null!==t&&(n.page=c({},n.page,t.page),delete t.page),this.json.context=c({},this.json.context,n,t),this}},{key:"withProperties",value:function(e){return this.json.properties=c({},this.json.properties,e),this}},{key:"withUaDataInProps",value:function(e,t){return t.uaVersion&&(e.uaVersion=t.uaVersion),e.callTrace=t.callTrace,delete e.uaMethodName,this}},{key:"withTealiumId",value:function(e){if(!e)return this;var t=e.getTealiumId();return t&&(this.json.properties=c({},this.json.properties,{tealiumId:t})),this}},{key:"withEventData",value:function(e){return this.json.eventData=c({},this.json.eventData,e),this}},{key:"withUser",value:function(e){if(!e)return this;var t=e.getId(),n=e.getAnonymousId();return t&&(this.json.userId=t),n&&(this.json.anonymousId=n),this}},{key:"toJson",value:function(){return c({},this.json)}}]),f);function f(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f);var t=e||{};t.integrations=t.integrations||{},t.context=t.context||{},t.properties=t.properties||{},t.eventData=t.eventData||{};var n=(new Date).toJSON();this.json={timestamp:n,sentAt:n,messageId:a()},this.json=c({},this.json,t)}t.exports=d},{2:2,46:46,6:6}],15:[function(e,t,n){"use strict";t.exports={FULL_WK_BLOCKLIST_DSP:["test_key_1"],CONDITIONAL_WK_ALLOWLIST_DSP:{test_key_2:{test_category:{test_action:!0},test_category_2:!0},z_test:{rentalsrp:{propertyimpression:!0},rentalhdp:{propertyimpression:!0},rentalbdp:{propertyimpression:!0},search:{search:!0},"followed homes":{"follow home":!0},unify:!0,"rmx aitools fixtures":!0,"photo loc tool":!0,"rmx aitools floor plan on map":!0},z_prod:{rentalsrp:{propertyimpression:!0},rentalhdp:{propertyimpression:!0},rentalbdp:{propertyimpression:!0},search:{search:!0},"followed homes":{"follow home":!0},unify:!0,"rmx aitools fixtures":!0,"photo loc tool":!0,"rmx aitools floor plan on map":!0}}}},{}],16:[function(e,t,n){"use strict";var i=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var o=e(6),a=e(43),s=a.getCookie,c=a.setCookie,l=e(39).nullOrString,u=e(33).analyticsEnabled,d="zjs_anonymous_id",f="zjs_user_id";function p(){return"SDK-"+o()}function g(){var e=function(){if(!window||!window.location)return null;var e=window.location.hostname;return e.includes("zillow.")?"zguid":e.includes("zillowhomeloans.")?"zhlguid":null}();if(!e)return null;var t=s(e,!1);if(!t)return p();var n=t.match(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/);return Array.isArray(n)&&n[0]?n[0]:t}var y=(i(h,[{key:"getCookieGuid",value:function(){return this._guidFromCookie?this._guidFromCookie:this._anonymousId}},{key:"setInitialGuid",value:function(e){this._guidFromCookie&&this._guidFromCookie.includes("SDK-")&&(this._guidFromCookie=e,this._isGuidFromInitialize=!0)}},{key:"getIsGuidFromInitialize",value:function(){return this._isGuidFromInitialize}},{key:"getAnonymousId",value:function(){return this._anonymousId}},{key:"setAnonymousId",value:function(e){this._anonymousId=void 0===e?this._anonymousId||p():e||p(),u()&&c(d,this._anonymousId)}},{key:"getId",value:function(){return this._id}},{key:"setId",value:function(e){"string"!=typeof e&&"number"!=typeof e&&null!==e||(this._id=l(e),u()&&c(f,this._id))}},{key:"getTealiumId",value:function(){return this._tealiumId}},{key:"_extractTealiumId",value:function(){var t=null,e=s("utag_main",!1);if(e&&"string"==typeof e)try{(e=e.split("$")).some(function(e){return!!e.startsWith("v_id")&&(t=e.split(":")[1],!0)})}catch(e){}return t}}]),h);function h(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,h),this._id=null,this._anonymousId=void 0,this._tealiumId=null,this._isGuidFromInitialize=!1;var e=u()?s(d):"",t=u()?s(f):null,n=u()?this._extractTealiumId():null;this._guidFromCookie=u()?g():null,this.setAnonymousId(this._guidFromCookie?this._guidFromCookie:e),t&&(this._id=t),this.setId(this._id),n&&(this._tealiumId=n)}t.exports=y},{33:33,39:39,43:43,6:6}],17:[function(e,t,n){"use strict";var l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=e(10).SELF_SERVE_WRITE_KEYS;function a(){return navigator.webdriver||document.$cdc_asdjflasutopfhvcZLmcfl_||document.documentElement.getAttribute("webdriver")}function s(e,t){var n,i,r,o,a,s,c,l,u,d,f,p,g,y,h,v,m,w,b=S("sdk_tech_spec"),_=e.eventTypeId,k=e.spec,A=[];b&&(n=b.contextualBlocks,r=(i=k.triggerBlock||{}).triggerObjects,o=i.triggerLocations,a=i.triggerSources,s=i.triggerType,c=k.semanticBlock.semanticEventName,l=k.contextualBlocks||[],f=(d=(u=t||{}).clickstream_trigger||{}).trigger_object_nm,p=d.trigger_source_nm,g=d.trigger_location_nm,y=d.trigger_type_nm,h=(u.semantic||{}).semantic_event_nm,o&&Array.isArray(o)&&(v=o.join(", "),A.push({condition:g&&!o.includes(g),message:"Web SDK Validation: trigger_location_nm '"+g+"' is not in the ENUM in event registry. Available trigger location nms are ["+v+"] for event type id "+_+"."}),A.push({condition:!g,message:"Web SDK Validation: trigger_location_nm is required. Please select one from these available trigger location nms ["+v+"] for event type id "+_+"."})),r&&Array.isArray(r)&&(m=r.join(", "),A.push({condition:f&&!r.includes(f),message:"Web SDK Validation: trigger_object_nm '"+f+"' is not in the ENUM in event registry. Available trigger object nms are ["+m+"] for event type id "+_+"."}),A.push({condition:!f,message:"Web SDK Validation: trigger_object_nm is required. Please select one from these available trigger object nms ["+m+"] for event type id "+_+"."})),a&&Array.isArray(a)&&(w=a.join(", "),A.push({condition:p&&!a.includes(p),message:"Web SDK Validation: trigger_source_nm '"+p+"' is not in the ENUM in event registry. Available trigger source nms are ["+w+"] for event type id "+_+"."}),A.push({condition:!p,message:"Web SDK Validation: trigger_source_nm is required. Please select one from these available trigger source nms ["+w+"] for event type id "+_+"."})),s&&(A.push({condition:y&&y!==s,message:"Web SDK Validation: trigger_type_nm '"+y+"' is not the same as the one in event registry. Please change it to '"+s+"' for event type id "+_+"."}),A.push({condition:!y,message:"Web SDK Validation: trigger_type_nm is required. Please change it to '"+s+"' for event type id "+_+"."})),c&&(A.push({condition:h&&h!==c,me
ssage:"Web SDK Validation: semantic_event_nm '"+h+"' is not the same as the one in event registry. Please change it to '"+c+"' for event type id "+_+"."}),A.push({condition:!h,message:"Web SDK Validation: semantic_event_nm is required. Please change it to '"+c+"' for event type id "+_+"."})),n&&Object.keys(t).forEach(function(e){var t;n.includes(e)&&(t=l.join(", "),A.push({condition:!l.includes(e),message:"Web SDK Validation: the contextual block '"+e+"' is not registered in the event registry. Available contextual blocks are ["+t+"] for event type id "+_+"."}),A.push({condition:0===l.length,message:"Web SDK Validation: the contextual block '"+e+"' exists in the payload but there are no registered contextual blocks in event registry for event type id "+_+"."}))}),T(A))}function E(){return window.location.hostname.includes("localhost")}function d(e,t){return!(!t||"string"!=typeof e||e.includes("sdk")||!t.match(/^[0-9a-f]{32}$/))}function S(e){var t=localStorage.getItem(e);if(!t)return null;var n=JSON.parse(t);return(new Date).getTime()>n.expiration?(localStorage.removeItem(e),null):n.value}function c(e){for(var t=/,(?=(?:(?:[^"]*"){2})*[^"]*$)/g,n=e.split(/\r?\n(?=(?:(?:[^"]*"){2})*[^"]*$)/g),i=n[0].split(t).map(function(e){return e.replace(/(^"|"$)/g,"")}),r=[],o=1;o<n.length;o++){for(var a=n[o].split(t).map(function(e){return e.replace(/(^"|"$)/g,"")}),s={},c=0;c<i.length;c++)s[i[c]]=a[c].trim();r.push(s)}return r}function T(e,t,n,i){var r=1<arguments.length&&void 0!==t?t:"",o=2<arguments.length&&void 0!==n?n:{},a=3<arguments.length&&void 0!==i&&i;e.filter(function(e){return!!e.condition}).forEach(function(e){var t;if(r?e.message+=" "+(a?"cd200":"event_type_id")+": "+r+".":o&&0<Object.keys(o).length&&o.trigger_location_nm&&(t="\n                trigger_location: "+o.trigger_location_nm+", \n                trigger_type: "+o.trigger_type_nm+",\n                trigger_object: "+o.trigger_object_nm+",\n                trigger_source: "+o.trigger_source_nm,e.message=e.message+" "+t),e.message+=" Please see https://docs.google.com/document/d/1cnemyXGOArRj2ijkGvm46uM0P0sxr7Tsls5RH3bo_rY for more information.",e.warning?console.warn(e.message):console.error(e.message),e.throwError)throw new Error(e.message)})}t.exports={isStaging:function(e){return e.options&&e.options.writeKey?!e.options.writeKey.includes("prod"):e.options&&e.options.apiHost&&!e.options.apiHost.includes("e.zg-api.com")&&!e.options.apiHost.includes("cs.zg-api.com")},checkEventRegistration:function(n,i){var e,r,t,o;n&&window.fetch&&!a()&&(e=localStorage.getItem("event_registry_data"),r=e?JSON.parse(e):{},t=(new Date).getTime(),o="Web SDK Validation: The event type id "+n+" is not registered in the event registry. If it was registered within the last hour, please check again after one hour. Please see https://docs.google.com/document/d/1cnemyXGOArRj2ijkGvm46uM0P0sxr7Tsls5RH3bo_rY for more information.",r[n]&&t<r[n].expiration?(r[n].isRegistered||console.error(o),r[n].data&&r[n].data.spec&&i&&s(r[n].data,i)):window.fetch("https://clickstream-event-debugging-api-prod.corp.zgcp-consumer-prod-k8s.zg-int.net/v4/stage_validation/"+n).then(function(e){if(500===e.status)throw new Error("Web SDK Validation: Something went wrong with the server while checking event registration for "+n+". Please try again later.");return e.ok?e.json():null}).then(function(e){var t=!0;e&&(!e||e.eventTypeId)||(t=!1,console.error(o)),e&&e.eventTypeId&&e.spec&&i&&s(e,i);r[n]={isRegistered:t,expiration:(new Date).getTime()+36e5,data:e},localStorage.setItem("event_registry_data",JSON.stringify(r))}).catch(function(e){return console.log(e)}))},uaVersionValidation:function(){T([{condition:!(0<arguments.length&&void 0!==arguments[0]?arguments[0]:""),message:"Web SDK Validation: You are currently using an unknown old UA version or calling SDK directly without UA. Please get the latest UA version!"}],arguments[1],arguments[2],3<arguments.length&&void 0!==arguments[3]&&arguments[3])},numberOfRetriesValidation:function(e){T([{condition:1<e,message:"numberOfRetries is greater than 1! Current retry count is "+e,warning:!0}])},isValidExpectedCd1:d,dualTaggedGaValidation:function(e,t){var n=t.user.getId(),i=t.user.getCookieGuid().replace(/[^a-zA-Z0-9]/g,"").toLowerCase(),r=n?i+"/"+n:i,o=d(r,i),a=e||{},s=a.dimension1,c=a.dimension198,l=a.dimension200,u=a.dimension193;T([{condition:!e,message:"Web SDK Validation: Props in dual tagged GA should not be empty!"},{condition:!E()&&o&&s!==r,message:"Web SDK Validation: CD1 in GA is not the same as the valid expected CD1!"},{condition:!u,message:"Web SDK Validation: CD193 in GA is not populated! It must have an UUID!"},{condition:c&&"string"==typeof c&&!c.includes("sdkTag"),message:"Web SDK Validation: sdkTag is not present in CD198!"},{condition:c&&"string"==typeof c&&!c.includes("sdkVersion"),message:"Web SDK Validation: sdkVersion is not present in CD198!"},{condition:c&&"string"==typeof c&&!c.includes("callTrace"),message:"Web SDK Validation: callTrace is not present in CD198!"},{condition:!l,message:"Web SDK Validation: CD200 is not present in GA even though it is dual tagged!"}],l,{},!0)},newLaneValidation:function(e){var t=e||{},n=t.clickstream_trigger,i=t.exposure,r=t.client_ts,o=t.uncategorized||{},a=o.sdkTag,s=o.callTrace,c=o.cd193,l=t.envelope||{},u=l.event_type_id,d=l.event_client_start_dtm,f=l.event_uuid,p=t.user_info||{},g=p.zuid,y=p.guid,h=(t.app_info||{}).sdk_version_id,v=n||{},m=v.trigger_location_nm,w=v.trigger_type_nm,b=v.trigger_object_nm,_=v.trigger_source_nm,k=v.trigger_reference_url,A=(t.semantic||{}).semantic_event_nm,S="";y&&(S=y.replace(/[^a-zA-Z0-9]/g,"").toLowerCase()),T([{condition:!e,message:"Web SDK Validation: Payload in new lane should not be empty!"},{condition:u&&!Number.isInteger(Number(u)),message:"Web SDK Validation: envelope.event_type_id must be a integer!"},{condition:!u,message:"Web SDK Validation: envelope.event_type_id is not present in the new lane payload!",throwError:!0},{condition:d&&"string"==typeof d&&!d.match(/^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]+)?(Z)?$/),message:"Web SDK Validation: envelope.event_client_start_dtm is not formatted correctly!"},{condition:!d,message:"Web SDK Validation: envelope.event_client_start_dtm is not present in the new lane payload!"},{condition:f&&"string"==typeof f&&!f.match(/^[0-9A-F]{8}-[0-9A-F]{4}-[4][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i),message:"Web SDK Validation: envelope.event_uuid is not formatted correctly!"},{condition:!f,message:"Web SDK Validation: envelope.event_uuid is not present in the new lane payload!"},{condition:!r,message:"Web SDK Validation: client_ts is not present in the new lane payload!"},{condition:r&&"string"==typeof r&&!r.match(/^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]+)?(Z)?$/),message:"Web SDK Validation: client_ts is not formatted correctly!"},{condition:!A,message:"Web SDK Validation: semantic.semantic_event_nm is not present!"},{condition:!g,message:"Web SDK Validation: user_info.zuid is not present in user_info! It might be because the user is not logged in.",warning:!0},{condition:g&&"string"==typeof g&&!g.startsWith("X1-"),message:"Web SDK Validation: user_info.zuid must start with X1-"},{condition:!y,message:"Web SDK Validation: user_info.guid is not present in user_info!"},{condition:!E()&&S&&!S.match(/^[0-9a-f]{32}$/),message:"Web SDK Validation: user_info.guid is not in the correct format!"},{condition:!E()&&y&&"string"==typeof y&&y.includes("SDK-"),message:"Web SDK Validation: user_info.guid is generated by SDK!"},{condition:!h,message:"Web SDK Validation: app_info.sdk_version_id is not present!."},{condition:!i&&!m,message:"Web SDK Validation: clickstream_trigger.trigger_location_nm is not present in the new lane payload!"},{condition:!i&&!w,message:"Web SDK Validation: clickstream_trigger.trigger_type_nm is not present in the new lane payload!"},{condition:!i&&!b,message:"Web SDK Validation: clickstream_trigger.trigger_object_nm is not present in the new lane payload!"},{condition:!i&&!_,message:"Web SDK Validation: clickstream_trigger.trigger_source_nm is not present in the new lane payload!"},{condition:!k,message:"Web SDK Validation: clickstream_trigger.trigger_reference_url is not present in the new lane payload!"},{condition:k&&"string"==typeof k&&k.length<14,message:"Web SDK Validation: clickstream_trigger.trigger_reference_url length should be at least 14 characters"},{condition:a&&"ALL"===a&&!c,message:"Web SDK Validation: uncategorized.cd193 is not present in new lane even though it is dual tagged!"},{condition:!s,message:"Web SDK Validation: callTrace is not present in uncategorized in new lane payload!"}],u,n)},validateAgainstTechSpecCsv:function(a){var t,n,i,e,r,s,c,o=S("sdk_tech_spec");o&&(t=o.structArray||[],n=o.attributeDataTypesObject||{},i=Object.keys(n)||[],e=o.deprecatedArray||[],r=[{attributeName:"uncategorized",value:a.uncategorized}],s=[],Object.keys(a).forEach(function(e){var t=a[e];"object"!==(void 0===t?"undefined":l(t))||null===t||Array.isArray(t)||"uncategorized"===e?r.push({attributeName:e,value:t}):(Object.keys(a[e]).forEach(function(e){return r.push({attributeName:e,value:t[e]})}),s.push(e))}),c=a.envelope&&a.envelope.event_type_id?"- event_type_id: "+a.envelope.event_type_id:"",r.forEach(function(e){i.includes(e.attributeName)?e.value&&function(e,t,n){var i=n.attributeName,r=t[i];if(r){var o=n.value,a=void 0===o?"undefined":l(o);switch(r){case"string":"string"!==a&&console.error("Web SDK Validation: The attribute name "+i+" is expected to be a string but it is "+a+". Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+e);break;case"int":case"long":Number.isInteger(o)||console.error("Web SDK Validation: The attribute name "+i+" is expected to be an integer but it is not. Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+e);break;case"boolean":"boolean"!==a&&console.error("Web SDK Validation: The attribute name "+i+" is expected to be a boolean but it is "+a+". Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+e);break;case"object":"object"===a&&null!==o&&!Array.isArray(o)||console.error("Web SDK Validation: The attribute name "+i+" is expected to be an object but it is not. Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+e);break;case"array":Array.isArray(o)||console.error("Web SDK Validation: The attribute name "+i+" is expected to be an array but it is "+a+". Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+e);break;case"double":case"float":"number"!==a&&console.error("Web SDK Validation: The attribute name "+i+" is expected to be a float but it is not. Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+e)}}}(c,n,e):console.error("Web SDK Validation: The attribute name "+e.attributeName+" does not exist in tech spec. Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+c)}),s.forEach(function(e){t.includes(e)||console.error("Web SDK Validation: The struct name "+e+" does not exist in tech spec. Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+c)}),e.forEach(function(e){var t,n=e.struct,i=e.attribute,r=a,o=!1;n&&s.includes(n)&&(r=a[n],o=!0,i||console.error("Web SDK Validation: The struct name "+n+" is deprecated. Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+c)),i&&r[i]&&(t=o?"The attribute name "+i+" is deprecated inside the struct "+n:"The attribute name "+i+" is deprecated",console.error("Web SDK Validation: "+t+". Please refer to the tech spec sheet and make changes accordingly - https://docs.google.com/spreadsheets/d/1Eq-CPZYPBLKiXKhnoXFDYMqVY_kKwmtrEiAfCstdGsE/edit#gid=1608965010&fvid=296156208 "+c))}))},setItemWithExpiration:function(e,t,n){var i=60*n*1e3,r={value:t,expiration:(new Date).getTime()+i};localStorage.setItem(e,JSON.stringify(r))},csvToJson:c,getTechSpecAttributes:S,isSelfServeWriteKey:function(e){return e&&"string"==typeof e&&i.has(e)},isSelenium:a,errorAboutInvalidWriteKey:function(e,t){if(!e)throw new Error(t?"Web SDK Validation: A valid write key must be provided! event_type_id: "+t:"Web SDK Validation: A valid write key must be provided! Please see https://docs.google.com/document/d/1cnemyXGOArRj2ijkGvm46uM0P0sxr7Tsls5RH3bo_rY for more information.");console.error("Web SDK Validation: The write key "+e+" is not valid. Please see https://docs.google.com/document/d/1cnemyXGOArRj2ijkGvm46uM0P0sxr7Tsls5RH3bo_rY for more information.")},checkExposureEventRegistration:function(i){var e=localStorage.getItem("exposure_event_registration_data"),r=e?JSON.parse(e):null,t=(new Date).getTime(),n=localStorage.getItem("tech_spec_csv_access_token"),o="Web SDK Validation: The event type id "+i+" is not a registered exposure event. If it was registered within the last hour, please check again after one hour.  Please see https://docs.google.com/document/d/1cnemyXGOArRj2ijkGvm46uM0P0sxr7Tsls5RH3bo_rY for more information.";if(i&&window.fetch&&!a())if(r&&t<r.expiration)r.eventIds.includes(i)||console.error(o);else{if(!n)return;window.fetch("https://gitlab.zgtools.net/api/v4/projects/40451/repository/files/csv%2Fzillow%2Fexposure_events.csv/raw?ref=main",{headers:{"PRIVATE-TOKEN":n}}).then(function(e){return e.text()}).then(function(e){var t=c(e),n=[];t.forEach(function(e){"web"===e.platform&&n.push(e.event_type_id)}),n.includes(i)||console.error(o);r={eventIds:n,expiration:(new Date).getTime()+36e5},localStorage.setItem("exposure_event_registration_data",JSON.stringify(r))}).catch(function(e){return console.log(e)})}}}},{10:10}],18:[function(e,t,n){"use strict";var i=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var o=e(6),a=e(43),s=a.getCookie,c=a.setCookie,l=e(33).analyticsEnabled,u=e(10),d=u.ZG_ANONYMOUS_ID_COOKIE_NAME,f=u.ZG_ANONYMOUS_ID_FORMAT,p=(i(g,[{key:"getZgAnonymousId",value:function(){return this.zgAnonymousId}},{key:"setZgAnonymousId",value:function(e){void 0===e||"string"!=typeof e||"string"==typeof e&&!f.test(e)?this.zgAnonymousId=this.generateZgAnonymousId():this.zgAnonymousId=e,l()&&c(d,this.zgAnonymousId)}},{key:"generateZgAnonymousId",value:function(){return o()}}]),g);function g(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,g),this.zgAnonymousId=void 0;var e=l()?s(d):"";this.setZgAnonymousId(e)}t.exports=p},{10:10,33:33,43:43,6:6}],19:[function(e,t,n){"use strict";var l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},u=e(55),d=e(44);t.exports={createEventHandlerSandbox:function(s,c){return{pluginName:s.name,handlerName:c,sandbox:function(t,n){var e,i,r=n&&n.options&&"object"===l(n.options.integrations)&&n.options.integrations,o=!0;if(r&&(e=s&&s.name,i=!1!==r.All,o=void 0!==r[e]?!1!==r[e]:i),o)try{s[c].bind(s)(t,n)}catch(e){var a=s.name+": "+c+" error";"NewLanePlugin"===s.name&&"onevent"===c?(0,d.logEventError)({error:e,title:a,eventId:n.properties.envelope.event_type_id}):(0,u.logError)(a,e),t&&"function"==typeof t.error&&t.error(e)}}}}}},{44:44,55:55}],20:[function(e,t,n){"use strict";var r=e(2);t.exports={mergeOptions:function(){for(var n={},e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];return t.forEach(function(e){var t=r({},n);((n=r({},n,e)).integrations||t.integrations)&&(n.integrations=r({},t.integrations,n.integrations))}),n},mergeDimensions:function(){for(var n={},e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];return t.forEach(function(e){var t=r({},n);((n=r({},n,e)).sharedProps||t.sharedProps)&&(n.sharedProps=r({},t.sharedProps,n.sharedProps)),(n.sharedParams||t.sharedParams)&&(n.sharedParams=r({},t.sharedParams,n.sharedParams))}),n}}},{2:2}],21:[function(e,t,n){"use strict";var o=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],i=!0,r=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){r=!0,o=e}finally{try{!i&&s.return&&s.return()}finally{if(r)throw o}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=/^dimension(\d+)$/;t.exports=function(i){if(!i||"object"!==(void 0===i?"undefined":a(i)))return{};var r={};return Object.getOwnPropertyNames(i).forEach(function(e){var t,n=s.exec(e);n?(t=o(n,2)[1],r["cd".concat(t)]=i[e]):r[e]=i[e]}),r}},{}],22:[function(e,t,n){"use strict";var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function r(){return"object"===i(window.ZMOB_nativeAPI)&&null!==window.ZMOB_nativeAPI||"object"===i(window.nativeClickstreamAPI)&&null!==window.nativeClickstreamAPI}t.exports={isWebView:r,isZillowWebView:r}},{}],23:[function(e,t,n){"use strict";var c=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],i=!0,r=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){r=!0,o=e}finally{try{!i&&s.return&&s.return()}finally{if(r)throw o}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},l=e(55).polyfillPromiseFinallyIfNotExist,u=e(44).logEventError,d=e(55).logError;function o(e,t){var n,r,i=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{},o=i.callback,a=i.eventId,s=i.headers;window&&window.fetch?(l(),n={method:"POST",body:JSON.stringify(t),priority:"low"},s&&(n.headers=s),window.fetch(e,n).catch(function(e){console&&console.error&&console.error(e),a?u({title:"Error trying to send event (Fetch)",error:e,eventId:a}):d("Error trying to send event (Fetch)",e)}).finally(function(){"function"==typeof o&&o()})):(r=new XMLHttpRequest,"function"==typeof o&&(r.onreadystatechange=function(){r.readyState===XMLHttpRequest.DONE&&o()}),r.open("POST",e),s&&Object.entries(s).forEach(function(e){var t=c(e,2),n=t[0],i=t[1];r.setRequestHeader(n,i)}),r.send(JSON.stringify(t)))}t.exports={sendBeacon:function(e){var t,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},i=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{},r=i.callback;"function"==typeof navigator.sendBeacon?(t=navigator.sendBeacon(e,JSON.stringify(n)))&&"function"==typeof r?r():t||o(e,n,i):o(e,n,i)},post:o}},{44:44,55:55}],24:[function(e,t,n){"use strict";var i=e(23),s=i.post,c=i.sendBeacon,l=e(44).logEventError,u=e(55).logError,d=e(17).numberOfRetriesValidation,f=2,p=500,g=!1;function y(){var e;return!(-1<(navigator&&navigator.userAgent||"").indexOf("PhantomJS/")||(e=navigator&&navigator.userAgent||"",-1<(navigator&&navigator.appVersion||"").indexOf("MSIE")||-1<e.indexOf("Trident/")))&&(navigator&&"function"==typeof navigator.sendBeacon)}function h(t,n,i){var e=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{},r=e.callback,o=e.eventId,a=e.headers;if(t&&n)try{(!y()||a||g?s:c)(t,n,e)}catch(e){console&&console.error&&console.error(e),0<i?setTimeout(function(){var e=f-(i-1);n.uncategorized&&(n.uncategorized.numberOfRetries=e),n.properties&&n.properties.callTrace&&(n.properties.numberOfRetries=e),!t||"string"!=typeof t||t.includes("e.zg-api.com")||t.includes("cs.zg-api.com")||d(e),h(t,n,i-1,r)},p):(o?l({title:"Error trying to send event",error:e,eventId:o}):u("Error trying to send event",e),"function"==typeof r&&r())}else"function"==typeof r&&r()}t.exports={sendPayload:function(e,t){h(e,t,f,2<arguments.length&&void 0!==arguments[2]?arguments[2]:{})},sendPayloadWithRetry:h,setIsAdblockEnabled:function(e){g=e}}},{17:17,23:23,44:44,55:55}],25:[function(e,t,n){"use strict";function i(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function r(e,t,n){console.groupCollapsed("%c %s %o","color: blue",e,n),console.log("ctx %s",t),console.log(JSON.stringify(n)),console.groupEnd()}var o=(function(e,t,n){return t&&i(e.prototype,t),n&&i(e,n),e}(a,[{key:"ontrack",value:function(e,t){r("ontrack",e,t)}},{key:"onsend",value:function(e,t){r("onsend",e,t)}},{key:"onpage",value:function(e,t){r("onpage",e,t)}},{key:"onidentify",value:function(e,t){r("onidentify",e,t)}},{key:"onsetdim",value:function(e,t){r("onsetdim",e,t)}},{key:"oninitialize",value:function(e,t){r("oninitialize",e,t)}},{key:"onerror",value:function(e,t){console.error(t)}},{key:"onevent",value:function(e,t){r("onevent",e,t)}}]),a);function a(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,a),this.name="DebugPlugin"}t.exports=o},{}],26:[function(e,t,n){"use strict";var i=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function u(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var d=e(14),f=e(24).sendPayload,o=e(21),a=e(20),p=a.mergeOptions,s=a.mergeDimensions,c=e(45),g=c.shouldAllowTrackDSP,l=c.shouldAllowPageDSP,y=(i(h,[{key:"oninitialize",value:function(e,t){this.options=p(this.options,t.options)}},{key:"ontrack",value:function(e,t){var n=p(this.options,t.options),i={type:"track",event:t.event||void 0,writeKey:n.apiKey,integrations:n.integrations};t.messageId&&(i.messageId=t.messageId);var r=new d(i);r.withUser(e.user),r.withTealiumId(e.user),r.withContext();var o,a,s=this.mergePropertiesWithDimensions(t.properties,e.dimensions),c=s.category,l=s.action;g(n.apiKey,c,l)&&(t.options&&t.options.uniqueEventId&&t.options.uniqueEventIdKey&&(o=u({},t.options.uniqueEventIdKey,t.options.uniqueEventId),s=this.mergePropertiesWithDimensions(o,s)),"category"in s&&"action"in s&&(r.withEventData({eventObject:s.category,eventAction:s.action,eventObjectName:s.label,eventParentObjectName:s.eventParentObjectName||"legacy"}),delete s.category,delete s.action,delete s.label,delete s.eventParentObjectName),r.withUaDataInProps(s,n),r.withProperties(s),a=this.clickUrl(n.apiKey,e.user.getAnonymousId(),n.secure,n.apiHost,n.apiUrlPath),t.cbManager?f(a,r.toJson(),{callback:t.cbManager.register()}):f(a,r.toJson()))}},{key:"onpage",value:function(e,t){var n,i,r,o,a,s,c=p(this.options,t.options);l(c.apiKey)&&(n={type:"page",writeKey:this.options.apiKey,integrations:c.integrations},t.messageId&&(n.messageId=t.messageId),(i=new d(n)).withUser(e.user),i.withTealiumId(e.user),i.withContext(),o=this.mergePropertiesWithDimensions(t.properties,e.dimensions),e.setdim(o,t.properties),t.options&&t.options.uniqueEventId&&t.options.uniqueEventIdKey&&(r=u({},t.options.uniqueEventIdKey,t.options.uniqueEventId),o=this.mergePropertiesWithDimensions(r,o)),(a=t.properties.category||t.category||void 0)&&(o=this.mergePropertiesWithDimensions({pagePath:a},o)),i.withUaDataInProps(o,c),i.withProperties(o),s=this.clickUrl(c.apiKey,e.user.getAnonymousId(),c.secure,c.apiHost,c.apiUrlPath),t.cbManager?f(s,i.toJson(),{callback:t.cbManager.register()}):f(s,i.toJson()))}},{key:"onsend",value:function(e,t){var n=t.guid?"/analytics/v1/click/event/"+t.guid:"",i=(t.options.apiUrlPath||n||"").replace(/^\/|\/$/g,""),r=p(this.options,t.options,{apiUrlPath:i}),o=r.apiHost;r.apiKey&&"string"==typeof r.apiKey&&r.apiKey.includes("prod")&&(o="gtm-z.zg-api.com");var a=("boolean"!=typeof r.secure||r.secure?"https":"http")+"://"+o+"/"+i;t.cbManager?f(a,t.properties,{callback:t.cbManager.register()}):f(a,t.properties)}},{key:"clickUrl",value:function(e,t,n,i,r){var o=0<arguments.length&&void 0!==e?e:"notset",a=1<arguments.length&&void 0!==t?t:"notset",s=n,c=i,l=r,u="";o.includes("prod")&&(c="cs.zg-api.com");var d,f=l||"";return f=(f=f.startsWith("/")?f.substring(1):f).endsWith("/")?f.substring(0,f.length-1):f,c&&(d="boolean"!=typeof s||s?"https":"http",u=f?d+"://"+c+"/"+f:d+"://"+c+"/click/"+o+"/"+a),u}},{key:"mergePropertiesWithDimensions",value:function(e,t){var n=s({},t,e);return n=o(n)}}]),h);function h(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,h),this.name="DspPlugin",this.options=e,this.payloadDefaults={}}t.exports=y},{14:14,20:20,21:21,24:24,45:45}],27:[function(e,t,n){"use strict";var o=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],i=!0,r=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){r=!0,o=e}finally{try{!i&&s.return&&s.return()}finally{if(r)throw o}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},i=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function c(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a=e(20).mergeOptions,l=e(2),s=e(17),u=s.isValidExpectedCd1,d=s.dualTaggedGaValidation,f=s.isStaging,p=s.uaVersionValidation,g=/^dimension(\d+)$/,y=/^metric(\d+)$/,h=/^cd(\d+)$/,v=e(10).BUILD_VERSION,m=(i(w,[{key:"oninitialize",value:function(e,t){this.isInitialized()||this.options&&this.options.gaAppKey&&"string"==typeof this.options.gaAppKey&&(this.loadGA(),this.getGA()("create",this.options.gaAppKey,"auto",this.options.gaOptions)),this.options=a(this.options,t.options)}},{key:"addMetadataToCd198",value:function(e,t,n){try{var i=e.dimension198?JSON.parse(e.dimension198):{};i.callTrace=t.options.callTrace,t.options.uaVersion&&(i.uaVersion=t.options.uaVersion),t.properties.sdkTag&&(i.sdkTag=t.properties.sdkTag),void 0!==t.options.isAdBlockerOn&&(i.isAdBlockerOn=t.options.isAdBlockerOn),void 0!==t.options.isGaBlocked&&(i.isGaBlocked=t.options.isGaBlocked),n&&(i.correctedCd1=n.correctedCd1,i.correctedCd1With=n.correctedCd1With),i.isGaPluginOn=!0,i.sdkVersion=v,e.dimension198=JSON.stringify(i)}catch(e){console.warn("invalid json sent for cd198")}}},{key:"ontrack",value:function(e,t){var n,i,r,o,a;this.isTrackAllowed(t.properties.category,t.properties.action,t.properties.label)?(n={hitType:"event",eventCategory:t.properties.category,eventAction:t.properties.action,eventLabel:t.properties.label,eventValue:t.properties.value,nonInteraction:t.properties.nonInteraction}).eventCategory&&n.eventAction&&(t.cbManager&&(n.hitCallback=t.cbManager.register()),r=this.mergeAndFixProperties(t.properties,e.dimensions),t.options&&t.options.uniqueEventId&&t.options.uniqueEventIdKey&&(i=c({},t.options.uniqueEventIdKey,t.options.uniqueEventId),r=this.mergeAndFixProperties(i,r)),n=l({},n,r),o=this.fixCd1(n,t,e),this.addMetadataToCd198(n,t,o),f(e)&&"ALL"===t.properties.sdkTag&&(d(n,e),p(t.options.uaVersion,n.dimension200,{},!0)),this.isInitialized()?(a=t.options&&t.options.integrations&&t.options.integrations.GaTrackerId?t.options.integrations.GaTrackerId+".send":"send",this.getGA()(a,n)):this.logWarn("Would send event to GA but GA not initialized: ",n)):this.logWarn("GA track event blocked by allowlist.",t)}},{key:"isTrackAllowed",value:function(t,n,i){return!this.allowListTrackEnabled||void 0!==this.allowListTrack.find(function(e){return!(e.category!==t&&"*"!==e.category||e.action!==n&&"*"!==e.action||e.label!==i&&"*"!==e.label)})}},{key:"onpage",value:function(e,t){var n,i,r,o,a,s=t.properties.category||t.category||document.location.pathname||void 0;this.isPageviewAllowed(s)?(n={hitType:"pageview",page:s},t.cbManager&&(n.hitCallback=t.cbManager.register()),r=this.mergeAndFixProperties(t.properties,e.dimensions),t.options&&t.options.uniqueEventId&&t.options.uniqueEventIdKey&&(i=c({},t.options.uniqueEventIdKey,t.options.uniqueEventId),r=this.mergeAndFixProperties(i,r)),n=l({},n,r),o=this.fixCd1(n,t,e),this.addMetadataToCd198(n,t,o),f(e)&&"ALL"===t.properties.sdkTag&&(d(n,e),p(t.options.uaVersion,n.dimension200,{},!0)),this.isInitialized()?(a=t.options&&t.options.integrations&&t.options.integrations.GaTrackerId?t.options.integrations.GaTrackerId+".send":"send",this.getGA()(a,n)):this.logWarn("Would send page to GA but GA not initialized: ",n)):this.logWarn("GA pageview event blocked by allowlist.",t)}},{key:"isPageviewAllowed",value:function(t){return!this.allowListPageviewEnabled||void 0!==this.allowListPageview.find(function(e){return e===t})}},{key:"onsetdim",value:function(e,t){var n=this.mergeAndFixProperties(t.properties,e.dimensions);this.isInitialized()?this.getGA()("set",n):this.logWarn("Would set custom dimensions in GA but GA not initialized: ",n)}},{key:"loadGA",value:function(){var e,t,n,i,r;e=window,t=document,n="ga",e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+(new Date).valueOf(),i=t.createElement("script"),r=t.getElementsByTagName("script")[0],i.async=1,i.src="//www.google-analytics.com/analytics.js",r.parentNode.insertBefore(i,r)}},{key:"getGA",value:function(){return"undefined"!=typeof window&&window.GoogleAnalyticsObject?window[window.GoogleAnalyticsObject]:void 0}},{key:"isInitialized",value:function(){return void 0!==this.getGA()}},{key:"logWarn",value:function(){if("undefined"!=typeof window&&window.console&&window.console.warn){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];window.console.warn.apply(console,t)}}},{key:"fixCd1",value:function(e,t,n){var i=n.user.getId(),r=n.user.getCookieGuid().replace(/[^a-zA-Z0-9]/g,"").toLowerCase(),o=i?r+"/"+i:r;return u(o,r)&&"ALL"===t.properties.sdkTag&&e.dimension1!==o?{correctedCd1:e.dimension1||"undefined",correctedCd1With:e.dimension1=o}:null}},{key:"mergeAndFixProperties",value:function(e,t){var i=l({},t,e),r={};return Object.keys(i).forEach(function(e){var t,n=h.exec(e);n?(t=o(n,2)[1],r["dimension".concat(t)]=i[e]):(g.test(e)||y.test(e))&&(r[e]=i[e])}),r}}]),w);function w(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,w),this.name="GaPlugin",this.options=e,this.allowListTrackEnabled=this.options&&this.options.gaAllowListTrackEnabled||!1,this.allowListPageviewEnabled=this.options&&this.options.gaAllowListPageviewEnabled||!1,this.allowListTrack=this.options&&this.options.gaAllowListTrack||[],this.allowListPageview=this.options&&this.options.gaAllowListPageview||[]}t.exports=m},{10:10,17:17,2:2,20:20}],28:[function(s,e,t){"use strict";var n=function(e,t,n){return t&&i(e.prototype,t),n&&i(e,n),e};function i(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}s(16);var l=s(2),u=s(12),d=s(21),c=s(44).logError,r=(n(o,[{key:"oninitialize",value:function(){this.dataLayerName="dataLayer"}},{key:"getOrCreateDataLayer",value:function(){return window[this.dataLayerName]=window[this.dataLayerName]||[],window[this.
dataLayerName]}},{key:"checkWindow",value:function(){return"undefined"!=typeof window}},{key:"ontrack",value:function(e,t){var n,i;this.checkWindow()&&(n={},i=[t.properties.category,t.properties.action,t.properties.label].filter(function(e){return!!e}).join("$"),l(n,{event:i}),l(n,{eventData:t.properties}),this.getOrCreateDataLayer().push(n))}},{key:"onevent",value:function(e,t){if(this.checkWindow()){var n=s(32),i={},r={};try{var o=this.getNewlaneData(e,t);this.populateEventData(o,r,n);var a=this.getEventKey(o,n);l(i,{event:a}),l(i,{eventData:r}),this.getOrCreateDataLayer().push(i)}catch(e){c("A problem was encountered while sending the new lane data to GTM",e)}}}},{key:"getNewlaneData",value:function(e,t){var n,i,r,o,a=l({},t.properties),s=t.options,c=new u(t.messageId);return c.withContext(),c.withUser(e.user),c.with("client_ts",t.createdAt||(new Date).toISOString()),c.withUncategorized(e.dimensions||{}),c.withMetadataFromOptions(s),t.options&&t.options.uniqueEventId&&t.options.uniqueEventIdKey&&(n=d((i={},r=t.options.uniqueEventIdKey,o=t.options.uniqueEventId,r in i?Object.defineProperty(i,r,{value:o,enumerable:!0,configurable:!0,writable:!0}):i[r]=o,i)),c.withUniqueEventId(n)),c.withProperties(a),c.toJson()}},{key:"populateEventData",value:function(i,r,e,t){var o=this;e[3<arguments.length&&void 0!==t?t:"default"].data.forEach(function(e){var t=o.getPropByPath(i,e),n=e.replace(/\./g,"$");r[n]=t})}},{key:"getEventKey",value:function(t,e,n){var i=this;return e[2<arguments.length&&void 0!==n?n:"default"].event_key.map(function(e){return i.getPropByPath(t,e)||"undefined"}).join("$")}},{key:"getPropByPath",value:function(e,t){if(!t||!e)return null;for(var n=t.split("."),i=0,i=0;i<n.length-1;i++){var r=e[n[i]];if(!r)return null;e=r}return e[n[i]]}},{key:"onpage",value:function(e,t){var n;this.checkWindow()&&(l(n={},{event:"PageView"}),l(n,{pagePath:t.properties.category||t.category||"",eventData:t.properties}),this.getOrCreateDataLayer().push(n))}},{key:"onsetdim",value:function(e,t){var n;this.checkWindow()&&(n=l({},{dimensions:t.properties}),this.getOrCreateDataLayer().push(n))}}]),o);function o(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o),this.name="gtm",this.log="function"==typeof e?e:function(){}}e.exports=r},{12:12,16:16,2:2,21:21,32:32,44:44}],29:[function(e,t,n){"use strict";var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],i=!0,r=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){r=!0,o=e}finally{try{!i&&s.return&&s.return()}finally{if(r)throw o}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},i=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var h=e(24).sendPayload,v=e(21),m=e(20).mergeOptions,w=e(35),b=e(12),_=e(2),s=e(55),k=s.logError,A=s.polyfillPromiseFinallyIfNotExist,c=e(34),S=c.isGetCDTAsync,E=c.getCDTAsync,T=c.getCDT,l=e(17),O=l.isStaging,D=l.uaVersionValidation,P=l.newLaneValidation,I=l.validateAgainstTechSpecCsv,C=l.checkEventRegistration,j=l.errorAboutInvalidWriteKey,x=l.checkExposureEventRegistration,u=e(10),N=u.CLICKSTREAM_WRITE_KEYS,d=u.EVENTING_TYPES,f=(i(p,[{key:"oninitialize",value:function(e,t){this.options=m(this.options,t.options)}},{key:"onSetPayloadDefaults",value:function(e,t){var r=_({},this.payloadDefaults);Object.entries(t.properties).forEach(function(e){var t=a(e,2),n=t[0],i=t[1];Object.prototype.hasOwnProperty.call(r,n)?Array.isArray(r[n])&&Array.isArray(i)?r[n]=r[n].concat(i):"object"===o(r[n])&&"object"===(void 0===i?"undefined":o(i))?r[n]=_({},r[n],i):r[n]=i:r[n]=i}),this.payloadDefaults=r}},{key:"onevent",value:function(r,o){var e,t,n,i,a=this,s=m(this.options,o.options),c=_({},o.properties),l=s.writeKey,u=/\w+_prod/.test(s.apiKey||"")?"zg_prod_web":"zg_dev_web",d=l&&N.has(l)?l:u,f=new b(o.messageId);function p(e){f.withProperties(a.payloadDefaults),f.withProperties(e);var t=f.toJson(),n=t.envelope&&t.envelope.event_type_id?t.envelope.event_type_id:"";O(r)&&(P(t),D(t.uncategorized.uaVersion,n,t.clickstream_trigger),I(t),t.exposure?x(n):C(n,t),N.has(l)||j(l,n));var i=o.cbManager?o.cbManager.register():void 0;h(g,t,{callback:i,eventId:n}),w.event("clickstream-event",c).catch(function(e){e.name="`window.ua data layer error: ClickstreamEventError:",k(e)})}f.withContext("clickstream_trigger"),f.withUser(r.user),f.with("client_ts",o.createdAt||(new Date).toISOString()),f.withUncategorized(r.dimensions||{}),f.withMetadataFromOptions(s),f.withMetadataFromDataLayer(),o.options&&o.options.uniqueEventId&&o.options.uniqueEventIdKey&&(e=v((t={},n=o.options.uniqueEventIdKey,i=o.options.uniqueEventId,n in t?Object.defineProperty(t,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[n]=i,t)),f.withUniqueEventId(e));var g=this.clickUrl(d,r.user.getCookieGuid(),s.secure,s.apiHost,s.apiUrlPath);if(S())A(),E().then(function(e){e&&0<Object.keys(e).length&&(e.metadata&&(f.withCDTMetadata(e.metadata),delete e.metadata),c.cross_domain_tracking=e)}).catch(function(e){k("window.ua data layer error: Error retrieving cross domain tracking data",e)}).finally(function(){try{p(c)}catch(e){O(r)&&console.error("SDK failed to send the event due to the following reason: "+e)}});else{var y=T();y&&0<Object.keys(y).length&&(y.metadata&&(f.withCDTMetadata(y.metadata),delete y.metadata),c.cross_domain_tracking=y);try{p(c)}catch(e){O(r)&&console.error("SDK failed to send the event due to the following reason: "+e)}}}},{key:"onSelfServeEvent",value:function(e,t){var n=m(this.options,t.options),i=_({},t.properties),r=new b(t.messageId);r.withContext("trigger"),r.withUser(e.user),r.with("client_ts",t.createdAt||(new Date).toISOString()),r.withUncategorized(e.dimensions||{}),r.withMetadataFromOptions(n),r.withMetadataFromDataLayer();var o=n.eventingType===d.sspa?this.clickUrlSspaV2(n.apiHost,e.user.getCookieGuid(),n.secure):this.clickUrl(n.writeKey,e.user.getCookieGuid(),n.secure,n.apiHost,n.apiUrlPath);r.withProperties(this.payloadDefaults),r.withProperties(i);var a,s=r.toJson(),c=s.envelope&&s.envelope.event_type_id?s.envelope.event_type_id:"",l={callback:t.cbManager?t.cbManager.register():void 0,eventId:c};c&&(a={"Content-Type":"application/json;charset=UTF-8","x-event-type-id":c},l.headers=a),h(o,s,l),w.event("SSPA-event",i).catch(function(e){k("`window.ua data layer error: SSPAEventError:",e)})}},{key:"clickUrl",value:function(e,t,n,i,r){var o=0<arguments.length&&void 0!==e?e:"notset",a=1<arguments.length&&void 0!==t?t:"notset",s=n,c=i,l=r,u="";o.includes("prod")&&(c="cs.zg-api.com");var d,f=l||"";return f=(f=f.startsWith("/")?f.substring(1):f).endsWith("/")?f.substring(0,f.length-1):f,c&&(d="boolean"!=typeof s||s?"https":"http",u=f?d+"://"+c+"/"+f:d+"://"+c+"/click/"+o+"/"+a),u}},{key:"clickUrlSspaV2",value:function(e,t,n){var i=1<arguments.length&&void 0!==t?t:"notset",r=n,o="";return e.includes("e.zg-api.com")&&(e="cs.zg-api.com"),e&&(o=("boolean"!=typeof r||r?"https":"http")+"://"+e+"/click/v2/"+i),o}}]),p);function p(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,p),this.name="NewLanePlugin",this.options=e,this.payloadDefaults={}}t.exports=f},{10:10,12:12,17:17,2:2,20:20,21:21,24:24,34:34,35:35,55:55}],30:[function(e,t,n){"use strict";var i=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var o=e(46),a=e(43),s=36e5,c=(i(l,[{key:"oninitialize",value:function(){var e,t="undefined"!=typeof window&&window.location&&window.location.search;t&&((e=o(t)).name&&a.setCookie("zjs_utmcampaign",e.name,s),e.source&&a.setCookie("zjs_utmsource",e.source,s),e.medium&&a.setCookie("zjs_utmmedium",e.medium,s),e.term&&a.setCookie("zjs_utmterm",e.term,s),e.content&&a.setCookie("zjs_utmcontent",e.content,s))}}]),l);function l(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),this.name="StoreUtmPlugin"}t.exports=c},{43:43,46:46}],31:[function(e,t,n){"use strict";var o=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],i=!0,r=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){r=!0,o=e}finally{try{!i&&s.return&&s.return()}finally{if(r)throw o}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r=function(e,t,n){return t&&a(e.prototype,t),n&&a(e,n),e};function a(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var s=e(2),c=e(38).flatten,l=(r(u,[{key:"oninitialize",value:function(){this.utagQueue=[],this.checkAndFlushEarlyEvents()}},{key:"ontrack",value:function(e,t){this.isCdpEnabled(t&&t.options)&&this.handleRequest(e,t,this.trackFunction)}},{key:"onpage",value:function(e,t){this.isCdpEnabled(t&&t.options)&&this.handleRequest(e,t,this.pageFunction)}},{key:"onsetdim",value:function(e,t){window.utag_data=window.utag_data||{},s(window.utag_data,c(t.properties))}},{key:"isReadyForCdp",value:function(e){return!("object"!==i(window.utag)||"function"!=typeof window.utag[e])}},{key:"handleRequest",value:function(e,t,n){var i=this.preparePayload(e,t,n);this.isReadyForCdp(n)?(this.hasFlushOccurred||(this.flushEvents(),this.hasFlushOccurred=!0),t.cbManager?this.executeUtag(n,i,t.cbManager.register()):this.executeUtag(n,i)):this.utagQueue.push([].concat(n,i,t.cbManager?t.cbManager.register():void 0))}},{key:"executeUtag",value:function(e,t,n){var i;this.isProduction()?"function"==typeof n?window.utag[e](t,n):window.utag[e](t):(i=s({},t,{method:e}),"function"==typeof n&&(i=s(i,{callback:n})),this.writeTestPayloadToWindow(i))}},{key:"isProduction",value:function(){return!(!window||!window.utag_data||"prod"!==window.utag_data.tealium_environment&&"dev"!==window.utag_data.tealium_environment)}},{key:"isCdpEnabled",value:function(e){return!!(e&&e.integrations&&e.integrations.cdp)}},{key:"preparePayload",value:function(e,t,n){var i={};return e&&e.user&&s(i,{ezuid:e.user.getId(),guid:e.user.getAnonymousId()}),n===this.trackFunction&&s(i,{ga_category:t.properties.category,ga_action:t.properties.action,ga_label:t.properties.label,ga_value:t.properties.value}),s(i,t.properties.custom_payload),i.tealium_event=i.cdp_event,delete i.cdp_event,i}},{key:"writeTestPayloadToWindow",value:function(e){window.tealium_test=window.tealium_test||[],window.tealium_test.push(e)}},{key:"checkAndFlushEarlyEvents",value:function(e){var t=this,n=0<arguments.length&&void 0!==e?e:20;window&&"object"===i(window.utag)&&"function"==typeof window.utag[this.pageFunction]&&"function"==typeof window.utag[this.trackFunction]&&!this.hasFlushOccurred?(this.flushEvents(),this.hasFlushOccurred=!0):0<=n&&setTimeout(function(){return t.checkAndFlushEarlyEvents(n-1)},1e3)}},{key:"flushEvents",value:function(){for(;this.utagQueue&&0<this.utagQueue.length;){var e,t,n,i,r=this.utagQueue.shift();Array.isArray(r)&&1<r.length&&(t=(e=o(r,3))[0],n=e[1],i=e[2],this.isReadyForCdp(t)&&this.executeUtag(t,n,i))}}}]),u);function u(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,u),this.name="cdp",this.trackFunction="link",this.pageFunction="view",this.hasFlushOccurred=!1,this.log="function"==typeof e?e:function(){}}t.exports=l},{2:2,38:38}],32:[function(e,t,n){t.exports={default:{data:["cms_info.block_id","user_info.guid","user_info.zuid","property_info.lot_id","property_info.zpid","property_info.saved_ind","property_info.state_cd","property_info.county_nm","property_info.city_nm","property_info.zip_cd","property_info.neighborhood_nm","property_info.property_type_cd","property_info.price_amt","property_info.raw_home_status_cd","property_info.marketing_status_simplified_cd","search_filter.fsba_ind","search_filter.fsbo_ind","search_filter.new_construction_ind","search_filter.forclosure_ind","search_filter.coming_soon_ind","search_filter.auction_ind","search_filter.premarket_foreclosure_ind","search_filter.for_rent_ind","search_filter.recently_sold_ind","search_filter.all_homes_ind","search_filter.only_open_house_ind","search_filter.zillow_owned_ind","search_filter.pending_listing_ind","search_filter.accepting_backup_offer_ind","search_filter.single_family_ind","search_filter.condo_ind","search_filter.apt_or_condo_ind","search_filter.multi-family_ind","search_filter.apt_ind","search_filter.manufactured_ind","search_filter.lot_land_ind","search_filter.townhouse_ind","search_filter.tour_3d_ind","search_filter.user_search_terms_txt","contact_request_form.pa_lead_id","clickstream_trigger.trigger_reference_url","building_info.state_cd","building_info.county_nm","building_info.city_nm","building_info.zip_cd","building_info.neighborhood_nm","building_info.street_address_txt","building_info.building_listing_status_txt","building_info.saved_ind","building_info.lot_id","envelope.event_uuid"],event_key:["envelope.event_type_id","semantic.semantic_event_nm","clickstream_trigger.trigger_type_nm","clickstream_trigger.trigger_location_nm","clickstream_trigger.trigger_source_nm","clickstream_trigger.trigger_object_nm"]}}},{}],33:[function(e,t,n){"use strict";t.exports={analyticsEnabled:function(){return!Boolean("undefined"!=typeof window&&window["disable-analytics"])}}},{}],34:[function(e,t,n){"use strict";var u=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],i=!0,r=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){r=!0,o=e}finally{try{!i&&s.return&&s.return()}finally{if(r)throw o}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},i=e(10),r=i.CROSS_DOMAIN_QUERY_PARAMS,l=i.CROSS_DOMAIN_KEYS_MAP,o=i.CROSS_DOMAIN_DATALAYER_KEYS,a=e(49),d=a.isInitialized,f=a.set,s=a.get,c=e(35).get,p=e(55).logError,g="cross_domain_tracking",y={zillow:"zillow.",zhl:"zillowhomeloans."};function h(e){return g+"_"+e}var v=void 0,m=void 0,w=!1;function b(e){if(e){var l={};Object.entries(e).forEach(function(e){var t,n,i=u(e,2),o=i[0],r=i[1],a=void 0===r?{}:r,s=a.value,c=a.timestamp;s&&(t=new Date(1e3*c).toISOString(),s.metadata&&(l.metadata||(l.metadata={}),Object.entries(s.metadata).forEach(function(e){var t,n=u(e,2),i=n[0],r=n[1];r&&(t=o.charAt(0).toUpperCase()+o.slice(1),l.metadata[""+i+t]=r)})),delete(n=Object.assign({},s,{saved_ts:t})).metadata,Object.entries(n).forEach(function(e){var t=u(e,2),n=t[0],i=t[1];i&&(n=n.replace("zuid","uid"),l[o+"_"+n]=i)}))});var t=function(){if(!window||!window.location)return null;var e=window.location.hostname;return e.includes("zillow.")?"zillow_guid":e.includes("zillowhomeloans.")?"zhl_guid":null}();return 0<Object.entries(l).length&&m&&t&&(l[t]=m.getCookieGuid()),l}}t.exports={setVisitor:function(e){v=e},setUser:function(e){m=e},setCDT:function(o,a){var s,e,t,n,i,c;o&&(w&&a&&a.isCDTFromCD68||(s={},r.forEach(function(e){if(o.has(e)){var t=l[e],n=t.domain,i=t.key,r=o.get(e);if(!(a&&a.isCDTManuallySet||function(e){var t=e.domain,n=e.value,i=e.key;if(document&&window&&window.location&&("string"!=typeof n||"null"!==n||"uid"!==i)){var r=y[t],o=!0;return document.referrer.includes(r)||(p(t+" CDT data did not come from a domain containing "+r),o=!1),window.location.hostname.includes(r)&&(p("CDT params cannot be set on the same domain ("+t+")"),o=!1),o}}({domain:n,key:i,value:r})||window.Cypress))return;s[n]||(s[n]=a?{metadata:a}:{}),s[n][i]=r}}),e=Object.entries(s),n=(t=new URL(window.location.href)).searchParams.toString(),r.forEach(function(e){t.searchParams.delete(e)}),n!==t.searchParams.toString()&&(i="?"+t.searchParams.toString()+t.hash,window.history.replaceState(null,"",i)),0<e.length&&(w=!0),d()?e.forEach(function(e){var t=u(e,2),n=t[0],i=t[1];f(n,i,{persistency:"visitor",screenName:g})}):(c=v?v.getZgAnonymousId():void 0,e.forEach(function(e){var t=u(e,2),n=t[0],i=t[1],r=h(n),o=JSON.stringify({value:i,id:c});localStorage.setItem(r,o)}))))},moveLocalStorageToDataLayer:function(){o.forEach(function(e){var t=h(e),n=JSON.parse(localStorage.getItem(t));n&&(n.id&&v&&n.id!==v.getZgAnonymousId()||f(e,n.value,{persistency:"visitor",screenName:g}))&&localStorage.removeItem(t)})},isGetCDTAsync:function(){return!d()},getCDT:function(){return b(s(o,{screenName:g,includeTimestamp:!0}))},getCDTAsync:function(){return c(o,{screenName:g,includeTimestamp:!0}).then(b)}}},{10:10,35:35,49:49,55:55}],35:[function(e,t,n){"use strict";var i=e(10),c=i.DATA_LAYER_RETRIES,l=i.DATA_LAYER_RETRY_AFTER_MS,u=i.DATA_LAYER_BACKOFF_FACTOR,d=e(55).logError;function r(a,s,e){return new Promise(function(r,o){!function e(t){var n,i="undefined"!=typeof window&&void 0!==window.ua&&!0===window.ua.initialized?window.ua:void 0;void 0!==i?i.apply(void 0,["datalayer",a].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(s))).then(function(e){r(e)}).catch(function(e){o(e)}):0<t?(n=Math.pow(u,c-t+1),setTimeout(function(){e(t-1)},n*l)):(d('window.ua data layer error: data layer never initialized. The "'+a+'" call failed.'),o(new Error('window.ua data layer never initialized. The "'+a+'" call failed.')))}(e)})}t.exports={get:function(e){for(var t=arguments.length,n=Array(1<t?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];return r("get",[e].concat(n),c)},event:function(e,t){return r("event",[e,t],c)}}},{10:10,55:55}],36:[function(e,t,n){"use strict";var i=e(10),r=i.SELF_SERVE_WRITE_KEYS,o=i.EVENTING_TYPES;t.exports={isClickstreamNewLaneEvent:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return e.envelope&&e.clickstream_trigger||e.exposure},isSelfServeEvent:function(e){return r.has(e.writeKey)||e.eventingType===o.sspa}}},{10:10}],37:[function(e,t,n){"use strict";var i=e(43).getCookie;t.exports=function(){return!0===i("zjs_debug")}},{43:43}],38:[function(e,t,n){"use strict";var c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};var l=e(2);t.exports={flatten:function(e){var t={};return"object"===(void 0===e?"undefined":c(e))&&e&&0<Object.keys(e).length&&function r(o,a,s){Object.keys(o).forEach(function(e){var t,n,i;!o[e]||"object"!==c(o[e])||o[e]instanceof Array||o[e]instanceof Date?l(a,(t={},n=s+e,i=o[e],n in t?Object.defineProperty(t,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[n]=i,t)):r(o[e],a,""+s+e+".")})}(e,t,""),t}}},{2:2}],39:[function(e,t,n){"use strict";t.exports={nullOrString:function(e){return null===e?null:""+e}}},{}],40:[function(e,t,n){"use strict";var s=Object.getOwnPropertyNames,c=Object.getPrototypeOf;t.exports={getObjectMethodsMap:function(t){for(var n={},e=s(t=t||{}),i=[],r=c(t),o=0;o<7&&r;o+=1)i=i.concat(s(r)),r=c(r);var a={};return s(c({})).forEach(function(e){a[e]=!0}),e.concat(i).filter(function(e){return!a[e]&&"function"==typeof t[e]}).forEach(function(e){n[e]=!0}),n}}},{}],41:[function(e,t,n){"use strict";t.exports=function(e){var t=void 0,n=e;return function(){return n&&(t=n.apply(this,arguments),n=null),t}}},{}],42:[function(e,t,n){"use strict";t.exports=function(e){var t={};if(!e||"string"!=typeof e)return t;for(var n=("?"===e[0]?e.substr(1):e).split("&"),i=0;i<n.length;i+=1){var r=n[i].split("=");r[0]&&(t[decodeURIComponent(r[0])]=decodeURIComponent(r[1]||""))}return t}},{}],43:[function(e,t,n){"use strict";var s=e(1),c=(new Date).valueOf();function l(e){if("string"!=typeof e)return"";var t=e.replace(/:\d+$/,""),n=t.split(".");return 2<n.length?n.slice(n.length-2).join("."):t}t.exports={getCookie:function(e){var t=!(1<arguments.length&&void 0!==arguments[1])||arguments[1];try{var n=s.get(e);return t&&"string"==typeof n?JSON.parse(n):n}catch(e){}return null},setCookie:function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;try{n=n||31556952e3;var i=document.location.host,r=JSON.stringify(t),o="localhost"===i?void 0:"."+l(i),a={expires:new Date(c+n),path:"/",domain:o};s.set(e,r,a)}catch(e){}},topDomain:l}},{1:1}],44:[function(e,t,n){"use strict";var i=e(10).BUILD_VERSION,c={},r="",l=[],u=!1,o=.01,a=new Map;function d(e){var n=e.title,i=e.error,t=e.tags,r=void 0===t?{}:t;a.has(n)&&(a.get(n)===r["event-id"]||!0===a.get(n))||(a.set(n,r["event-id"]||!0),c.withScope(function(t){r&&Object.keys(r).forEach(function(e){t.setTag(e,r[e])}),!n||i?(n&&t.setTransactionName(n),c.captureException(i)):c.captureException(n)}))}t.exports={logSentryError:function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];var i=t[0],r=t[1],o="string"==typeof i?i:"string"==typeof r?r:"";if(o.includes("window.ua data layer error")){if(u)return;u=!0}var a=r instanceof Error?r:null,s={title:o,error:i instanceof Error?i:a};c.captureException?d(s):l.push(s)},loadSentry:function(){!function e(t){if(t<=0)return;if("undefined"==typeof window)return;if(c.captureException)return;if(window.zga_get_sentry)return(c=window.zga_get_sentry(o)).configureScope(function(e){e.setTag("sdk-version",i),e.setUser({id:r})}),window.zga_sentry=c,l.forEach(function(e){c.captureException(e)}),void(l=[]);if(window.Sentry&&window.Sentry.BrowserClient){var n=new window.Sentry.BrowserClient({dsn:"https://0fa95b757d5048fe8669eadd8bcd9ab6@o168728.ingest.sentry.io/4505211521728512",stackParser:window.Sentry.defaultStackParser,integrations:[new window.Sentry.Dedupe],transport:window.Sentry.makeFetchTransport,sampleRate:o});return(c=new window.Sentry.Hub(n)).configureScope(function(e){e.setTag("sdk-version",i),e.setUser({id:r})}),l.forEach(function(e){d(e)}),l=[],void(window.zga_sentry=c)}setTimeout(function(){e(t-1)},2e3)}(3)},logEventError:function(e){var t={error:e.error,title:e.title,tags:{"event-id":e.eventId}};c.captureException?d(t):l.push(t)},setSentryUser:function(e){c.setUser?c.setUser({id:e}):r=e},resetSentry:function(){c={},u=!(l=[]),a.clear()}}},{10:10}],45:[function(e,t,n){"use strict";var a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=e(15),r=i.FULL_WK_BLOCKLIST_DSP,s=i.CONDITIONAL_WK_ALLOWLIST_DSP;t.exports={shouldEnableDSP:function(e){return!r.includes(e)},shouldAllowTrackDSP:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"",n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:"";if(!s[e])return!0;var i=t.trim().toLowerCase(),r=n.trim().toLowerCase(),o=s[e][i];return!0===o||!("object"!==(void 0===o?"undefined":a(o))||null===o||!o[r])},shouldAllowPageDSP:function(e){return!0}}},{15:15}],46:[function(e,t,n){"use strict";var i=e(42);t.exports=function(e){var r,o={};return e&&(r=i(e),Object.getOwnPropertyNames(r).forEach(function(e){var t,n,i=/^utm_(.+)$/.exec(e);i&&(t=i[1],n=r[e],"campaign"===t?o.name=n:o[t]=n)})),o}},{42:42}],47:[function(e,t,n){"use strict";var i=e(48),u=i.setCustomDimensions,d=i.getCustomDimensions,f=i.sendPageview,p=i.sendEvent,g=i.identifyUser,r=e(51),y=r.handleGtagEvent,h=r.handleGtagSet,o=e(55),v=o.isValidGASendEventHitType,m=o.isValidGASendPageviewHitType,w=o.isGACommand,b=o.extractAndProcessUAOptionsFromArgs,a=e(53),_=a.uaMethodProxy,k=a.uaDataLayerProxy;function s(e){for(var t=arguments.length,n=Array(1<t?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];if(w(e,"set")&&"userId"===n[0])return g(n[0]);if(w(e,"set"))return u(n[0],n[1]);if("get-dimensions"===e)return d();if(w(e,"send")&&"pageview"===n[0]){var r=b(n);return f(n[1],r)}if(w(e,"send")&&"event"===n[0]){var o=b(n);return p(n[1],n[2],n[3],n[4],o)}if(w(e,"send")&&v(n[0])){var a=b(n);return p(n[0].eventCategory,n[0].eventAction,n[0].eventLabel,n[0].eventValue,a)}if(w(e,"send")&&m(n[0])){var s=b(n);return f(n[0].page,s)}if("gtag"===e&&"event"===n[0])return y(n[1],n[2]);if("gtag"===e&&"set"===n[0])return h(n[1]);if("datalayer"!==e)return _.apply(void 0,[e].concat(n));var c=void 0,l=[];return Array.isArray(n)&&(c=n[0],l=n.slice(1)),k.apply(void 0,[c].concat(function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(l)))}s.initialized=!0,s.q=[],t.exports={ua:s}},{48:48,51:51,53:53,55:55}],48:[function(e,t,n){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=e(2),s=e(54),i=e(55),o=i.isScalar,c=i.logError,l=i.logWarn,u=i.isTelLink,d=i.getRedirect,f=i.insertDimensionsAndMetrics,p=i.setGAIntegrationIfNotExists,g=e(56).zcall,y=e(36).isClickstreamNewLaneEvent,h={};function v(){return"undefined"!=typeof window&&window.GoogleAnalyticsObject?window[window.GoogleAnalyticsObject]:void 0}function m(){return void 0!==v()}function w(e,t){var n,i=((n=e)?n.callTrace?n.callTrace:n.options?n.options.uaMethodName:n.uaMethodName:"")||"UnknownOldUAVersion";return i.split(".").includes(t)?i:i+"."+t}function b(e,t,n){var i,r,o=e||{},a=t||{};a.callTrace=w(t,"SDK-track"),s.hasNativeClickstreamAPI()&&a.newLaneEvent?(i={category:o.category,action:o.action,label:o.label,value:o.value},s.trackHybridEvent({legacy:i,config:a,clickstream:a.newLaneEvent})):s.hasMobNativeApi()&&o.category&&o.action?(r={category:o.category,action:o.action,label:o.label,value:o.value,noninteraction:o.noninteraction},s.trackEvent(r)):(void 0!==o.noninteraction&&(o.nonInteraction=o.noninteraction,delete o.noninteraction),f(o,a),p(!0,a),g("track",n||"event",o,a))}function _(e,t,n){var i=t||{},r=n||{};r.callTrace=w(n,"SDK-page"),e?s.hasNativeClickstreamAPI()&&r.newLaneEvent?s.trackHybridPageView({legacy:{pageName:e},config:r,clickstream:r.newLaneEvent}):s.hasMobNativeApi()?s.trackPageView(e,r):(f(i,r),p(!0,r),g("page",e,i,r)):c("page: missing path")}function k(e){void 0!==e?s.hasMobNativeApi()?l("identify: DispatchToNative is not implemented"):g("identify",e):c("identify: userId was not set")}function A(e,t){var n=t||{};s.hasMobNativeApi()||s.hasNativeClickstreamAPI()?s.setCustomDimensions(e):(p(!0,n),h=a({},h,e),g("setdim",e,n))}function S(){return s.hasMobNativeApi()||s.hasNativeClickstreamAPI()?s.getCustomDimensions():a({},h)}t.exports={getCustomDimensions:S,setCustomDimensions:function(e,t,n){var i={};if("string"==typeof e&&o(t))i[e]=t;else{if("object"!==(void 0===e?"undefined":r(e))||null===e)return void c("setCustomDimensions: could not determine dimensions or they were empty.");i=e}A(i,n)},setprop:function(e,t){var n=e||{},i=t||{};s.hasMobNativeApi()||s.hasNativeClickstreamAPI()?l("setprop: not implemented on mobile."):(p(!0,i),g("setprop",n,i))},sendEvent:function(e,t,n,i,r){var o=Number.isSafeInteger(i)&&0<=i;b(a({},{category:e,action:t,label:n,value:i=o?i:void 0},r))},trackEvent:function(e){var t,n,i=e||{},r={};r.callTrace=w(e,"SDK-trackEvent"),i.uaVersion&&(r.uaVersion=i.uaVersion,delete i.uaVersion),i.category?i.action?("hitCallback"in i&&(r.hitCallback=i.hitCallback,delete i.hitCallback),i.href&&(i.target=i.target||"_self",t=d(i),"_blank"===i.target||u(i.href)?t.call():m()?(n=setTimeout(t,500),r.hitCallback=function(){clearTimeout(n),t.call()}):setTimeout(t,100)),b(i,r)):c("track: missing action"):c("track: missing category")},trackEventV2:function(e,t){var n=e||{},i=t||{};i.callTrace=w(t,"SDK-trackEventV2"),n.category?n.action?b(n,i):c("track: missing action"):c("track: missing category")},sendPageview:function(e,t,n){_(e,n,t)},trackPageview:function(e){var t=e||{},n={};n.callTrace=w(e,"SDK-trackPageview"),t.uaVersion&&(n.uaVersion=t.uaVersion,delete t.uaVersion),_(t.pageURL,t,n)},trackPageviewV2:function(e,t){var n=e||{},i=t||{};i.callTrace=w(t,"SDK-trackPageviewV2");var r=n.pageURL;delete n.pageURL,_(r,n,i)},identifyUser:function(e){k("object"===(void 0===e?"undefined":r(e))&&null!==e?e.userId:e)},getGA:v,isGAInitialized:m,requestGAScript:function(e){var t,n,i,r,o,a=e||"ga";try{t=window,n=document,i=a,t.GoogleAnalyticsObject=i,t[i]=t[i]||function(){(t[i].q=t[i].q||[]).push(arguments)},t[i].l=+new Date,r=n.createElement("script"),o=n.getElementsByTagName("script")[0],r.async=1,r.src="//www.google-analytics.com/analytics.js",o.parentNode.insertBefore(r,o)}catch(e){c("Tried to invoke GA loading script, but there was an error.",e)}},gaCommand:function(){if(m()){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];v().apply(window,t)}else c("gaCommand called, but GA was not initialized!")},track:b,event:function(e,t){var n=e||{},i=t||{};i.callTrace=w(t,"SDK-event"),s.hasNativeClickstreamAPI()&&y(e)?s.trackClickstreamEvent(e,t):(f(n,i),p(!0,i),g("event",n,i))},page:_,identify:k,setdim:A,setCDT:function(e){g("setCDT",e)},setPayloadDefaults:function(e){g("setPayloadDefaults",e)},getdim:S,dwell:function(e,t){g("dwell",e,t)},dwellEnd:function(e){g("dwellEnd",e)},send:function(e,t,n){g("send",e,t,n)},generateCallTrace:w}},{2:2,36:36,54:54,55:55,56:56}],49:[function(e,t,n){"use strict";var h=function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var n=[],i=!0,r=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){r=!0,o=e}finally{try{!i&&s.return&&s.return()}finally{if(r)throw o}}return n}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")},f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r=e(50),o=e(18),i=e(55),v=i.logError,a=i.logWarn,s=i.polyfillPromiseFinallyIfNotExist,l=e(33).analyticsEnabled,c=e(10),u=c.BUILD_VERSION,d=c.LIBRARY_NAME,m=c.DATA_LAYER_NAME,p=!1,g=null,y=null,w=null,b={},_={},k=Object.freeze({None:"none",Visitor:"visitor",Forever:"forever"});function A(e){var t=e.key,n=e.screenName;return n?n.toLowerCase()+"."+t:t}function S(e,t,n){var i,r=n&&n.persistency?n.persistency:k.None,o=n&&"string"==typeof n.screenName&&0<n.screenName.length,a=o?n.screenName.toLowerCase():void 0,s=A({key:e,screenName:a});return window[m][s]=t,r===k.Forever||r===k.Visitor?(i={value:t,o:{p:r,t:I()}},r===k.Visitor&&(i.o.id=w.getZgAnonymousId()),o&&(i.o.sn=n.screenName,i.o.ok=e),y.set(s,i)):y.remove(s),_[s]={p:r,t:I()},o&&(_[s].ok=e,_[s].sn=a),D("datalayer-set",n?{key:e,value:t,options:n}:{key:e,value:t,options:{}}),!0}function E(e,t){if("object"!==(void 0===e?"undefined":f(e)))return v("window.ua data layer error: must provide an object of keys mapped to values to set",e,t),!1;var n=!0,i=!1,r=void 0;try{for(var o,a=Object.entries(e)[Symbol.iterator]();!(n=(o=a.next()).done);n=!0){var s=o.value,c=h(s,2);S(c[0],c[1],t)}}catch(e){i=!0,r=e}finally{try{!n&&a.return&&a.return()}finally{if(i)throw r}}return!0}function T(e,t){if(!l())return!1;if(!P())return v("window.ua data layer error: not initialized before call to remove",e),!1;var n,i=t&&"string"==typeof t.screenName?t.screenName.toLowerCase():void 0;return Array.isArray(e)?e.forEach(function(e){var t="string"==typeof i?i+"."+e:e;delete window[m][t],delete _[t],y.remove(t)}):(n="string"==typeof i?i+"."+e:e,delete window[m][n],delete _[n],y.remove(n)),!0}function O(e,t){if(!l())return!1;if(!Object.prototype.hasOwnProperty.call(b,e))return!0;var n=b[e],i=n.findIndex(function(e){return e.handler===t});return i<0||i>=n.length||n.splice(i,1),!0}function D(t,e){if(!l())return!1;if(!Object.prototype.hasOwnProperty.call(b,t))return!0;var n=b[t];if(n.length)for(var i=n.length-1;0<=i;--i){var r=n[i];try{r.handler.call(void 0,e)}catch(e){v("window.ua data layer error while triggering an event",t,r,e)}r.options&&Object.prototype.hasOwnProperty.call(r.options,"once")&&!0===r.options.once&&O(t,r.handler)}return!0}function P(){return!!l()&&p}function I(e){return!0===e?(new Date).toISOString():Math.floor(D
ate.now()/1e3)}function C(){var e=!0,t=!1,n=void 0;try{for(var i,r=Object.keys(_)[Symbol.iterator]();!(e=(i=r.next()).done);e=!0){var o=i.value;!0===_[o].qp&&T(o)}}catch(e){t=!0,n=e}finally{try{!e&&r.return&&r.return()}finally{if(t)throw n}}try{var a=new URLSearchParams(window.location.search),s=!0,c=!1,l=void 0;try{for(var u,d=a.entries()[Symbol.iterator]();!(s=(u=d.next()).done);s=!0){var f=u.value,p=h(f,2),g=p[0],y=p[1];window[m]["qp."+g]=y,_["qp."+g]={qp:!0}}}catch(e){c=!0,l=e}finally{try{!s&&d.return&&d.return()}finally{if(c)throw l}}}catch(e){v("window.ua data layer error while parsing query parameters",e)}}t.exports={set:function(){if(!l())return!1;for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];return P()?"undefined"==typeof window?(v("window.ua data layer error: window object does not exist or is inaccessible",t),!1):("object"!==f(window[m])&&(window[m]={},a("window.ua data layer (window['"+m+"']) was not an object, so it was overwritten.")),t.length<1||3<t.length?(v("window.ua data layer error: invalid call to set",t),!1):"string"==typeof t[0]?3===t.length?S(t[0],t[1],t[2]):2===t.length?S(t[0],t[1]):(v("window.ua data layer error: invalid call to set",t),!1):2===t.length?E(t[0],t[1]):1===t.length?E(t[0]):(v("window.ua data layer error: invalid call to set",t),!1)):(v("window.ua data layer error: not initialized before call to set",t),!1)},get:function(e){var i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!l())return Array.isArray(e)?{}:void 0;if(!P()&&!i.doSynchronous)return v("window.ua data layer error: not initialized before call to get",e),Array.isArray(e)?{}:void 0;var r="string"==typeof i.screenName?i.screenName.toLowerCase():void 0;if(Array.isArray(e)){var o={};return e.forEach(function(e){var t=e;"string"==typeof r&&(t=r+"."+e);var n=window&&window[m]?window[m][t]:void 0;o[e]=i.includeTimestamp&&n?{value:n,timestamp:_[t].t}:n}),o}var t="string"==typeof r?r+"."+e:e;return window&&window[m]?window[m][t]:void 0},getAll:function(e){var t={};if(!l())return t;if(!P())return v("window.ua data layer error: not initialized before call to getAll"),t;if(!window||window&&!window[m])return v("window.ua data layer warning: the data layer is inaccessible"),t;if(e&&"string"==typeof e.screenName){e.screenName=e.screenName.toLowerCase();var n=!0,i=!1,r=void 0;try{for(var o,a=Object.keys(_)[Symbol.iterator]();!(n=(o=a.next()).done);n=!0){var s,c=o.value;_[c].sn===e.screenName&&(s=_[c].ok,void 0!==window[m][c]&&(t[s]=window[m][c]))}}catch(e){i=!0,r=e}finally{try{!n&&a.return&&a.return()}finally{if(i)throw r}}return t}return Object.assign(t,window[m])},has:function(e,t){if(!l())return!1;if(!P())return v("window.ua data layer error: not initialized before call to has",e),!1;var n=t&&"string"==typeof t.screenName?t.screenName.toLowerCase():void 0;if(Array.isArray(e)){var i={};return e.forEach(function(e){var t="string"==typeof n?n+"."+e:e;i[e]=window&&window[m]&&Object.prototype.hasOwnProperty.call(window[m],t)}),i}var r="string"==typeof n?n+"."+e:e;return window&&window[m]&&Object.prototype.hasOwnProperty.call(window[m],r)},remove:T,on:function(e,t,n){return!!l()&&(!e||e&&"string"!=typeof e?(v("window.ua data layer error: eventName cannot be empty and must be a string",e,t,n),!1):"function"!=typeof t?(v("window.ua data layer error: a function must be passed in as an event handler",e,t,n),!1):(Object.prototype.hasOwnProperty.call(b,e)||(b[e]=[]),b[e].push({handler:t,options:n&&"object"===(void 0===n?"undefined":f(n))?n:{}}),!0))},off:O,event:D,clear:function(e){if(!l())return!1;if(!P())return v("window.ua data layer error: not initialized before call to clear",e),!1;if(!e||e&&"string"!=typeof e)return v("window.ua data layer error: screenName must be a string and cannot be empty",e),!1;e=e.toLowerCase();var t=!0,n=!1,i=void 0;try{for(var r,o=Object.keys(_)[Symbol.iterator]();!(t=(r=o.next()).done);t=!0){var a=r.value;_[a].sn===e&&T(_[a].ok,{screenName:_[a].sn})}}catch(e){n=!0,i=e}finally{try{!t&&o.return&&o.return()}finally{if(n)throw i}}return!0},initialize:function(e,t){if(l()&&"undefined"!=typeof window&&!p){Object.prototype.hasOwnProperty.call(window,m)?"object"!==f(window[m])&&(window[m]={},a("window.ua data layer (window['"+m+"']) was initialized to something other than an object, so it was overwritten.")):window[m]={},w=e||new o;var n=!1,i=function(){n||(n=!0,s(),y.getAll().then(function(e){!function(e){if(!e||e&&"object"!==(void 0===e?"undefined":f(e)))return;try{var t=!0,n=!1,i=void 0;try{for(var r,o=Object.entries(e)[Symbol.iterator]();!(t=(r=o.next()).done);t=!0){var a,s,c=r.value,l=h(c,2),u=l[0],d=l[1];d&&d.value&&d.o&&(d.o.p===k.Forever?d.o.sn?(a=A({key:d.o.ok,screenName:d.o.sn}),window[m][a]=d.value,_[a]={p:d.o.p,sn:d.o.sn,ok:d.o.ok,t:d.o.t}):(window[m][u]=d.value,_[u]={p:d.o.p,t:d.o.t}):d.o.p===k.Visitor&&(d.o.id===w.getZgAnonymousId()?d.o.sn?(s=A({key:d.o.ok,screenName:d.o.sn}),window[m][s]=d.value,_[s]={p:d.o.p,sn:d.o.sn,ok:d.o.ok,t:d.o.t}):(window[m][u]=d.value,_[u]={p:d.o.p,t:d.o.t}):y.remove(u)))}}catch(e){n=!0,i=e}finally{try{!t&&o.return&&o.return()}finally{if(n)throw i}}}catch(e){v("window.ua data layer error while initializing data layer from storage",e)}}(e)}).catch(function(){}).finally(function(){window.ZillowAnalyticsDataLayerObject=m,function(){window[m]["load_time.epoch"]=I(),window[m]["load_time.utc"]=I(!0),window[m]["zga.library_name"]=d,window[m]["zga.library_version"]=u,g=window.location.href,C();try{var i=new MutationObserver(function(){g!==window.location.href&&(window[m].sdk_previous_url=g,g=window.location.href,C())});!function e(t){var n=document.querySelector("body");n?i.observe(n,{childList:!0,subtree:!0}):0<t&&setTimeout(function(){e(t-1)},300)}(3)}catch(e){v("window.ua data layer error while trying to establish query parameter listener/updater",e)}}(),p=!0,t instanceof Function&&t()}))};y=new r;try{y.initialize(i)}catch(e){v("window.ua data layer error while initializing storage",e),i()}setTimeout(i,2500)}},isInitialized:P}},{10:10,18:18,33:33,50:50,55:55}],50:[function(e,t,n){"use strict";var i=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var u=e(55).logError,o=e(10),d=o.DATA_STORAGE_NAME,a=o.DATA_STORAGE_SCHEMA_VERSION,f=o.DATA_STORAGE_TABLE_NAME,s=(i(c,[{key:"set",value:function(e,t){if(this.initialized){if(this.useIndexedDB)try{var n=this.db.transaction(f,"readwrite");n.objectStore(f).put(t,e),n.onerror=function(e){u("Error occurred while saving data to indexedDB",e)}}catch(e){u("Error occurred while saving data to indexedDB",e)}else if(window&&window.localStorage){var i=d+"."+e;try{var r=JSON.stringify(t);window.localStorage[i]=r}catch(e){u("Error while encoding localStorage value",e)}}}else u("window.ua data layer storage: must initialize before calling set()")}},{key:"get",value:function(i){if(!this.initialized)return u("window.ua data layer storage: must initialize before calling get()",i),Promise.reject(new Error("Data layer storage was not initialized"));var r=this;return this.useIndexedDB?new Promise(function(t,n){try{var e=r.db.transaction(f,"readonly").objectStore(f).get(i);e.onsuccess=function(e){e.target.result?t(e.target.result):t(void 0)},e.onerror=function(e){u("Error while querying indexedDB for key",e),n(e)}}catch(e){u("Error while querying indexedDB for key",e),n(e)}}):new Promise(function(e){var t=d+"."+i;if(window&&window.localStorage&&Object.prototype.hasOwnProperty.call(window.localStorage,t)){var n=void 0;try{n=JSON.parse(window.localStorage[t])}catch(e){u("Error while decoding localStorage value",e)}e(n)}else e(void 0)})}},{key:"getAll",value:function(){if(!this.initialized)return u("window.ua data layer storage: must initialize before calling getAll()"),Promise.reject(new Error("Data layer storage was not initialized"));var i=this,r={};if(window&&window.localStorage){var e=!0,t=!1,n=void 0;try{for(var o,a=Object.keys(window.localStorage)[Symbol.iterator]();!(e=(o=a.next()).done);e=!0){var s=o.value;if(s.startsWith(d+".")){var c=s.substring(d.length+1);try{var l=JSON.parse(window.localStorage[s]);r[c]=l}catch(e){u("Error while decoding localStorage value",e)}}}}catch(e){t=!0,n=e}finally{try{!e&&a.return&&a.return()}finally{if(t)throw n}}}return this.useIndexedDB?new Promise(function(n,t){try{var e=i.db.transaction(f,"readonly").objectStore(f).openCursor();e.onsuccess=function(e){var t=e.target.result;null!=t?(t.value&&t.key&&(r[t.key]=t.value),t.continue()):n(r)},e.onerror=function(e){u("Error while querying indexedDB for all",e),t(e)}}catch(e){u("Error while querying indexedDB for all",e),t(e)}}):new Promise(function(e){e(r)})}},{key:"remove",value:function(e){if(this.initialized){if(this.useIndexedDB)try{this.db.transaction(f,"readwrite").objectStore(f).delete(e).onerror=function(e){u(e)}}catch(e){u("Error while deleting key from indexedDB",e)}var t=d+"."+e;window&&window.localStorage&&Object.prototype.hasOwnProperty.call(window.localStorage,t)&&window.localStorage.removeItem(t)}else u("window.ua data layer storage: must initialize before calling remove()",e)}},{key:"initialize",value:function(t){var n,i,r;this.initialized?t&&"function"==typeof t&&t.call(void 0):window&&window.indexedDB?(n=this,i=setTimeout(function(){n.useIndexedDB=!1,n.initialized=!0,t&&"function"==typeof t&&t.call(void 0)},2e3),(r=window.indexedDB.open(d,a)).onerror=function(e){clearTimeout(i),u("Error occurred on data layer storage initialization",e),n.useIndexedDB=!1,n.initialized=!0,t&&"function"==typeof t&&t.call(void 0)},r.onupgradeneeded=function(e){clearTimeout(i);var t=e.target.result,n=void 0;(n=t.objectStoreNames.contains(f)?r.transaction.objectStore(f):t.createObjectStore(f)).indexNames.contains("key")||n.createIndex("key","key",{unique:!0})},r.onsuccess=function(e){clearTimeout(i),n.db=e.target.result,n.useIndexedDB=!0,n.initialized=!0,t&&"function"==typeof t&&t.call(void 0)}):(this.initialized=!0,t&&"function"==typeof t&&t.call(void 0))}}]),c);function c(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,c),this.initialized=!1,this.useIndexedDB=!1,this.db=null}t.exports=s},{10:10,55:55}],51:[function(e,t,n){"use strict";var a=e(2);t.exports={handleGtagEvent:function(e,t){var n,i,r,o;n=e,i=a({},t),window&&"function"==typeof window.gtag&&gtag("event",n,i),r=e,o=a({},t),window&&"function"==typeof window.zanalytics&&zanalytics("track",r,o)},handleGtagSet:function(e){var t,n;t=e,window&&"function"==typeof window.gtag&&gtag("set",t),n=e,window&&"function"==typeof window.zanalytics&&zanalytics("setdim",n)}}},{2:2}],52:[function(e,t,n){"use strict";var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};var r=e(55),o=r.toArraySafe,a=r.logError,s=e(49).initialize,c=e(34),l=c.setCDT,u=c.moveLocalStorageToDataLayer,d=c.setVisitor,f=void 0;function p(e,n){!Array.isArray(e)||e.length<=0||e.forEach(function(e){var t=o(e);n.apply(void 0,function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(t))})}function g(e,t){e&&t&&(f=t,Object.defineProperties(e,{ua:{get:function(){return f},set:function(e){(f=e)!==t&&a("Zillow Clickstream Universal-Analytics (ua) got overwritten with",void 0===e?"undefined":i(e),"from:",function(){var e=new Error,t=void 0,n=new RegExp(/.+\/(.*?):\d+(:\d+)*$/),i=new RegExp(/getScriptName \(.+\/(.*):\d+:\d+\)/);if((t=n.exec(e.stack.trim()))&&""!==t[1])return t[1];if((t=i.exec(e.stack.trim()))&&""!==t[1])return t[1];return void 0===e.fileName?null:e.fileName}())},configurable:!0}}))}function y(e){return Boolean(e&&"function"==typeof e.ua)&&!0===e.ua.initialized}t.exports={initializeUaObject:function(e,t,n){var i=e&&e.ua&&e.ua.q||[];y(e)||(d(n),s(n,u),p(i,t),g(e,t),l(new URLSearchParams(e.location.search)))},hasGlobalUaInitialized:y,replaceStubObject:g,replayEventsFromQueue:p}},{34:34,49:49,55:55}],53:[function(e,t,n){"use strict";var i=e(10),s=i.DATA_LAYER_RETRIES,c=i.DATA_LAYER_RETRY_AFTER_MS,l=i.DATA_LAYER_BACKOFF_FACTOR,u=e(55).logError,d=e(49),r=e(48),o=r.setCustomDimensions,a=r.setprop,f=r.identifyUser,p=r.trackEvent,g=r.trackEventV2,y=r.trackPageview,h=r.trackPageviewV2,v=r.getGA,m={trackEvent:p,trackEventV2:g,trackPageview:y,trackPageviewV2:h,setCustomDimensions:o,setprop:a,isInitialized:r.isGAInitialized,requestUAScript:r.requestGAScript,gaCommand:r.gaCommand,getGA:v,identifyUser:f,track:r.track,event:r.event,page:r.page,identify:r.identify,setdim:r.setdim,setCDT:r.setCDT,setPayloadDefaults:r.setPayloadDefaults,getdim:r.getdim,dwell:r.dwell,dwellEnd:r.dwellEnd,send:r.send},w={set:d.set,get:d.get,getAll:d.getAll,has:d.has,remove:d.remove,clear:d.clear,on:d.on,off:d.off,event:d.event};t.exports={uaMethodProxy:function(e){for(var t=void 0,n=arguments.length,i=Array(1<n?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];if(!(e in m))return u("A window.ua command was invoked that doesn't exist: "+e,i),t;try{t=m[e].apply(m,i)}catch(e){u("window.ua error:",e)}return t},uaDataLayerProxy:function(o){for(var e=arguments.length,a=Array(1<e?e-1:0),t=1;t<e;t++)a[t-1]=arguments[t];return o in w?new Promise(function(i,r){!function e(t){var n;d.isInitialized()?i(w[o].apply(w,a)):0<t?(n=Math.pow(l,s-t+1),setTimeout(function(){e(t-1)},n*c)):(u('window.ua data layer error: data layer never initialized. The "'+o+'" call failed.'),r(new Error('window.ua data layer error: data layer never initialized. The "'+o+'" call failed.')))}(s)}):Promise.reject(new Error('window.ua data layer method "'+o+'" does not exist.'))}}},{10:10,48:48,49:49,55:55}],54:[function(e,t,n){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},s=e(55).logError,o=e(2),a=new Set(["2","3","4","5","6","7","8","9","10","13","14","15","16","17","18","20","24","25","26","27","28","51","52","53","54","56","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","122","123","124","125","126","127","128","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","153","155","156","157","158","159","160","161","162","163","188","189","192","193","194","195","196","197","198"]),c={},i=null;function l(){if("undefined"!=typeof window&&window.ZMOB_nativeAPI)return window.ZMOB_nativeAPI}function u(){if("undefined"!=typeof window&&window.nativeClickstreamAPI)return window.nativeClickstreamAPI}function d(e){var i=c;e&&(i=o(i,e));var t=Object.keys(i),r={};return t.forEach(function(e){var t=e,n=i[e];a.has(t)&&(r[t]=n)}),r}function f(e){var t,n=o({legacy:{},config:{},clickstream:{}},e);Array.isArray(n.clickstream)&&(t=n.clickstream[1]||{},n.clickstream=n.clickstream[0]||{},t.hitCallback&&(n.config.clickstreamCallback=t.hitCallback)),p(n.clickstream);var i=d(n.config.customDimensions);return n.legacy.customDimensions=i,n}function p(e){!e||Object.keys(e).length<1||(i&&(e.user_info={webview_guid:i.getCookieGuid()}),window.location&&(e.clickstream_trigger=e.clickstream_trigger||{},e.clickstream_trigger.trigger_reference_url=window.location.href))}t.exports={trackEvent:function(e){var t,n=e.category,i=e.action,r=e.label,o=parseInt(e.value,10),a=l();a&&a.trackUAWebviewEvent?(t=d(e.customDimensions),a.trackUAWebviewEvent(n,i,r,o,JSON.stringify(t))):a&&a.trackWebviewEvent?a.trackWebviewEvent(n,i,r,o):s("Mobile Bridge: There was no mobile method for trackEvent."),"function"==typeof e.hitCallback&&e.hitCallback()},trackPageView:function(e,t){var n,i;t=t||{},"object"===(void 0===e?"undefined":r(e))&&(e=e.pageURL),"string"==typeof e?(n=d(t.customDimensions),(i=l())&&i.trackUAPageview?i.trackUAPageview(e,JSON.stringify(n)):i&&i.trackWebviewPageView?i.trackWebviewPageView(e):s("Mobile Bridge: There was no mobile method for trackPageView.")):s("Mobile Bridge: The pageURL field was not set."),"function"==typeof t.hitCallback&&t.hitCallback()},setCustomDimensions:function(n){var i={};n&&Object.keys(n).forEach(function(e){var t=(t=e.replace("dimension","")).replace("cd","");i[t]=n[e]}),c=o(c,i)},getCustomDimensions:d,hasMobNativeApi:function(){return!!l()},hasNativeClickstreamAPI:function(){return!!u()},trackHybridEvent:function(e){var t=u(),n=f(e),i=n.legacy,r=n.config,o=n.clickstream;t&&t.trackHybridEvent?t.trackHybridEvent(JSON.stringify(o),JSON.stringify(i)):s("Mobile Bridge: There was no mobile method for trackHybridEvent."),"function"==typeof r.hitCallback&&r.hitCallback(),"function"==typeof r.clickstreamCallback&&r.clickstreamCallback()},trackHybridPageView:function(e){var t=u(),n=f(e),i=n.legacy,r=n.config,o=n.clickstream;t&&t.trackHybridPageView?t.trackHybridPageView(JSON.stringify(o),JSON.stringify(i)):s("Mobile Bridge: There was no mobile method for trackHybridPageView."),"function"==typeof r.hitCallback&&r.hitCallback(),"function"==typeof r.clickstreamCallback&&r.clickstreamCallback()},trackClickstreamEvent:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};!function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};p(e);var t=u();if(!t)return s("Mobile Bridge: There was no mobile native clickstream API.");if(e.clickstream_trigger&&"view"===e.clickstream_trigger.trigger_type_nm&&t.trackPageView)return t.trackPageView(JSON.stringify(e));if(t.trackEvent)return t.trackEvent(JSON.stringify(e));s("Mobile Bridge: There was no mobile method for clickstream event.")}(e),"function"==typeof t.hitCallback&&t.hitCallback()},setWebViewUser:function(e){i=e}}},{2:2,55:55}],55:[function(e,d,t){(function(i){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},t=e(2),o=e(41),a=e(44).logSentryError;function s(e){return!(!e||"object"!==(void 0===e?"undefined":r(e)))&&(0===Object.keys(e).length&&e.constructor===Object)}function n(e,t){if("string"!=typeof e)return!1;if("string"!=typeof t)return!1;var n=Math.max(0,e.length-t.length);return e.substr(n)===t}function c(){if("undefined"!=typeof window&&window.console&&window.console.warn){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];window.console.warn.apply(console,t)}}function l(){if("undefined"!=typeof window&&window.console&&window.console.info){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];window.console.info.apply(console,t)}}function u(e,r,o){o&&t(e,Object.keys(o).reduce(function(e,t){var n=t;t=t.replace(r,"");var i=Number(t);return 0<i&&i===Math.floor(i)?e[r+i]=o[n]:c("Could not set UA option "+r+t),e},{}))}d.exports={isScalar:function(e){var t=void 0===e?"undefined":r(e);return"string"===t||"number"===t||"boolean"===t||"undefined"===t||null===e},toArraySafe:function(e){return[].slice.call(e||[])},isValidGASendEventHitType:function(e){return"object"===(void 0===e?"undefined":r(e))&&null!==e&&"event"===e.hitType},isValidGASendPageviewHitType:function(e){return"object"===(void 0===e?"undefined":r(e))&&null!==e&&"pageview"===e.hitType},endsWith:n,isGACommand:function(e,t){return e===t||n(e,"."+t)},extractAndProcessUAOptionsFromArgs:function(e){var t,n={};return!(Array.isArray(e)&&0<e.length)||(t=e[e.length-1])&&"object"===(void 0===t?"undefined":r(t))&&(t.hitCallback&&"function"==typeof t.hitCallback&&(n.hitCallback=o(t.hitCallback),delete t.hitCallback),t.nonInteraction&&"boolean"==typeof t.nonInteraction&&(n.noninteraction=t.nonInteraction,delete t.nonInteraction),s(e[e.length-1])&&delete e[e.length-1]),n},logError:function(){for(var e=arguments.length,t=Array(e),n=0;n<e;n++)t[n]=arguments[n];i.env.JEST_WORKER_ID&&"undefined"!=typeof window&&window.console.error.apply(console,t),a.apply(void 0,t)},logWarn:c,logInfo:l,isTelLink:function(e){return/^tel:/i.test(e)},getRedirect:function(e){return"undefined"!=typeof window&&window.open?window.open.bind(window,e.href,e.target):l.bind(null,'ga redirect window.open("%s", "%s")',e.href,e.target)},insertDimensionsAndMetrics:function(e,t){u(e,"dimension",t.dimensions),u(e,"metric",t.metrics)},isEmptyObject:s,setGAIntegrationIfNotExists:function(e,t){"integrations"in(t=t||{})||(t.integrations={}),"GaPlugin"in t.integrations||(t.integrations.GaPlugin=e)},polyfillPromiseFinallyIfNotExist:function(){Promise.prototype.finally||(Promise.prototype.finally=function(t){if("function"!=typeof t)return this.then(t,t);var n=this.constructor||Promise;return this.then(function(e){return n.resolve(t()).then(function(){return e})},function(e){return n.resolve(t()).then(function(){throw e})})})}}}).call(this,e(3))},{2:2,3:3,41:41,44:44}],56:[function(e,t,n){"use strict";var a=e(55).logWarn,s=500;function c(e,t,n){var i,r,o=l();i=e,(r=l())&&"function"==typeof r[i]?o[e].apply(o,function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}(t)):(void 0===o||!o[e])&&0<n?setTimeout(function(){c(e,t,n-1)},s):a("A call was dropped to ZA: "+e+" - "+t)}function l(){return"undefined"!=typeof window&&window.ZillowAnalyticsObject?window[window.ZillowAnalyticsObject]:void 0}t.exports={zcall:function(e){for(var t=arguments.length,n=Array(1<t?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];c(e,n,2)}}},{55:55}],57:[function(e,t,n){"use strict";var i,r,o,a,s,c,l,u,d,f,p,g,y,h,v,m,w,b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},_=e(7),k=e(18),A=e(26),S=e(29),E=e(25),T=e(28),O=e(31),D=e(27),P=e(30),I=e(22),C=e(37),j=e(44).loadSentry,x=e(45).shouldEnableDSP,N=e(10).BUILD_VERSION,z=e(52).initializeUaObject,K=e(47).ua,V=e(17),L=V.setItemWithExpiration,R=V.csvToJson,G=V.getTechSpecAttributes,M=V.isStaging,W=V.isSelenium,F=e(55).polyfillPromiseFinallyIfNotExist,U=e(24).setIsAdblockEnabled,B="undefined"==typeof window?{}:window,q=new k;z(B,K,q),I.isWebView()||(i=B.ZillowAnalyticsObject||"zanalytics",r="zillow",o={},B[i]&&B[i]._loadOptions&&"object"===b(B[i]._loadOptions)&&(o=B[i]._loadOptions),a=new S,s=new O,c=new P,l=new T,u=new D,_.use(a),_.use(s),_.use(c),_.use(l),_.use(u),o[r]&&x(o[r].apiKey)&&(d=new A,_.use(d)),C()&&(f=new E,_.use(f)),r in o||(o[r]={}),"integrations"in o[r]||(o[r].integrations={}),M({options:o[r]})||j(),o[r].integrations.GaPlugin=!1,o[r].uniqueEventIdKey="dimension193",o.uaVersion&&(o[r].uaVersion=o.uaVersion),p=B[i],g=o[r],y=function(){_.initialize(p,g,q),B[i]=_,B[i].BuildVersion=N},window&&window.fetch?(F(),h="",v=!1,window.fetch(new Request("https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js")).then(function(){h=!1}).catch(function(){h=!0}).finally(function(){o[r].isAdBlockerOn=h,U(h),window.fetch("https://www.google-analytics.com/collect").catch(function(){v=!0}).finally(function(){o[r].isGaBlocked=v,setTimeout(y,0)})}),M({options:o[r]})&&!W()&&((m=localStorage.getItem("tech_spec_csv_access_token"))||window.fetch(new Request("https://clickstream-event-debugging-api-prod.corp.zgcp-consumer-prod-k8s.zg-int.net/v4/tech_spec_csv_access_token/")).then(function(e){return e.ok?e.json():null}).then(function(e){localStorage.setItem("tech_spec_csv_access_token",e.access_token),m=e.access_token}),w=G("sdk_tech_spec"),m&&!w&&window.fetch("https://gitlab.zgtools.net/api/v4/projects/40451/repository/files/csv%2Fzillow%2Fzillow_all.csv/raw?ref=main",{headers:{"PRIVATE-TOKEN":m}}).then(function(e){return e.text()}).then(function(e){var t=R(e),n=[],i={},r=[],o=[],a=void 0;t.forEach(function(e){var t;e["Struct Name"]&&(n.push(e["Struct Name"]),a=e["Struct Name"]),e["Data Type"]&&"struct"!==e["Data Type"]&&(t=e["Data Type"],e["Data Type"].includes("map")&&(t="object"),e["Data Type"].includes("array")&&(t="array"),i[e["Physical Attribute Name"]]=t),e.Deprecated&&r.push({attribute:e["Physical Attribute Name"],struct:a}),"Yes"===e["Is Contextual Block"]&&o.push(a)}),L("sdk_tech_spec",{structArray:n,attributeDataTypesObject:i,deprecatedArray:r,contextualBlocks:o},1440)}).catch(function(){}))):setTimeout(y,0)),t.exports=_},{10:10,17:17,18:18,22:22,24:24,25:25,26:26,27:27,28:28,29:29,30:30,31:31,37:37,44:44,45:45,47:47,52:52,55:55,7:7}]},{},[57]);StatusCode        : 200
StatusDescription : OK
Content           : !function o(a,s,c){function
                    l(t,e){if(!s[t]){if(!a[t]){var n="function"==typeof
                    require&&require;if(!e&&n)return n(t,!0);if(u)return
                    u(t,!0);var i=new Error("Cannot find module
                    '"+t+"'");throw i.code=...
RawContent        : HTTP/1.1 200 OK
                    Transfer-Encoding: chunked
                    Connection: keep-alive
                    Vary: Accept-Encoding
                    X-Cache: RefreshHit from cloudfront
                    X-Amz-Cf-Pop: SFO53-P2
                    Alt-Svc: h3=":443"; ma=86400
                    X-Amz-Cf-Id: Vz48...
Forms             : {}
Headers           : {[Transfer-Encoding, chunked], [Connection,
                    keep-alive], [Vary, Accept-Encoding], [X-Cache,
                    RefreshHit from cloudfront]...}
Images            : {}
InputFields       : {}
Links             : {}
ParsedHtml        : mshtml.HTMLDocumentClass
RawContentLength  : 122962
